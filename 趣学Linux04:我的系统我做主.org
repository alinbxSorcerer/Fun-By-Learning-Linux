* 第4章 装载Applience

经过了短暂的磨合，用户逐渐地熟悉了我这个Ubuntu操作系统，基本的上网、听音乐、看看视频之类的工作，都可以完成了。不过这自然还不算完，默认的外观，自带的软件，并不是每个人都用着顺手的。这不，懒蜗牛同学就开始着手把系统弄得更加个性化，更符合自己的习惯。

** 4.1　桌面

有道是人凭衣服马凭鞍，操作系统看外观。外观对于一个操作系统来说也是挺重要的，所以，最先被懒蜗牛同学改造的，就是图形界面的样子。
*** 4.1.1　默认桌面的配置

懒蜗牛同学看着我们默认的图形界面很不顺眼。为什么呢？因为窗口上的关闭、最大、最小化按钮竟然在左边，如图4.1所示。

[[./Images/image00345.jpeg]]

图4.1　默认的窗口布局

这导致每次懒蜗牛同学要关窗口的时候，鼠标都会划出一条很纠结的曲线------先向右上方去，发现按钮不在原来的位置之后又打轮拐向左上角来。听说我们这届的图形界面组那哥儿几个都是种苹果的出身，所以审美观点可能跟以往有些不同。不过没关系，我们Linux是为人类服务的，哪里看着不爽都可以改。

懒蜗牛同学上网学习了一下之后就开始动手了，过程并不复杂。

（1）首先启动命令行，并且运行gconf-editor，或者按下Alt+F2键，输入gconf-editor也可以。运行起来如图4.2所示。

[[./Images/image00346.jpeg]]

图4.2　gconf-editor界面

*提示：*gconf-editor是一个Gnome桌面环境的配置编辑器，有点像Windows系统中的注册表。不过Windows的注册表是用来管理整个系统的，而gconf-editor只管Gnome桌面环境相关的设置。

（2）懒蜗牛同学依次展开了左侧的apps|metacity|general文件夹，这时在右侧上方窗口显示出了相关的键值，就是类似图4.3这样（以后咱就简单地说xxx|xxx|xxx文件夹中的yyy键值了啊）。

[[./Images/image00347.jpeg]]

图4.3　选中条目查看信息

（3）双击右侧上方列表框里面的button\_layout键值，是个字符串类型的。把里面的内容改成这样：
: menu: minimize, maximize, close

改后就像图4.4所示这样，然后单击“确定”按钮，窗口上的按钮马上就回归到图4.5所示的风格了。

[[./Images/image00349.jpeg]]

图4.4　修改键值

[[./Images/image00350.jpeg]]

图4.5　修改后的窗口布局

除此之外gconf-editor还可以设置很多东西，下面介绍一些常用的吧。

　apps|nautilus|desktop目录中的computer_icon_visible键值，布尔型，用于控制是否在桌面上显示计算机。

　apps|nautilus|desktop目录中的trash\_icon\_visible键值，布尔型，用于控制是否在桌面上显示回收站。

　apps|nautilus|desktop目录中的volumes\_visible键值，布尔型，用于控制是否在桌面上显示已挂载的设备。

*提示：*gconf-editor的设置保存在～/.gconf/目录中，如果配置出现错误需要恢复默认设置，删除此目录即可。

窗口按钮顺手了之后，懒蜗牛同学又开始追求更加新奇的东西------3D桌面。

*** 4.1.2　扩展阅读：Xorg

本节在咱们说3D桌面时提到了Xorg，那么Xorg是个什么软件呢？

【Xorg是谁】

话说我们Linux系统里，系统跟图形界面是分开的。绘制图形界面的事情由专门的图形部门来负责。而图形部门的老大，就是Xorg。他会跟硬件打交道，会用显卡（当然，用显卡也得经过我），能在显示器上画东西，想画什么画什么，谁要想显示点东西给用户看，都得经过他。

【X协议】
# 协议=黑话
要想跟Xorg打交道，在显示器上显示出图形来，得懂他们图形部门的黑话------学名叫协议。他们说话使用一种叫做X的协议。一个程序通过X协议告诉Xorg要画什么，那么这个程序就是X-Client，而负责在屏幕上画的Xorg就是X-Server。反正要想显示图形，就得用这种黑话跟Xorg去说。每一个要显示图形的程序都得会这种黑话，比如狐狸妹妹（以下“狐狸妹妹”或“狐狸”特指Firefox），要显示东西，就说：“驼子碗，筛土的拋闪！”那意思可能就是说画一只猪。当然，这就是打比方，其实我可不懂他们的黑话（这一点不像Windows7，他本身兼职负责画图形）。

那么程序要画什么直接跟Xorg说就行了么？其实也行，比如Mplayer，他可以直接跟底层的X
Server交流，可那就像是在字符界面下看片了------没有窗口，图像没法移动，没法全屏，没法最小化。因为MPlayer只负责放片，像画窗口、移动窗口什么的这些事情他可不管。那谁来管呢？这时就需要一个窗口管理器。

【窗口管理器】

我们这里默认的窗口管理器叫做Metacity（就是Gnome下的默认窗口管理器）。程序要画什么东西其实是跟他说的，不直接跟Xorg说。比如Mplayer说：“画一只猪。”（当然是用X黑话）。于是Metacity转头告诉Xorg：“在某某位置画个方的窗口，在里面画一只猪。”过一会儿可能用户觉得Mplayer的窗口挡着他和MM聊天了（那是，猪哪有MM好看呀），就把Mplayer的窗口挪了挪，于是Metacity又对Xorg说：“把刚才那只猪和窗口往左移动3.2厘米。”这个过程Mplayer是不知道的，他只管专心地向Metacity描绘着影片中的一幅幅图像：“猪、走路的猪、跑动的猪、跌倒的猪、捆绑的猪、烤熟的猪......”

*提示：*如果安装了Compiz，则Gnome界面将使用Compiz作为窗口管理器。

** 4.2　浏览器

懒蜗牛同学安装了Compiz
Fusion，打开了3D特效，桌面看上去比以前好看了不少。接下来，懒蜗牛同学又开始挑选合适的网络相关的软件了。

*** 4.2.1　满身插件的狐狸妹妹
安装常用插件-略

*** 4.2.2　会分身的Chrome

懒蜗牛同学和狐狸妹妹又缠绵了一阵子，才终于想起来------哦，对了，我是想装Chrome的，明明是要换用自己顺手的浏览器，怎么差点被狐狸迷惑了。他赶紧找到下载的Chrome的deb包。由于懒蜗牛同学没有更改保存地址，狐狸妹妹就把下载的东西存在了懒蜗牛同学的家目录下的“下载”目录。

*提示：*所谓家目录，就是/home目录下以用户名命名的那个目录。比如lanwoniu用户的家目录就是/home/lanwoniu。每个用户只能在自己的这个家目录下进行操作，其他的目录没有权限。

*提示：*Linux中可以使用“～”符号代表家目录。例如，对于user1用户，运行ls～就相当于运行ls
/home/user1，而对于user2用户则相当于运行ls/home/user2。

懒蜗牛同学找到了deb文件，双击安装。不一会，apt就按照操作流程解开了这个deb包，从里面拎出一只浏览器。

【用多进程追求速度的极致】

这家伙长得色彩斑斓，红黄绿蓝四色相间，样子简简单单，倒也清爽。大家没来得及仔细看，这家伙就被apt带进硬盘里安排住处去了。狐狸妹妹有些不高兴地说：“哼，回头倒要看看他有什么本事。”是啊，这家伙来了自然就会抢狐狸的饭碗，难怪狐狸不高兴。

没过一会儿，Chrome就被懒蜗牛同学叫起来干活了。Chrome一跑进内存，一下子变成了4个Chrome！也就是分出4个进程。他们在工作间里窜来窜去，那叫一个热闹。4个Chrome分别忙着各自的工作，有的负责向图形界面申请窗口；有的负责在窗口上绘制各种标签和按钮；有的打开网口，访问默认的主页。虽然这么多进程挺闹腾，倒也是各司其职，有条不紊。而且这样一来，这些事情是同时进行的，效率就会高一些。很快，Chrome就为用户显示出了一个简洁的界面，如图4.20所示。

[[./Images/image00366.jpeg]]
图4.20　Chrome运行界面

*提示：*可以用ps --A命令来查看当前运行的进程。
#+BEGIN_SRC shell :results output
ps -ef |grep firefox
#+END_SRC

相比之下我们的狐狸妹妹就比较本分，一步一步进行。先向图形部门申请绘制窗口，窗口批下来之后再在窗口中绘制好各种文字、菜单、按钮之类的。这之后再根据用户设置的主页，上网申请数据，数据来了再显示给用户。如果有插件，在这之前还要加载各种插件，难怪有人觉得狐狸有点慢呢。

这还不算完，等到懒蜗牛同学真的开始使用Chrome浏览网页我才知道，原来这Chrome不只是4个，随着打开的网页越来越多，Chrome不断地复制自己，工作间里的Chrome进程也越来越多。好家伙，转眼间工作间里就看不见别人了，到处都是Chrome。不过好在他们每个占用的资源都不多，因此也不会给别人带来什么麻烦，这也算是Chrome这家伙的特色之一吧。

【争夺默认浏览器的地位】

Chrome来了以后，这工作间里面就开始不太平了。狐狸妹妹和他谁也不服谁，整天吵架。系统中可以有很多浏览器，但是默认的浏览器只有一个。原本默认浏览器当然是狐狸妹妹，可当Chrome启动的时候就显示出图4.21所示的这个界面来告诉用户：我不是默认浏览器，把我设成默认浏览器吧。

[[./Images/image00367.jpeg]]
图4.21　Chrome询问是否设置为默认浏览器

如果用户把Chrome设成默认浏览器，狐狸妹妹启动时也会向懒蜗牛同学抱怨：“以前我是默认的，干得好好的怎么就换了呢？您还是给我设回来吧。”也搭上我们的懒蜗牛同学没准主意，墙头草，随风倒。今天设狐狸为默认的，明天改Chrome是默认的。

*提示：*可以手动设置默认浏览器，单击“系统”|“首选项”|“首选应用程序”，选择Internet标签，如图4.22所示，在上方“Web浏览器”对应的下拉列表框中选择即可。

[[./Images/image00368.jpeg]]
图4.22　设置默认浏览器

不过最终懒蜗牛同学还是确定了狐狸妹妹的默认浏览器地位，毕竟是我的原班人马嘛。别的不说，由于狐狸是软件源里的软件，所以如果有个什么版本升级BUG修复之类的，都是自动的。那时apt（以下“apt”特指apt）会接到Canonical学校发来的通知：狐狸同志，工作一向兢兢业业，刻苦提高技术水平，今经组织决定，晋升狐狸为x.xx版本，建议进行升级。得到用户的同意之后，apt就去下载来新的部件，把我们机器里的狐狸按照学校提供的步骤改装成新的狐狸。

我带来的每一个软件和通过apt安装的软件都有这种待遇，而像Chrome这种从网站上下载来安装的软件就不行了，要想升级，只能再去网上下载新的版本，自己重新安装。

*提示：*软件源里有Chromium浏览器，算是Chrome的试验版。如果喜欢Chrome风格但又希望它能跟随系统进行更新，可以安装源里面的chromium-browser这个软件包。

所以Chrome们整天不服气，跟狐狸说：“你也就是因为有靠山，那"乌棒兔"内核跟你一伙的，所以才能容得你这么飞扬跋扈。”狐狸自然也不肯罢休：“你那样子又有什么好了，再说了，要变成你那样子简单得很。给我装上Chromifox
Basic主题，再装上Total Rechrome扩展倒置标签兰和地址栏，最后装个Hid
Menubar扩展隐藏掉菜单栏，跟你也没什么区别。只不过用户不愿把我打扮得像你那么难看罢了。”另一只Chrome反唇相讥：“哼，变成我们这样有什么用，装那么多插件扩展的，臃肿啊，哪像我们简洁高效。”狐狸怒道：“你想装这么多插件还没人给你开发呢！”

*提示：*目前最新版的Firefox默认界面已经逐渐向Chrome学习，不需要安装什么扩展也很精简。

*** 4.2.3　干净利索的Opera

后来，懒蜗牛同学又先后安装了很多浏览器，有极其简约的Uzbl，有轻巧的Epiphany，有简陋的dillo，甚至纯字符界面的lynx和links都装上了。他装这么多浏览器干啥？一块运行起来看热闹玩？当然不是，他是在体验，在选择，寻找最适合自己的那一款浏览器。

我们Linux世界里的软件总是多种多样的，同样功能的软件可能会有很多款，而且特色各异。每个人都可以找到适合自己的那一款。甚至如果没有哪款合你心意的，还可以通过修改某个浏览器的代码（因为多是开源的嘛），来创造出你自己喜欢的浏览器来。比如狐狸妹妹深受广大用户喜爱，然而就是干活速度有些慢，于是有人就在狐狸代码的基础上加以改进，出现了疯狐狸（MadFox）浏览器。这就是Linux的世界，在这个世界里，人类才是软件的主人。

*** 4.2.4　使用aria2下载
*** 4.2.5　扩展阅读：软件位宽

上面提到了，我是一个64位的操作系统。到底这个64位、32位说的是什么意思呢？

【运算位数的限制】

这个多少多少位，说的是CPU一次运算的二进制数字的位数。这个CPU就像是个计算器，我们软件用CPU就像人类用计算器似的。它很重要，我们要算一丁点东西，也需要用CPU来算（别跟我说用心算，我是软件，OK？）。

但是这个CPU算东西的能力，是有限制的，有什么限制呢？你拿出你家的计算器看看，算个28+783，没问题是吧。算个7836--473也没问题是吧，再算个72635446584939202937346537+1，能么？估计99％的同志出问题了（不排除有牛人拥有很牛的计算器）：“我哪能按出这么多数来啊，我这计算器总共就能显示得下11位数字”。对，这就是计算器的位数限制。

CPU也一样，一次能算的数不能无限大，总得有个边，只不过不是按照十进制的位数算的，而是按照二进制的位数算的。至于什么叫十进制，什么叫二进制，可以去问问狗狗大哥，不过不知道也没关系，咱暂时按照咱们平常的十进制来说。
# 好,google狗狗大哥
【软件操作CPU的过程】

我们软件使用CPU运算的过程和你们人类使用计算器是差不多的。比如说，我这有个计算器只能算99以内的数字，也就是只有2位（也不知道谁设计的这么弱智的计算器）。那么我用这个计算机算个3+4怎么算呢？简单，输入3，按+号，再输入4，按=号，就出来了。再算个大点的，算个56+47。先输入56，按+号，再输入47，按=号。咦？显示03，怎么不显示103呢？废话，它倒是想显示，往哪写那1呀？但是我用的这个计算器（也就是CPU啊）是很人性化的，会提示你运算结果超出了它的能力范围。比如可能会有个红灯亮起，提示你03前面还有一个进位，进到百位了。
# 解释得好.

【高位宽CPU的优势】

好了，基本的操作说完了，现在说正题，不同位数的区别。两位的CPU就像刚才说的那样，那么假设现在需要计算3173+644，这里有2位的CPU一个，4位的CPU一个，分别用他们做这个计算，有什么区别呢？

咱先看这2位的，有人说了，2位的只能算两位啊，这个没法算哪？唉，这机器是死的，咱软件是活的啊，一次只能算2位，咱不会分开多算几次么。首先，输入73，按+号，再输入44，按=号。显示出来17，同时红灯一亮，说明还得进位。好，找张纸记下17这个数，还得写上“得进位”。然后再输入31，按+号，输入6，按=号，显示出来37。别忙，没完，刚才还得进位么不是，再输入37，按+号，输入1，按钮，咔嚓，出来38。好，最后结果拼一块，高位是38，低位是17，最后结果：3817。

再拿这4位的算算看。4位的就意味着输入的和显示的数最大可以是9999，也就是说我直接就可以输入3173，按+号，再输入644，按=号，显示出来3817，OK，收工。

*提示：*目前市场上常见的CPU都已经是64位CPU。

【软件位宽与CPU位宽的关系】

这就是2位的CPU和4位的CPU的不同，从理论上来说，4位的要比2位的快，从上面的例子看得很明显嘛，大一点的数，4位的CPU一下就能算完，2位的CPU要折腾好几次。但是这4位的CPU还得有人会用才行，这就需要4位的软件来用这个4位的CPU。

终于说到软件的位数了，CPU的位数就是一次能计算多少位的数，那软件的位数呢？就是说明这个软件需要使用多少位的CPU。软件干活肯定需要计算，计算就得用CPU，2位的软件会用2位的CPU，4位的软件就会用4位的CPU（还是拿十进制位做比喻啊）。比如有一个2位的软件，当他运行在一个2位CPU的电脑上的时候就是这样：比如要算3173+644，他就会先算73+44，然后记住进位，然后计算31+6，然后加上进位，最后拼起来，得到答案，就像上面描述的那样。那么当这个2位的软件运行在一个4位的CPU上的时候会怎么样呢？他会先算73+44，然后记住进位，然后计算31+6，然后加上进位，最后拼起来，得到答案......有人说了，他怎么不直接算啊？4位的CPU不是能直接就算出来么？但是别忘了他是2位的软件啊，他不会用4位的CPU，但是不会用不等于完全不能用，他还是可以拿4位的CPU当成2位的来用，只是有些浪费而已。

*提示：*64位Ubuntu系统中自带的软件，以及通过软件源安装的软件，除某些不开源的软件外，都是64位的。

那么要想完全发挥4位CPU的性能该怎么办呢？当然就得4位的软件出场了。当一个4位的软件运行在一个4位的CPU上时怎么计算3173+644呢？大家大概都知道了，直接算，一次完成。那么当一个4位的软件运行在一个2位的CPU上时会怎么样呢？这个软件会写个3173的纸条要往CPU的寄存器里塞，急得满头大汗就是塞不进去，最后一甩手------老子不干了，这破CPU没法用！当然，这只是个比喻，并不是说4位软件在2位CPU上算3173+644就算不了，算1+1就能算。4位的软件是根本无法运行在2位的CPU上的。

*** 4.2.6　扩展阅读：进程

咱说Chrome是个多进程的浏览器，一运行就复制出好多进程来。有人可能对进程这个名字还不是很明白，什么是进程呢？

【进程的概念】

简单地说，进程就是正在干活的软件。比如狐狸妹妹，躺在硬盘里睡觉的时候她就是一个软件、一堆数据、一坨代码。当她被叫醒，跑进内存里开始干活的时候，她就是一个进程了（当然，其实这么说不很准确，但可以姑且这么理解）。换句话说，内存里忙忙碌碌的，都是一个个的进程。当然，同时他们都是程序、都是软件，这不冲突。

就像去公司上班的人，他们都是人，当他们在公司工作的时候，他们都是公司的员工。员工，就像进程一样。很多公司的员工每个人都有个工号，什么NB001，SB999之类的；每个进程也都有一个唯一的标识------进程ID号，简称PID。这个ID号是由我分配给每一个跑进工作间的进程的，分配的规则很简单，每人一个，每次加一。第一个跑进来的就是1号，在我们Linux系统里，有个叫init的家伙每次都是第一个被我叫起来，帮我打理一下日常工作，所以他的ID号总是1。而且，他还有个特殊身份，这个咱暂时保密，待会儿再说。
# 宇宙大爆炸的七点.
*提示：*init一般位于/sbin/目录下，内核启动后会首先调用此程序，进行一些初始化工作。
#+BEGIN_SRC shell :results output
ls /sbin/ |grep init
#+END_SRC

#+RESULTS:
: init
: mkinitramfs
: telinit
: update-initramfs

【管上级叫爹】

每个公司的员工都有个直属的上级，上级又有上级，依此类推。我们这里的进程也是这样的，只不过我们不叫“上级”或者“上司”，我们叫------爹！好吧，似乎这个称谓土了点，但是就是这个意思。一个进程之所以成为一个进程，一定是由于另一个进程创建了他（有点绕嘴吧）。比如说用户开了一个终端，于是就有了一个bash进程，然后用户在这个终端里敲入firefox并回车，bash就去找狐狸妹妹，把她带到内存里开始工作，于是就创建了一个firefox进程。好了，现在，firefox这个进程是由bash这个进程创建的，那么，bash这个进程就是firefox这个进程的父进程，firefox进程就是bash进程的子进程。也就是说，狐狸妹妹就得管bash叫爹！那bash也得有个“爹”吧？是的，如果是在Gnome环境下开的那个终端，那么bash他爹就是调用bash的gnome-terminal。

既然每个进程都有爹，爹进程又有爹，如此循环往复，肯定有一个站在金字塔最高点的总“爹”吧？难道，难道"乌棒兔"你就是他们的总爹？很遗憾，我不是，所有进程的总爹，是每次启动第一个被我叫起来的init。所有的进程都是被init直接或者间接创建的，所以init才是所有进程的祖宗！

关于父进程，有两点要说明。

第一，我们这的父子关系不是固定的，是会变换的。如果从bash启动Firefox那么bash就是Firefox的爹，如果直接从图形界面启动那就没bash什么事情了（这时候Firefox的爹其实是init）。

第二，不要问我哪里有妈进程！

*提示：*父进程的说法源自英文parent process。

【当爹的义务】

当爹也有当爹的义务，人家不能白叫你一声爹是不是。当自己的娃（也就是子进程啦）做完自己该做的工作以后，就停止了一切动作，像个死尸一样待在那里，当爹的就负责给他“收尸”。

一个结束了所有工作的进程，会处于一种“僵尸”状态，这时候他什么也不做了，就等着被干掉。进程进入僵尸状态前一般会通知他爹一声，汇报一下说：爹啊，俺已经把该做的都做啦，现在我要变僵尸啦！（让后平伸双手开始行走？那是生化危机！）然后他爹负责向我汇报：我家娃干完活了，你把他的工号（就是PID，记得吧）取消掉然后让他回去睡觉吧。然后我就把它的工号收回，看看他有没有什么申请了没释放的资源（一般一个好孩子在结束运行成为僵尸之前，会主动释放掉自己申请的资源的）。确认都没问题了之后，他就被从我的进程列表中清除了。

*提示：*所谓进程申请的资源，包括进程申请过的内存、打开的文件、Socket连接等。

【当爹遇到意外】

但是有时候也会有些特殊情况，比如有的时候娃还在兢兢业业地干活呢，结果他爹死了（可能他爹干完活退出了，也可能被用户用命令kill了）。这个时候我就会发个信号给他家娃说：那个......娃呀，那啥，跟你说个事，你爹死了。

这时候有的娃就悲痛欲绝：俺爹都死了俺活着还有啥意思啊，呜呜呜......俺也僵尸吧。然后他就退出了。比如你在终端运行Firefox，然后把终端关了，Firefox也就退出了。

也有的娃比较坚强，一定要完成上级交给的任务，化悲痛为力量。这时候我会给他找个新爹------因为每个进程总得有个父进程，没爹是不行的。一般我会安排他爹的爹来当他的爹（又绕进去了吧），也就是这个进程原来的“爷爷”进程来当他的父进程。然后这娃在长了一辈后，继续认真工作。比如你在终端运行nohup
firefox，然后把终端关了，Firefox继续运行。那如果他爷爷不幸也挂了呢？那就继续往上找吧，我们说了init是所有进程的祖宗，所以他那里就成了最终的“无依靠青年进程收容所”。

如果init也挂了呢？那系统就挂了，重启吧！

*提示：*父进程退出时，系统会向子进程发送“挂断”信号（SIGHUP），子进程是否退出取决于子进程如何处理挂断信号。

【当爹和娃同时出意外】

还有的时候娃已经把该做的事情做完了，汇报给他爹并变成僵尸。可是他爹还没来得及给自己娃收尸，自己就先挂掉了，这个时候就有点麻烦了。

首先我没法通知那娃说她爹挂了，因为那娃已经是僵尸了，啥也不听啥也不干了。其次我也不能直接把他干掉，啥事情都得按规矩来嘛，只有他爹向我申请我才能把他干掉，可是他爹又已经挂了......那怎么办呢？那就按流程来，先给这个娃找个爹，哪怕这娃已经是僵尸了，也得有个爹。一般我会找到init说：那个ID号是2725的进程爹死了，你当他爹吧。一边说一边看也不看地用手往那边一指，假装自己没看到那娃已经成僵尸了。一般init也不会太注意，直接就答应了，然后马上发现了事情的真相，跑到我这里来说：那娃已经成了僵尸啦，你还叫我收养个啥？我肯定会一脸无辜状：啊？是啊，那不管怎样，你是他爹了，你负责处理一下后事吧。于是init只好以爹的身份处理那个僵尸的后事，问题就这样解决了。

** 4.3  影音

狐狸妹妹今天接到懒蜗牛同学的任务，要去下载一部叫做《Big Buck Bunny》的电影。说是电影，其实就是个短片，还不到10分钟。并且它还有个最大的特点------它是开源的。好，废话不多说，狐狸妹妹已经用她的Downthemall扩展把这个短片下载下来了，于是，就引出了一场播放器之间的斗争。

*提示：*所谓开源电影，是说它是在开源的平台上用开源的软件制作的，并且免费下载观看，还可以获得它的原始制作文件。
*** 4.3.4　扩展阅读：解码器与硬解码

本节提到了视频文件有编码，播放器要用解码器。这个视频文件都是有一定的编码方式的。比如大家都听说过MPEG吧，就是MovingPicture Experts
Group，动态图像专家组，听这名字本来是用来指代一小撮明白真相的群众的，不过后来这一小撮群众发布的标准被广泛使用，于是MPEG就成了指代这一小撮群众定义出的那一大撮标准的名词了。

【编码，从MPEG-1到MPEG-4】

MPEG-1是小撮群众在1992年定义出的一个标准，是一种视频和音频的编码方式。大家记得以前的VCD不？VCD光盘上的视频和音频用的就是MPEG-1这种编码标准。而MPEG-1标准中关于音频的部分------MPEG-1
Layer3，更是成为互联网上及大家口袋里最常见的音频标准------MP3。

后来，1994年，这一小撮明白真相的群众又发布了MPEG-2标准。MPEG-2向下兼容MPEG-1，并增加对隔行扫描的支持，被应用于有线电视，还有DVD的音频视频编码。

再后来，这一小撮群众又开发了MPEG-3，注意MPEG-3跟我们的MP3没有任何关系，而且，MPEG3最终没有得到很好的应用，因为当时人们发现MPEG-2足够了，MPEG-3并没有提供足够好的改进。

而1998发布的MPEG-4就不一样了，它可以让视频文件的体积更小，压缩率更高，因此得到了广泛的使用。现在市场上卖的MP4播放器，就是用来播放MPEG-4压缩的视频文件的设备。所以，MP4跟MPEG-4有关，而MP3跟MPEG-3无关。
.
【软件解码】

说了这么多，回过头来说说解码。

视频文件都进行了一定的编码，比如MPEG-2，或者MPEG-4。就是说这个视频文件里面的东西都是一大堆乱七八糟的数字，要想看这个视频文件，就得解码，也就是根据这一大堆数字算出应该显示的一帧一帧的图像，并且把这些图像连续播放起来，从而还原成视频。那么这个解码的过程就要靠Mplayer老先生了。

老先生有很多的解码器，也就是有很多的说明手册，上面写了每种编码格式的文件应该怎么计算，怎么解码。那么以前没有硬件解码的时候，Mplayer老先生是怎么做的呢？首先，拿到一个视频文件，然后看看是什么编码的，对着自己的手册，开始解码。解码的过程就是计算的过程，计算需要用什么？那位同学回答了，得用CPU啊。于是Mplayer一手拿着手册，一手拎着数据找到我，请求使用CPU（我是操作系统嘛，软件要用CPU得跟我申请）。我说，好的，你就排在GIMP的后面，等他用完了你用。过一会儿GIMP用完了CPU，Mplayer过去开始拿CPU按照手册上写的算法算他那堆数据。最后算出来，得到了几张图片，就转身把图片给图形部门，让他们去显示。然后再从那个视频文件里拿一些数据，再来排队等着用CPU。

由于视频文件的计算量都很大，尤其是高清视频尤其大，因此为了保证蜗牛看的电影不变成带旁白的幻灯片，我就要尽可能地让Mplayer多用CPU，来保证他能顺利地解码。于是，每次Mplayer一播高清视频，CPU就总被他占着，搞得别的程序都抱怨。

【硬件解码】

如果他终于学会硬解码了，情况就好多了。当然，光他学会硬解码也不行，关键是显卡也得支持，而且驱动还得装好才行，不过这些咱现在不讨论，先说Mplayer。

会了硬解码之后怎么样呢？在播放视频的时候一手拿着手册，一手拎着数据找到我，跟我说要用用显卡。可不是CPU了啊，改用显卡了。于是我就很乐意地让他去用了，反正别人也用不着，让他自个玩去吧。于是他就去用显卡算去了。用显卡算和用CPU算不一样，CPU虽然强大，虽然啥都能算，但是要自己手动算。就是说自己要知道算法（对于Mplayer来说，算法都在解码器上写着呢），比如要算出一帧的视频来，要先用第1个数加上第2个数，再用结果乘以第3个数之类的。这里加啊，乘啊，都是用CPU算的，但是中间的过程是要软件（也就是Mplayer）自己控制的。可是用显卡解码就不一样了，人家那东西是专门解视频的啊，所以你只要把数据放在里面，直接就能给你算出一帧帧的画面来。全自动啊！于是Mplayer不但不用跟别的软件抢CPU了，而且解码的速度还快了不少。

*提示：*显卡上的GPU在计算并行计算方面比CPU更加强大，因此硬解码可以获得更快的速度。
# 原来如此.

** 4.4　图像

今天一起床就接到了一个任务，听起来还挺轻松，一般胡同里大妈大婶的，经常做这项工作，并且乐此不疲，那就是------串门。不过我去串门可不是聊天去的，我是去做搬运工，要把一些图片复制到我们Ubuntu系统的硬盘里。估计懒蜗牛同学是想处理照片了，这回，图像处理部的那几个软件有事干了。

*** 4.4.1　GIMP
*** 4.4.2　扩展阅读：磁盘碎片的产生

前面我们说到了Windows7那里有磁盘碎片。什么是磁盘碎片呢？它是怎么产生的？下面我就给大家讲讲这个磁盘碎片。

【Windows 7管理硬盘的方式】

同学们都坐好，都把手机铃声关了，小灵通调成震动，BP机直接扔了------台都没了你还留着它干嘛。好，上课了，首先说说什么叫磁盘碎片。

磁盘，是我们程序居住的空间，我们用不同的方式对整个磁盘的空间进行管理。前面说过，包括各种方式，什么ext4、xfs、ntfs等。而磁盘里放的东西，就是一个一个的文件，同学们可以把磁盘想象成你家的屋子，文件就像一个个大大小小的箱子。每个箱子上面写着字，就是文件名。Windows7喜欢把每个箱子都紧挨着放，一个挨一个，上下左右前前后后都紧贴着。这样，看上去很规整，可以让剩余的空闲空间比较完整。有同学说，我家也这么收拾，这样很利索呀。不过，对于操作系统，这样做虽然有好处，但是也会有一些问题。

*提示：*Linux对磁盘的管理机制不同，文件存放位置相对分散，因此不容易产生碎片。

【文件增大产生碎片】

比如，一开始存了一个文件，也就是搬来了一个箱子，比如叫“日记”。Windows
7把它放在最靠墙的位置。后来又存了很多其他的文件，在“日记”文件的前前后后，左左右右，上上下下都放满了。忽然这一天，日记文件被修改了，加了点内容，就相当于往“日记”那个箱子里加了东西。可是箱子已经满了，再往里加，箱子就要增大（也就是文件大小变大，毕竟是比喻，不是真的箱子，大家不用费脑子想箱子怎么会伸缩）。可是箱子周围堆满了其他的箱子，没地方了，怎么办呢？

可以把边上的箱子挪开一点，原来的箱子就可以扩大了。可是边上的箱子要是少还好办，要是很多，还都装了铅块铸铁大理石什么的，那可就累死了。那怎么办呢？只好把新的内容放在另一个小点的箱子里，放在别处。然后还得在原来的“日记”箱子上标注上“日记（第1部分，第2部分在东墙根）”。然后在新的箱子上写“日记（第2部分，结束）”。日子长了第2个箱子也被很多箱子挤在中间后，又要编辑日记文件，这个文件又变大了，就又要如法炮制出第3个箱子，乃至第4个，第5个......

【碎片太多影响性能】

等到有一天，要读取这个日记文件的时候，Windows7就忙开了------首先，到西墙角找到日记第1部分，翻腾出里面的内容，然后往箱子上一看“第2部分见东墙根”，然后再跑到东墙根找第2个箱子，翻腾出里面的内容，再一看箱子“第3部分见大衣柜上头”，然后又搬梯子，上大衣柜一看“第4部分在厕所水箱后边”......等到Windows7把整个日记文件读完了，也累得半死了。这种情况，就是会影响性能的磁盘碎片。好，本节课到此结束，同学们自由活动吧，那位同学，快去捡你的BP机去吧，说不定还能找着。

** 4.5　办公软件

今天蜗牛打开电脑，破天荒地先去叫醒了OO老先生，往常都是先去叫醒狐狸妹妹或者去找那个World of Goo玩一会儿。今天找OO老先生干什么呢？

*** 4.5.1　LibreOffice
*** 4.5.2　翻译软件
*** 4.5.3　电子邮件Evolution和雷鸟

** 4.6　我的杀毒中心

虽然我们Ubuntu系统作为家庭用户的桌面版没啥中毒的机会，因此也没有装杀毒软件的必要，但是给我们装个杀毒软件，帮别的系统杀杀病毒还是不错的。这不，懒蜗牛同学就机缘巧合地开始研究Ubuntu系统下的杀毒软件了。

*** 4.6.1　Linux下也有杀毒软件

事情是这样的。懒蜗牛同学写好了简历后，把简历存储在他的U盘里拿去打印。然而这个学校的公共电脑，尤其是天天插各种U盘的连接打印机的那台电脑中，基本上快成病毒博览会了。懒蜗牛同学的U盘往那台机器上一插------无悬念命中。

懒蜗牛同学发现U盘染毒之后，马上想到了我们Ubuntu系统对病毒免疫（准确地说是对Windows病毒免疫）。于是打算把U盘插到我们系统上，备份好U盘里面的重要文档之后，把U盘整个格式化一遍。但转念又一想，这样也太没有技术含量了，不如在Ubuntu系统中装上杀毒软件，把U盘上的病毒杀掉。对，说干就干！

那么Linux系统下也有杀毒软件么？当然有，下面就给您介绍几个。

【Avira AntiVir Personal】
【ESET NOD32 Antivirus for Linux Desktop】
*** 4.6.2　Linux下杀毒毫无压力

懒蜗牛同学经过筛选，决定安装avast来完成他的U盘杀毒工作。于是，我们几个软件马上开始干活：狐狸妹妹Firefox掏出Downthemall扩展把avast的deb格式的安装包下载下来；apt负责将安装包解开，掏出里面的avast并把他安顿在硬盘里；之后，我接到了蜗牛用户的指令，把avast叫起来干活。

avast进入工作状态之后，先去网上下载了最新的病毒库。这个病毒库就相当于一沓子通缉令。那上面写着各种已知病毒的名字、相貌特征、作案手法等信息，以便avast在杀毒的时候查对。下载完毕之后，就见avast收拾好工具，整理一下装备，向着懒蜗牛那狭小的U盘出发了。

【活着的病毒不好杀】

要说起病毒来，Windows系统还真是挺害怕它的。无论是Windows 7还是Windows
XP，或者更早的Windows系统，都需要杀毒软件的保护。针对Windows系统的病毒多种多样，各有各的本领，真是八仙过海各显其能。

有的病毒会伪装成别的软件。比如Windows
7叫醒“记事本”去干活，却不知真正的记事本已经被病毒一棍子打死了。现在躺在那里，长得跟记事本一样的家伙，其实是整了容的病毒。有的病毒能够藏在正常的程序里面。一个正在工作的IE同志，很可能工作服的兜里就隐藏着病毒。并且现在多数的病毒都会随着Windows系统一起起床。当Windows
7被叫醒，伸个懒腰揉着眼睛走进内存的时候，他庞大的身躯后面可能正趴着40多只病毒。

由于病毒是活的，要杀掉它们很困难。它们可能会有很多人共同作战：杀毒软件杀掉了内存里的强夫，内存里的大熊会把硬盘里强夫的复制版再叫起来。扭头杀毒软件去杀大熊，强夫会把杀掉的大熊抢救过来，结果谁也没被杀死。有的病毒更暴力，自己先跑进内存，一看见有杀毒软件要进来，立刻过去一铁锹把杀毒软件拍死，然后藏起铁锹装着杀毒软件的声音说：“杀毒软件成功启动，没有发现病毒，噢耶！”有的病毒还能监视IE，一旦他要访问什么杀毒防毒相关的网站，二话不说，直接将IE干掉！

综上所述，要想在Windows系统中杀光这些活着的病毒，还是有很大难度的。

【睡着的病毒不反抗】

但这回avast去杀毒就简单多了。因为他杀毒的时候，电脑中运行的是我们Ubuntu系统。Windows的那些病毒根本无法在我们的系统中运行，就像死掉一样只会躺在硬盘或者U盘里睡觉。这时它们不会有任何反抗能力。avast过去，只要根据通缉令一一对照并干掉即可。只听到U盘里边不时传出“啊！”“呃......”“哎呦～”“我死得好惨呐！”等惨叫声。过了一段时间，avast回来向蜗牛报告：“共发现病毒7种，总计214只，全部歼灭。”

从那以后，懒蜗牛又装了几款其他的杀毒软件，并经常帮他的同学和朋友清理各种移动设备上的病毒。谁有什么带毒的，不敢往自己电脑上插的设备，都要先插到蜗牛同学这台百毒不侵的电脑上处理一下，才敢使用。懒蜗牛同学成功地依靠我们Ubuntu系统，把他这台电脑打造成了一个杀毒中心！

** 4.7　本章小结

这一回中，懒蜗牛同学算是过足了装软件的瘾了。上网用的浏览器挨个换了一个遍，下载软件、媒体播放软件、图片处理软件、办公软件、杀毒软件，都是挑了又挑，选了又选，终于都找到了自已用着顺手的一款。说明这Linux下的软件，还是挺丰富的吧。

那么这些软件能不能完全满足懒蜗牛的需要呢？会不会有什么软件在Linux下找不到替代品呢？咱们下回再说。

#+BEGIN_QUOTE
概要:
内存碎片, 软件解码与硬件解码.
#+END_QUOTE

**
