#+TITLE: 趣学Linux
* 概要
本书是一本与众不同的Linux入门读物。作者借鉴历史畅销书《明朝那点事儿》的写作风格，将技术图书以风趣幽默的风格娓娓道来，阅读起来十分过瘾。书中以一个拟人化的Ubuntu操作系统为主角，以Ubuntu 10.04为基础，讲解了Ubuntu系统从安装、配置，到搭建开发平台、投入使用的过程。
本书共8章，内容容安排上采取循序渐进的方式，由浅入深地引导读者安装、配置、使用Ubuntu系统。

1) 第1章介绍Linux系统的产生和发展概况；
2) 第2章介绍Ubuntu系统的各种安装方法；
3) 第3章介绍安装系统后的基本设置；
4) 第4章介绍Ubuntu下的常用软件；
5) 第5章介绍Windows下的部分软件在Linux中运行的解决方案；
6) 第6章介绍命令行的使用及脚本的编写；
7) 第7章介绍Ubuntu系统下C/C++、Java、PHP开发环境的搭建；
8) 第8章深入讲解一个软件的编译、调试、打包、发布的过程。

以上.
# 后面的三章是关键点. 最早阅读这本书是在远洋一方的草坪上.
# 再次阅读时候, 收获便是将其意像化.
再次处理的话可以分为三个部分
1. 介绍linux的发展历史
2. 1) 安装ubuntu,起手式 2)安装后的基本配置 安装配置
3. 配置好之后便是常用的软件, 要开始工作嘛,
   windows下部分软件的解决方案.

* 第1章 源起

我们将要讲述的故事，发生在一个你可能不熟悉、不了解，却又几乎天天都会接触到的世界。那里可闻鸟语却无花香，那里不见天日却色彩斑斓------那就是软件的世界。而我们的主角，就是一个软件，一个操作系统------Ubuntu。不过主角总是不着急登场的，在他露面之前，我们先来说说这位主角，以及跟他有血缘关系的几个操作系统的诞生过程。
# 引子好

** 1.1 UNIX的诞生

UNIX是一个强大的操作系统，稳定程度令人发指。要说UNIX，那得从20世纪60年代的美国开始说起。

*** 1.1.1　操作系统的从无到有

20世纪60年代，计算机可是个新鲜玩意儿，没有现在这么普及，而且非常笨重，都是用在商业或者科学研究领域，家庭用户想都不用想。而且那时候的计算机远没有易用到70多岁的赵大妈都能拿它来斗地主的地步。那时候使用计算机需要由专业人员通过输入一条条的指令，来进行各种运算。他们输入的指令大约相当于现在的汇编指令，所以效率和操作难度有多高就可想而知了。那时候计算机大都没有什么操作系统，顶多有个批处理系统，可以把要输入的指令记录在某种媒介上（比如纸带，如图1.1所示）一次性输入进去，省去了重复输入指令的麻烦。
# 批处理系统
[[./Images/image00219.jpeg]]

图1.1　打孔纸带

后来慢慢有了很简单的操作系统，但并不像现在我们见到的操作系统这样通用。这个时候，卖计算机的厂商要为每个型号的计算机设计不同的操作系统，一个程序在这个型号的计算机上写好了，如果想拿到其他型号的计算机上运行，就需要再重新写一遍，因为这两台机器的硬件组成、操作系统等都不一样。

计算机要是就这样下去，那么70多岁的赵大妈就别想玩斗地主了。所幸这个斗地主的问题，后来被那个时代IT业界的大地主，蓝色的IBM公司率先着手解决了。1964年IBM公司推出了一个系列的大型机，用途、价位各不一样，但它们上面运行的操作系统，都是System/360，图1.2所示就是其中一个。IBM的这一举措为其带来了很大的利润，因为省去了为每一台电脑单独编写系统的成本。直到今天，IBM的大型机上依然可以运行这个360系统，可见其当初设计时充分考虑了兼容性。然而我们要讲的主角不是360，而是另一个伟大的操作系统。

[[./Images/image00220.jpeg]]

图1.2　IBM的System/360大型电脑

*** 1.1.2　有牛人的地方就有新技术

- 【在那牛人聚集的地方】

那时候有个聚集了很多牛人的地方，叫做贝尔实验室，是1925年由AT&T公司成立的，就是图1.3所示的这个地方。一帮头脑发达四肢也不一定简单的家伙整天聚在那里，研究新奇的东西，什么任意门啊，竹蜻蜓啊......都不是他们发明的（听说发明这些的人是个日本科学家）。贝尔实验室那帮人的研究工作大致可以分为3个类别：基础研究、系统工程、应用开发。
在基础研究方面主要从事电信技术的基础理论研究，包括数学、物理学、材料科学、计算机编程理论等，反正都是大学时听不懂的那几门就是了。
系统工程主要研究构成电信网络的高度复杂系统。
应用开发部门是贝尔实验室最大的部门，负责设计构成贝尔系统电信网络的设备和软件。
具体来说，贝尔实验室研究出来过的东西有晶体管、发光二极管、通信卫星、电子数字计算机、蜂窝移动通信等，都是我们今天的生活中非常常用的东西。总之，通信网的许多重大发明都诞生自这里。

[[./Images/image00221.jpeg]]

图1.3　贝尔实验室总部

那时候还有个聚集了很多牛人的地方，叫做麻省理工学院（MIT）。这是美国的一所综合性私立大学，有“世界理工大学之最”的美名，图1.4所示是它的主校区。从这里走出的牛人很多，到2009年为止，先后有76位诺贝尔奖得主，都曾经在麻省理工学院学习或者工作。麻省理工学院的自然及工程科学在世界上享有极佳的盛誉，其管理学、经济学、哲学、政治学、语言学也同样优秀。另外，麻省理工学院研发高科技武器和美国最高机密的林肯实验室、领先世界一流的计算机科学及人工智能实验室、世界尖端的媒体实验室和培养了许多全球顶尖首席执行官的斯隆管理学院，也都是麻省理工学院赫赫有名的宝贵资产。

[[./Images/image00222.jpeg]]

图1.4　麻省理工学院主校区

那时候，又有个聚集了很多牛人的地方（哪来这么多地方阿！）。这个地方是个公司，叫做通用电气。这个公司当年是个卖灯泡的，他们的灯泡虽然不节能，寿命也不长，价格还挺贵，但是他们的灯泡非同一般------他们是第一家卖灯泡的！他们的老大，就是大名鼎鼎的托马斯·爱迪生。1876年，发明灯泡的爱迪生同学成立了爱迪生灯泡厂，为节约蜡烛和灯油作出了突出的贡献。到1890年，爱迪生同学将灯泡厂重组，成立了爱迪生通用电气公司，到1892年又与汤姆森－休斯顿电气公司合并，成立了通用电气公司。现在，通用公司的总部位于纽约市的通用电气大厦，就是图1.5中所示的这座建筑。

[[./Images/image00223.jpeg]]

图1.5　位于纽约市的通用电气大厦

-【牛人多了也不一定靠谱儿】

好，时间到了1965年，这3个聚集着不少牛人的地方有一天忽然想合作一把。他们一起开始了一个制作操作系统的计划。为了结束长期以来计算机上面没有统一的操作系统的混乱局面，他们决定，要创造出一套旷古烁今、空前绝后、惊世骇俗的操作系统！具体来说，这个操作系统应该是一个支持多使用者、多任务、多层次的操作系统。因为这三多，所以这个操作系统就起名叫做MULTICS------就是MULTiplexed Information and Computing System的缩写，连图标都设计出来了，就是图1.6所示的这样。有了这3家的强强联合，那开发的结果还用问吗？这个MULTICS操作系统的项目在1965年成立，到了1969年就......被取消了。原因好像是因为进度太慢，看来编写操作系统也不是一件容易的事儿嘛。毕竟道路是曲折的，研究是辛苦的，成绩还是有的，失败呢......也是可以原谅的嘛。

[[./Images/image00224.jpeg]]

图1.6　MULTICS的图标

项目失败了，大家都很沮丧。在这些沮丧的人中，汤普逊（Kenneth Lane Thompson）只是很普通的一个，就是图1.7中所示的这位。汤普逊于1943年出生在美国新奥尔良市。在烤翅的芳香中长大的他，没有辜负养育他的父母和那些没有了翅膀的鸡。
# 真厉害呀, 查了多少资料, 我也曾尝试按照州整理一些图书.
1960年，他考上了加州大学博克莱分校主修电气工程，顺利取得了电子工程硕士的学位。1966年，他加入了贝尔实验室，参与了MULTICS项目。做项目是个很辛苦的事情，在疲劳地揉揉因熬夜而发红的眼睛后，他很想能有个电脑游戏来玩玩。然而那时候别说超级玛丽，连吃豆也没有。所以汤普逊同学就自己编了一个游戏，叫做星际旅行。

[[./Images/image00225.jpeg]]

图1.7　Kenneth Lane Thompson

*** 1.1.3　一个游戏引发的变革------UNIX元年来了

这个星际旅行跟星际争霸肯定是没得比的，不过在那时候已经算很有吸引力了。这个游戏自然是被设计运行在MULTICS系统上的，由于MULTICS系统还不完善，导致游戏运行得不是很流畅，所以，能够顺畅地玩星际旅行，成为汤普逊同学努力工作的源动力。

可是后来项目取消了，汤普逊同学似乎再也不可能流畅地玩他的星际旅行了，这是多么遗憾的事情啊。然而汤普逊同学没有就此放弃，强烈的游戏欲望推动他行动起来。毛主席教导我们：自己动手，丰衣足食。我估计汤普逊没有背过毛主席语录，但是他用自己的行动证明了这句话的正确性。他在墙角淘换出一台PDP－7的机器，并且伙同其同事Dernis Ritchie，打算将星际旅行移植到这台PDP－7上，于是这台PDP---7也跟着名垂史册，就是图1.8所示的这台。

[[./Images/image00226.jpeg]]

图1.8　PDP---7

当然，要想运行这个游戏，肯定还得有个系统。可是MULTICS已经停工了，并且这个系统绝对不是两个人可以搞定的（那么多牛人一起都没搞定）。那怎么办？那就自己动手！于是汤普逊和Dernis
Ritchie发扬自己动手的精神，用汇编语言写出一个系统，这就是最初的、简陋的、UNIX的前身。这个系统不像MULTICS那么牛，不支持很多的用户，只能支持两个用户（就是他俩玩嘛），支持的进程也有限，其他功能也都没有MULTICS设计得那么复杂。相对于那个MULTICS系统，Brian
Kernighan戏称他们的系统其实是：“UNiplexed Information and Computing
System”，缩写为“UNICS”。后来大家取其谐音，就诞生了UNIX这个词。这一年，已经是1970年，史称UNIX元年。直到现在，计算机中都是用1970年1月1日0点0分0秒作为记录时间的原点。
# 有意思,单任务, uni,凡事从小处做起. 1970年是这么来的.

[[./Images/image00227.jpeg]]*提示：*计算机中记录的时间，是自1970年1月1日0点0分0秒开始，到当前时间所经历的总秒数，再根据这个秒数计算出具体的年、月、日、小时、分等信息。

后来，Dernis Ritchie觉得用汇编写的系统不好维护，于是......他也发扬自己动手的精神，发明了C语言（符合大牛一切自己动手的风格），然后用C语言把UNIX重写了一遍。从此，UNIX走上了发展的快车道。如今，许多世界级的大服务器，用的依旧是UNIX系统。

而这一切的努力，最初都是为了玩个游戏。

# 总结,三个大牛机构与两个人. Ritchie因为汇编语言难以维护而写出
** 1.2 Stallman和他的GNU计划

这回要说的，是另一个传奇人物------Richard Matthew
Stallman，就是图1.9里这位不爱刮胡子的大叔。

[[./Images/image00228.jpeg]]

图1.9　Richard Matthew Stallman

Richard Matthew
Stallman，1953年出生在美国纽约曼哈顿地区。在他生命的前十几年中，他并没有表现出什么过人的地方，但那是因为他没遇到一个叫做电脑的东西。

*** 1.2.1　快乐的自由

高中的一个暑假，他去给IBM打工，花了两周的时间用Fortran语言编了一个数据处理的程序。这是他第一次接触计算机，或许就是这次相遇，确定了他未来行走的方向。1971年，他考上了哈佛大学，上学的同时，他还受聘于麻省理工学院的人工智能实验室，成为了一名职业黑客（黑客这个词没有贬义）。在人工智能实验室期间，他可没少干活，开发了很多有用的软件，其中最著名的就是Emacs编辑器。Emacs是一个可与Vi相抗衡的强大的编辑器。两者的操作方式完全不同，但同样强大，各自用自己独有的方式，提高着人们的编辑效率。直到今天，仍然有人争论到底Emacs好还是Vi好，信奉Emacs的人和信奉Vi的人形成了两个帮派，这两个帮派经常在互联网上用鼠标键盘相互灌水拍砖，拼个你死我活。哦，扯远了，咱还回来说Stallman。

那时候的Stallman在人工智能实验室里工作得非常愉快，大家有BUG同当，有代码共享。那时候的软件工程师的世界，是一个“人人为我，我为人人”的理想世界。因为最初的计算机软件没有什么开源不开源的概念，那时候的软件天生就是自由的！卖计算机的同时会附带软件，包括软件的源代码和文档。计算机厂商卖的主要是计算机的硬件，软件只是附属品而已。用户可以根据自己的需要去修改软件，与别人分享软件。总之，软件是用户花钱买硬件时附带着买来的，用户想怎么玩就怎么玩。软件开发者的目的，也不是靠软件赚钱，而是靠软件支撑起硬件的功能，然后靠卖硬件赚钱。

*** 1.2.2　自由逐渐远去

然而随着技术的发展，软件逐渐脱离硬件成为一个独立的产业，很多软件慢慢地只提供二进制代码而不提供源代码了，这就意味着你不能修改它，并且多数软件还规定最终用户没有二次分发的权利。也就是说，这东西你买了，只能你用，你再给别人就不行！这就好像我买了把菜刀，然后卖菜刀的告诉我“你这把菜刀不许借给你的邻居用，也不许私自给菜刀换刀把，否则我就告你！”

Stallman当时就遇到了类似这样的菜刀问题。那时候，他们实验室买的第一台打印机附带有驱动程序的源代码。他们那的黑客们可以随意修改这个驱动，根据自己的需要添加些小功能，改改BUG之类的，这为他们的工作带来了很大的方便。后来，实验室又买了一台激光打印机，这次厂商只提供了二进制的打印机驱动程序，它是实验室里仅有的一个没有源代码的软件。Stallman很不喜欢这样的产品，然而他没有选择，只能沉默。

后来出于工作的需要，Stallman想修改一下这个驱动程序，但是不行，没源代码啊。Stallman听说卡内基·梅隆大学有这个打印机的驱动程序源代码，他就去了那里，跟他们套近乎：“那啥，大家都是道上混的，谁还没个"马高蹬短"的时候？是兄弟的拉哥们儿一把，我也没啥事儿，就是我们那打印机老丢字，老把一些关键的字打成口口，我估计是驱动的问题，听说你们这有这驱动的源代码，能不能给我拷一份？”对方办事效率还是挺高的，很干脆地拒绝了他。因为他们和厂商签署了一份保密协议，协议要求他们不能向别人拷贝源代码。Stallman顿时感到他们背叛了自由的计算机社团，他非常生气，但是他没有办法改变什么，只好又选择了沉默。

这只是一件小事，只是一个时代的缩影。那个时代，正处在软件向私有化转变的过程中，也是软件逐渐商业化的过程。越来越多的软件选择了不开放源代码，不允许二次分发的发布方式。Stallman身边的同事，一个一个地跑到开发私有软件的公司去打工了，他们不再相互分享，不再相互交流。Stallman问：“你们那软件的查找算法做得不错啊，怎么实现的？”“对不起，无可奉告。”“你们的文档工具效率挺高啊。”“对不起，商业机密。”......面对这一切，Stallman又能说什么呢？他还是只有沉默。

*** 1.2.3　不在沉默中爆发，就在沉默中灭亡

Stallman爆发了！他不能容忍软件世界里清新自由的空气被私有软件污染；他不能容忍被剥夺按照自己的需求修改软件的权利和乐趣；他不能容忍自己买条皮带尺寸不够时，自己竟然连在上面多打个洞的权利都没有！于是，他就爆发了。

他要重现当年那“人人为我，我为人人”的合作互助的软件世界；他要把使用、复制、研究、修改、分发软件的权利还给软件世界的每一个人民；他要用自己的行动告诉人们，软件天生就该是自由的！

他要开辟一个新的世界，哪怕是一个人在战斗！于是，一个宏伟的计划------GNU计划在他心中产生了。它的目标是创建一套完全自由的操作系统。因为操作系统是电脑中最重要、最基础的软件，要创造自由的软件世界，自然先要有一套自由的操作系统，然后再以此系统为中心，开发各种各样自由的软件。1983年，Stallman在net.unix-wizards新闻组上公布了GNU计划，这个计划的标志是一头角马（也就是非洲牛羚），就是图1.10所示的这个。

[[./Images/image00229.jpeg]]

图1.10　GNU计划的图标

[[./Images/image00227.jpeg]]*提示：*GNU是“GNU is Not
UNIX”的递归缩写，Stallman表示这个词应该读作/'gnu:/（发音类似“革奴”），以区别于表示非洲牛羚的单词gnu（发音与“new”相同）。

这个计划要创造一套自由的类UNIX操作系统。系统本身及系统上的软件都是自由软件，它们可以被免费获取，随意使用、修改和再分发。并且每个人都可以获得这个系统全部的源代码，每个人都可以为完善这个系统作出自己的贡献。这个系统要使用与UNIX相同的接口标准，这样，就可以由不同的人，分期分批地创作操作系统的不同部分而不必担心相互之间协同工作的问题。

*** 1.2.4　实现GNU梦想

为了实施GNU计划，1985年，Stallman又创建了自由软件基金会。基金会的主要工作就是执行GNU计划，开发更多的自由软件。1989年，Stallman与基金会的一群律师们起草了广为使用的《GNU通用公共协议证书》也就是GPL协议，以此协议来保证GNU计划中所有软件的自由性。到了1990年，GNU计划中的这个系统已经初具规模，有了很多优秀的软件。其中有很多是世界各地的黑客们无偿提供的，也有一部分是利用自由软件基金会的基金雇用程序员来开发的，当然，Stallman自己也身先士卒，开发了Emacs、GCC、GDB等重要软件。当他看着这些丰富的自由软件的时候，感觉到那清新自由的空气，终于又回来了，以后，人们就可以拥有一个可以自由使用、自由修改、自由分发的、自由的操作系统了！不过等一下，好像还差点什么，哦，还......差个内核吧。

作为一个系统，没有内核是不行的，这么重要的部件Stallman当然不会忘记，所以才会有Hurd内核。这个内核被设计为一个遵守POSIX标准的微内核。所谓微内核，是相对于宏内核来说的。宏内核就像我们现在的Linux内核，是一个独立的程序，里面包含了进程管理、内存管理、文件管理等功能。而微内核则将一个内核需要的功能尽量地简化并且拆分，运行起来是几个独立的程序，有的专门负责进程管理，有的专门负责内存分配。内核是一个系统的核心，所以至关重要，Stallman对Hurd的开发也是精益求精，非常谨慎，以至于内核的进度有些落后于其他的系统软件，当其他软件都已经有比较优秀的版本的时候，Hurd内核依然不能够走出实验室投入真正的使用。这种情况一直持续到1991年，另一位英雄的出现------不过，这里先卖个关子，暂且不去说他。

无论怎样，到今天，Stallman理想中的自由世界，终于拉开了那沉重的幕布，展现出了自由的光彩。而Stallman并不满足，也确实没有满足的理由，这个自由的世界还需要成长，还需要更加丰富多彩，还需要有更多的人走进这个世界中来。于是Stallman奔走于世界各地，告诉人们有这么一个自由的世界，号召人们加入这个世界，鼓励人们为使这个世界更加自由而付出自己的力量。他是一个执着的苦行僧，为了他的梦想，为了他的自由世界，他会一直走下去......

** 1.3 从异想天开到Ubuntu

1988年，芬兰赫尔辛基大学迎来了一位新的大学生------Linus Benedict
Torvalds，就是图1.11所示的这位。当然，那时候他还比较瘦，而且他的名字在学校的花名册中也并不显眼，但是一年后，他大二的时候，开始有故事了。

[[./Images/image00230.jpeg]]

图1.11　Linus Benedict Torvalds

*** 1.3.1　Minix

大学二年级的时候，Linus同学开始学习操作系统这门课程。那时候这门课程使用Minix系统进行教学。Minix这个名字或许您听着并不熟悉，这是个专门用于教学的操作系统，它的系统结构和UNIX系统是类似的。有人可能会问：那为什么不直接用UNIX呢？嗯，UNIX确实很先进，很优秀，确实值得学习计算机科学和操作系统的同学们学习。然而要知道有一种东西叫做版权，即便你不怎么在乎这个东西，但人家学校是不能做违法的事的。UNIX并不免费，并且是天价的，广大穷苦的大学生们买不起，学校也没钱为每一名学生配备一套UNIX系统。

荷兰阿姆斯特丹Vrije大学的Andrew S.
Tanenbaum教授（就是图1.12所示的这位）在教学过程中就深刻地体会到，世界上缺少一个教学用的操作系统。他的学生们学习了计算机，学习了操作系统原理，不能光啃书本，总得实践一下吧？
# 有道理呦.
总得找台机器装个操作系统用用吧？用什么操作系统来教学呢？买个DOS装上？虽然那时候DOS已经问世了，但是这么一个单用户、单任务、效率也不高的操作系统，实在不能指望它培养出什么软件人才。装个UNIX？学校还不想破产。于是牛人Andrew
S. Tanenbaum拿起键盘------咱自个儿编一个吧！然后Minix就诞生了。

[[./Images/image00231.jpeg]]

图1.12　Andrew S. Tanenbaum教授

Minix取Mini
UNIX之意，1987年被编写出来，到1991年发展到1.5版，后来发展到2.0基本上就停止了。因为这个操作系统的初衷只是作为一个教学模型，并不是一个实用的系统，所以功能很简单，体积也很小，并且以后也没有进行进一步的开发和扩充。它为的是能够让学生在一学期内学完整个系统。很长一段时间后又出了Minix 3，这回有图形界面了，图1.13所示就是Minix
3的界面。那时候Minix在大学中用于教学是免费的，但是用于其他用途是需要给钱的，不过现在已经彻底免费了。它作为一个操作系统，其实并不算优秀，但它是一个源代码完全开放的操作系统，这使得有理想、有志向、有抱负的黑客们，第一次能够完整地阅读到一个操作系统的全部代码。

[[./Images/image00232.jpeg]]
图1.13　Minix 3的界面
# 很有意思, 没忘记意像avatar

*** 1.3.2　异想天开的FREAX

Linus他们学校的计算机上装的就是这个专门用于教学的Minix系统。虽然适合拿来学习，不过系统本身并不强大。这要是别人也还罢了，可是Linus同学有个最大的爱好，就是虐待计算机。
# 虐待计算机, 这个提法有意思. 那我也要虐待emacs.
他热衷于测试计算机的能力和限制，整天研究怎么让计算机按照自己的想法去干活，怎么发挥计算机最大的性能，一定要把可怜的机器累得精疲力尽，口眼歪斜，电容爆浆，吐血身亡才算罢休。

可想而知，很快这个教学用的操作系统就已经不能满足Linus大侠的欲望了，可是似乎也没有更好的选择。上面说过了，UNIX奇贵无比，DOS又不够优秀，而且无论UNIX还是DOS，它们的代码都是不开放的，只能拿来用，没法拿来折腾。于是像其他牛人一样，Linus自己动手了（当想要的东西不存在时就自己动手创造，这充分说明他有成为大牛的潜质）。

今天我们都知道，Linus从那时起开始了一个事业，一个神话，但在当时，他并没有想那么多，只是为了学习Intel386体系结构下的编程技术。他并不知道自己即将创造的是一个在世界范围广泛使用的系统，而只觉得是自己一时的异想天开。因此，一开始他把自己写的这个操作系统命名为FREAX，有异想天开之意，就此开始了这个“异想天开”操作系统的编写。大约1991年4月份的时候，他就编写出了第一个可以运行的版本------0.00版。这个版本可以启动，运行两个进程，分别在屏幕上打印出AAA和BBB，然后......就没了。虽然连句整话都不会说，不过这是一个好的开始，至少能启动了。

[[./Images/image00227.jpeg]]*提示：*FREAX源于英文中的freak。freak有怪诞，怪物之意，Linus取其谐音命名其操作系统为FREAX。

*** 1.3.3　Linux的由来

如果Linus就这么干下去，估计到今天只会有两种结果。

（1）成家立业后的Linus经常指着他的电脑C盘里面的一个文件夹对来访的朋友说：看，我那时候还写过一个FREAX系统。
# 有意思的想象, 脑洞大开的优秀作者.
（2）Linus为完成FREAX系统挑灯夜战，最终累得吐血身亡，永远活在我们心中。

总之，如果他一直自己干下去，就不会有Linux这个东西了，因为一个人的力量是有限的。有道是人多力量大，众人拾柴火焰高。Linus深刻明白这一点，他没有独自在家闭门造车，而是让他的操作系统和互联网，亲密接触了。

“Hello everybody out there using minix------I'm doing a (free) operating
system.”这是他当年在comp.os.minix上发布的消息，告诉大家，他正在写一个操作系统。并且，他还把他写的“异想天开”操作系统的代码上传到ftp.funet.fi的服务器上供大家下载，以便交流心得，共同学习。这就相当于你跑到网站上发帖子说：我研究出一种萝卜炖牛腩的方法，主料是啥啥啥，配料是啥啥啥，怎么怎么炖，大家都试试吧！（对不起，我又饿了）于是很多有兴趣的人就来尝Linus炖的牛腩，哦不对，是尝试Linus写的系统。不过当时那个服务器的管理员Ari
Lemke看着这个异想天开的名字就不顺眼。想想，既然是Linus写的操作系统，又是类UNIX的，干脆，叫Linux吧。

这里先要说一个概念，Linux是什么？狭义地讲，Linux只是一个操作系统的内核，它只是各位的Ubuntu系统里面/boot/目录下的那个内核文件vmlinuz-x.x.xx-xx-generic。就好比汽车，Linux只是一个引擎而已，只是大家普遍习惯把装了Linux这种引擎的汽车叫做Linux汽车。那么既然Linux只是一个内核，要想工作，就还需要很多周边软件的支持，比如文件系统；比如一个命令行程序；比如一些基本的软件。这些东西加在一起成为一个系统，其实应该叫做GNU/Linux系统。不过为了符合平时习惯，本书后面如无特别声明，所提到的Linux都指GNU/Linux系统。
#+BEGIN_SRC shell :results output
ls /boot
#+END_SRC

#+RESULTS:
#+begin_example
config-5.3.0-18-generic
config-5.3.0-19-generic
efi
grub
initrd.img
initrd.img-5.3.0-18-generic
initrd.img-5.3.0-19-generic
initrd.img.old
memtest86+.bin
memtest86+.elf
memtest86+_multiboot.bin
System.map-5.3.0-18-generic
System.map-5.3.0-19-generic
vmlinuz
vmlinuz-5.3.0-18-generic
vmlinuz-5.3.0-19-generic
vmlinuz.old
#+end_example

*** 1.3.4　众人拾柴造就Linux

Linux被公布在网上之后，引来大家纷纷的路过和围观，很多人觉得这个东西挺有意思，不过第一个对外发布的0.01版Linux还有很多的不完善（这简直是一定的）。于是，全世界的有志之士纷纷伸出援手，共同完善这个刚刚出生的Linux。

首先就要感谢Richard_Stallman大牛创建的GNU计划，这使得Linux不必去从头开始开发那些最基本的软件和命令，而是直接利用GNU计划中的那些优秀的开源软件------前面说过了，那时候GNU系统除了内核以外，已经比较完善了。

有了基本的软件之后，还需要一个文件系统。由于当初Linus大侠是在Minix系统上开发的，所以最开始Linux用的文件系统是借用Minix的文件系统。可老借别人的总不是个事儿，还是应该有自己的文件系统，要不然你怎么好意思跟别的操作系统打招呼？这时候，来了个牛人叫Theodore
Ts'o，就是图1.14中这位。

[[./Images/image00233.jpeg]]

图1.14　Theodore Ts'o，曹予德

Theodore
Ts'o，曹予德，华裔，1990年毕业于美国MIT大学计算机科学专业。他爱好广泛，喜欢烹饪、骑车、无线电报，还有折腾电脑（这些爱好都不挨着啊），当然这不是我们的重点。他看到Linux觉得很有意思，于是怀着极大的热情为Linux提供了邮件列表服务以便大家一起讨论问题，后来还提供了ftp站点来共享Linux的代码，并且一直用到现在。除此之外，技术上，他编写了
0.10内核中的虚拟磁盘驱动程序和内存分配程序。在感觉到Linux缺少一个自己的文件系统后，他提出并实现了ext2文件系统，此后ext系列的文件系统一直都是Linux世界中事实上的标准，任何一个发行版都会默认支持ext文件系统，现在已经发展到了ext4了。

另一位牛人，一个英国人------Alan
Cox，请见图1.15，不要问我为什么牛人都不爱刮胡子，我也不知道。

[[./Images/image00234.jpeg]]
图1.15　Alan Cox

他工作于英国威尔士斯旺西大学，特别爱玩电脑游戏（又一个玩游戏的，可见玩游戏也不是坏事），尤其是网游（你看你看，还是网游），不过那时候的网游不像现在这样华丽，那时候是字符界面的，能想象吗？字符界面的网游！那种网游叫做MUD------Multi-User
Dungeon or Dimension。玩MUD当然就得有计算机，得有网，所以Alan Cox开始逐渐地对计算机和网络产生了兴趣。为了提高电脑运行游戏的速度及网络传输的速度，他开始接触各种操作系统，为自己选择一个满意的游戏平台，争取榨干电脑的每一个指令周期。
# 榨取
经过仔细考虑，他买了一台配有80386-SX型CPU的电脑，并且装了Linux 0.11版的系统。这主要是因为预算比较紧张，即使是Minix他也买不起。于是他开始使用Linux，进而学习其源代码，并对Linux产生了兴趣，尤其是网络方面相关的代码（整天琢磨怎么榨干他家那点带宽呢）。在Linux
0.95版之后，他开始为Linux系统编写补丁程序，以后逐渐加入Linux的开发队伍，并成为维护Linux内核源代码的主要人物之一。有一个稍微有点软的公司还曾经邀请他加盟，被他稍微有点硬地拒绝了。

[[./Images/image00227.jpeg]]*提示：*80386-SX是Intel公司于1988年年末推出的一款廉价版CPU。其价格只相当于主流版本80386-DX的三分之一。

再有一位，Michael K.
Johnson，他是著名的Linux文档计划的发起者之一，写了《内核骇客手册》一书，曾经在Linux
Journel工作，现在就职于著名的商业发行版Red Hat的公司。

当然除了这些大牛，还有更多的大牛，中牛，小牛，肥牛......（唉，又饿了）他们都为Linux的发展作出了自己的贡献。他们来自不同的国家，从事不同的职业，甚至从未见过面。但是他们为了一个共同的目标，通过网络，一起合作，利用自己的业余时间，义务地帮助Linux成长，才有了今天这个可以合法免费使用的操作系统。这是什么精神？这就是“人人为我，我为人人”的软件精神！

*** 1.3.5　琳琅满目的Linux

这之后，Linux的发展可以用“一发不可收拾”来形容。很多商业公司和民间组织都纷纷看好这个系统，并加入了Linux的阵营，各种各样的发行版满足着众多Linux爱好者的需求。

商业化比较成功的发行版，要数来自俄罗斯的Red_Hat了，相信大家对图1.16里这顶红帽子有些印象。Red Hat 1.0版于1994年11月3日发布，之后一直稳健发展。到Red Hat 9.0之后版本出现分支，其中的桌面版与来自民间的Fedora计划合并，成为Fedora
Core发行版。而Red Hat公司则把精力全部投入企业使用的服务器版本------Red
Hat Enterprise Linux。Red_Hat为Linux社区作的最大的贡献要数rpm软件包了，现在，相当多的发行版都使用rpm作为默认的软件包格式。

[[./Images/image00235.jpeg]]
图1.16　Red Hat的徽标

Mandriva是一个来自欧洲的发行版，它的前身是法国的MandrakeLinux。Mandrake的特点是方便，易用性好，硬件兼容性强。它为Linux的普及作出了很大贡献。2005年Mandrakesoft公司与拉丁美洲最大的Linux厂商Conectiva达成了收购协议，Mandrake从此更名为Mandriva。Mandriva和Red
Hat一样，以rpm作为软件管理工具，部分兼容了Red Hat Linux/Fedora
Core的软件包。图1.17所示是Mandriva的运行界面。

[[./Images/image00236.jpeg]]

图1.7　Mandriva的运行界面

SUSE是一个来自德国的发行版，隶属于Novell公司。它的特点是界面漂亮，但消耗的资源相对多一些，图1.18所示就是SUSE的界面。另外，它包含了一个安装及系统管理工具------YaST2。用户可以用这个工具进行软盘分区、系统安装、联机更新、网络及防火墙组态设置、用户管理等操作，为原来复杂的设置工作提供了方便的组合界面。

[[./Images/image00237.jpeg]]

图1.18　SUSE界面

还有一个比较有历史的发行版，就是Debian。它的徽标是一个豪放的螺旋，就像图1.19所示的这样。这是一个没有商业化，完全追随开源精神的发行版。Debian于1993年发布第一个版本，一直到现在，路线没有大的变动，以稳定、保守著称。它的deb格式的软件包和Red
Hat公司的rpm包具有同等重要的地位。同时，它的apt软件包管理器，也成为其他发行版竞相效仿的模范。

[[./Images/image00238.jpeg]]

图1.19　Debian的徽标

除了这些之外，还有灵活的Slackware、极端的Gentoo、简洁的Arch，以及我们这个故事的主角，在Debian的基础上改头换面而来的Linux界的新星------Ubuntu。

** 1.4 本章小结

好了，Linux家族的这点历史渊源就介绍到这里，相信您对UNIX、Minix、Linux这些发音差不多的系统，已经有了些简单的了解了。下一章，就该我们这本书的主角------Ubuntu系统登场了。

#+BEGIN_QUOTE
总结:
发展历史: 三个组织和两个人
开源计划: stallman, GNU
Linux及各个版本

所学所得:
怀抱着榨取计算机性能的初心,
意像方法, C语言的发明人Det
凡事从小处做起, 比如unix系统, linux系统, 起初只有一个小目标.


#+END_QUOTE
* 第2章 入驻安装

我叫Ubuntu，我的用户喜欢叫我“乌棒兔”。但是我绝对不笨，与某种耳朵长尾巴短的哺乳动物也没有什么联系。我是一个操作系统，我是Linux，我是Ubuntu。

我是一只幸运的Ubuntu，遇到了一个欣赏我，喜欢我，真正能够让我施展才能的用户。今天，我就讲讲我从出生，到被下载进电脑，直至安装到硬盘里的过程。

** 2.1　抵达--获得Ubuntu的途径

在2010年的4月，我来到了这个世界，并由出生的月份得到了我的代号------10.04，也就是2010年4月出生的意思。和我同一天出生的兄弟们还有很多，我们都是Ubuntu
10.04。我们出生前一直在Canonical学校学习------这话您听了可能会费解，怎么出生前就开始学习了呢？
# 回顾ubuntu的历史.
这不怪您，主要是因为咱们不是一个种族的。我们是软件，我们所谓的出生，也叫发布，也就是正式推出的意思。但我们在正式发布之前，其实就已经存在了，只是那时候还不完善，叫做Beta版或者Alpha版。我们出生前有很多的缺点：可能比较懒，经常启动不起来；可能脾气大，有点不顺心就吐一屏幕的英文字母给你看；要不就经不起打击，一不留神就死掉了（别害怕，我们软件死掉容易，复活也简单，重启就行了）。总之，我们出生前有很多的缺点和不足。所以要努力学习，争取到出生的那一天能够成为一个值得信赖的操作系统。或者不叫“出生”吧，听着别扭。这个过程其实有点像你们人类上学，那叫毕业吧？毕业，也就是正式发布的那天。

[[./Images/image00227.jpeg]]*提示：*Ubuntu系统通常在每年4月和10月各发布一个新的系统版本。

*** 2.1.1　毕业了，就要去工作

从Canonical学校毕业之后，我们就该参加工作啦。和你们人类一样，我们毕业的时候，也都充满理想；也都满怀激情；也都各奔东西；也都......不管分配。那我们怎么找工作呢？上招聘网？您见过招聘网站上提供下载操作系统的吗？我们是等着工作来找我们！

比如您想招我到您的电脑上工作，就可以从互联网大道走：到www市，Ubuntu区，com大楼，就找到我们学校了。还有中文分校，离着不远：也在www市，Ubuntu区，org大院里面的cn门。进去之后，您可以在里面随便逛逛，参观一下，了解Ubuntu系统的一些基本知识。之后按照页面上的提示，找到下载我们的网页，就可以开始下载了。一般中文的下载页面是这里：


进到下载页面，会看到一个硕大的橙色按钮写着“开始下载”。不过先别着急点，先在左边选择好你需要的版本，就是图2.1中标示出的这个地方。

[[./Images/image00240.jpeg]]
图2.1　选择要下载的Ubuntu版本

图2.1中上面那个下拉列表框是选择我们Ubuntu系统的版本的。一般会有两个选项，一个是最新的普通版，另一个是最新的长期支持版（就是带LTS的版本）。普通版只提供18个月的支持，18个月以后，虽然系统还能用，但是官方不再提供任何软件升级和补丁了。而长期支持版可以提供3年的支持，并且更加稳定，但是里面的软件就不是最新的了。

[[./Images/image00227.jpeg]]*提示：*无论普通版还是长期支持版，在有新的版本发布之后，都可以在线升级为最新的版本，如从Ubuntu
11.04升级为Ubuntu 11.10。但只能相邻版本升级，不能跨版本升级。如从Ubuntu
10.10不能直接升级为Ubuntu 11.10。

图2.1下面的下拉列表框是选择下载32位系统还是64位系统。虽然现在的电脑基本都是64位的了，不过还是建议一般用户选择32位系统。因为有些软件还没有64位的版本，所以使用32位系统遇到的问题会少一些。

选好之后单击那个硕大的“开始下载”按钮，就开始下载了。这里要说明一下，领我们回家是免费的，不需要花一分钱（当然，您自己的上网费自己掏），我们也不会因为您没花钱就隔三岔五地黑屏重启。

*** 2.1.2　要工作，先要有住处
# 形象类比的提法, 指的是U盘
如果是从互联网大道把我拉回到您的电脑上的，那么您得到的是一个ISO文件，名字大约是ubuntu-10.04.1-desktop-i386.iso、ubuntu-11.10-desktop-i386.iso这样的。不过您如果只是把这个ISO文件静静地放在硬盘里，除了占用一点您宝贵的硬盘空间外是没有任何用处的。要想让我们为您工作，得把我们安装到您的电脑上，让我们在您的硬盘里定居才行。公司招俩研究生不还得给解决户口呢吗，我们也是这个道理。

[[./Images/image00227.jpeg]]*提示：*像Ubuntu
10.04这样长期支持的版本，每过一段时间会推出一个升级版，叫做Ubuntu
10.04.1、Ubuntu 10.04.2之类，就相当于Windows XP系统的SP1、SP2。

要把我安装到您的电脑上有很多方法，最简单的就是把这个ISO文件刻录成光盘来安装。记住，要选择刻录镜像文件（刻录软件不同，叫法可能不一样，不过大概是这个意思）。可不要把ISO包解开，然后把里面一大堆乱七八糟的文件拖进去刻录；也不能直接把ISO文件拖进去，刻完了之后打开光盘一看，里面就一个ISO文件。这么刻完的光盘都是启动不了的。再次重复，要用镜像刻录，这样刻出来的光盘才能够正常地从光驱引导计算机，并进入安装界面。这也是自盘古开天地以来最通用、最正常、最安全的操作系统安装方法------光盘安装。

要想使用光盘安装，您的电脑先得设置成从光盘启动才行。这个大概不用我教您，一般打算安装Linux的人，设置BIOS启动顺序应该不成问题。设置好之后，把光盘放进去，重启就行了。就像现在，我就正静静地躺在一台电脑的光驱里，等待着和我的用户见面，等待着他启动电脑......

** 2.2　启动--安装Linux前的准备

在光驱中躺着，等着电脑启动的时候，心里总觉得有些忐忑，胡思乱想。估计刚毕业的大学生第一次面试之前也是这样吧。不知道我能不能被留在这个电脑里，我可不想被扔在角落里等着落灰。算了，不乱想了，抓紧时间整理一下第一次启动该做的事情吧，省得待会儿出错。

*** 2.2.1　了解计算机的组成

作为一个操作系统，我应该对这个电脑的组成有所了解。好，那就来复习一下。

电脑，大名计算机，要说这可是个伟大的发明。它的出现极大地改变了人们的生活。最初的计算机个头很大，有一大堆这个管那个管，动不动就两个火车头，半拉四合院那么大。里面看上去很复杂，但功能相对简单。随着技术的发展，计算机的体积越来越小，速度越来越快。今天的计算机，看上去比以前简单（实际更复杂），但功能比以前强大了不知道多少倍。不过，虽然经过了复杂的演变，计算机的大体结构还是一样的。就像这年头盖的房子这么多，户型各式各样，但不外乎都有客厅、卧室、厨房、厕所。计算机也一样，不外乎都是由厨房、厕所......哦不对，不外乎都是由处理器、存储器和输入/输出设备组成的。注意，计算机里，没有厨房、厕所！
# 真是一个喜欢动脑的人.我的卧室, linux的内存.
【处理器】

处理器，也就是我们常说的CPU（Center Processing
Unit，中央处理单元）。图2.2所示就是一块CPU，大家都很熟悉。有道是“文臣纸笔安天下，武将刀马定乾坤”。无论干什么，总不能赤手空拳，多少都需要些工具。处理器就是我们软件工作的时候要用到的最重要的工具。每一个软件工作的时候都得用处理器，就好像会计工作得用算盘，厨师工作得用菜刀一样。处理器主要有计算和控制两大功能。

[[./Images/image00241.jpeg]]
图2.2　处理器

计算，好理解吧，就是算数。我们软件做任何工作都需要计算，也就是说我们软件做任何工作都需要用处理器。所以处理器的运算速度，直接影响着我们软件的工作效率。有句话怎么说来着？“工欲善其事，必先利其器”嘛。

那么处理器的控制功能又是什么呢？就是说计算机里的任何一个硬件，都直接或者间接地受处理器的控制。我们软件只要拿着处理器进行操作，就可以实现对声卡、显卡、网卡这些硬件的控制。这有点像汽车，虽然汽车要想行驶起来，需要各个零部件密切的配合，但是司机只要坐在上面，握好方向盘，踩对了油门、刹车、离合器，就可以控制整个汽车的行驶。

【存储器】

再说存储器，存储器就是用来存储程序的地方，换句话说，存储器就是用来给我们软件住宿、工作的空间。再说白点，软件待的地方，就是存储器！比如我现在所在的光盘，就是存储器。不过光盘只是我们软件从一台机器挪到另一台机器的时候所需要的交通工具，真正要定居在一台电脑里的时候，要住在硬盘里。有人说，那硬盘也是存储器了？没错，硬盘、光盘、U盘这些都是存储器。

不过这些存储器有个共同点------都是程序们平时不工作的时候住的地方，它们都属于外存储器。而当一个程序真正要干活的时候是要到另一个空间去的，这个空间就是我们软件的工作间------内存储器，也就是大家常说的内存，比如图2.3所示这个，就是一个内存条。内存的大小对我们的工作效率也有很大的影响，内存越大，工作效率自然越高。你想啊，要是你们公司都坐得人挨人人挤人，恨不得把办公桌摞起来，老张坐老李脑袋上办公，那工作效率能高得了吗？

[[./Images/image00242.jpeg]]

图2.3　内存储器

[[./Images/image00227.jpeg]]*提示：*最初的计算机内部没有磁盘，只有RAM，因此磁盘------包括硬盘、软盘，都算做外存储器。

【输入/输出设备】

那么这个输入/输出设备是干什么用的呢？咱回过头来想想，有了外存了，我们软件的住宿问题解决了。有了内存了，我们有了工作间了。然后又有控制器了，我们有工作的工具了，好，可以开工了！等等，先别急，您想想咱开工干什么啊？得有人给我们任务呀，要不我们拿着CPU算什么呢？不能自己算“1+1=2”玩吧。那么任务是谁给我们的呢？当然是坐在电脑前的人了。

可是，有句话叫人鬼殊途。软件虽然不是鬼，但和人类也是不能直接对话的。所以，我们之间的交流需要设备。输入设备就是用来让人类给我们发指令、分配任务的。比如鼠标、键盘、触摸屏这些都是输入设备。输出设备相反，是用来让我们软件计算得出结果后把结果反映给人类的。显示器、音箱、打印机是输出设备。
# 输入和输出, 可以简单化, 输入键盘和触控板, 输出显示屏, 人脸.
# 眼耳鼻舌身意
我正在整理着思路，忽然感到一阵震动。之后，光盘缓缓旋转，逐渐加速------终于启动了！

*** 2.2.2　先尝后买------用LiveCD体验Ubuntu

这时候电脑正在从光驱引导，光驱里那扇通往内存的IDE通道之门已经打开，我背起我的背包------一个RAM文件系统，走过IDE通道，进入这台机器的内存里。

【第一印象】

进入内存里之后，我把RAM文件系统展开，把里面的东西掏出来放好。背包是我来的时候就打好的，里面是一个能够运行起来的文件系统，包括很多跟我一起干活的同志们，如Firefox、apt、gnome等。把文件系统搞定之后就叫这帮人起来干活。哦，对，还有驱动，赶快翻翻我带来的驱动程序。我们学校的老师教导我们说，第一印象是很重要的，所以一定要在CD上面的RAM系统包里打进尽可能多的驱动程序，这样无论遇到什么硬件，都能够直接地正常使用。否则用户从光盘一启动，就发现分辨率混乱，音箱不出声，那就麻烦了。

马上要显示出界面了。这是我第一次与用户面对面交流，不免有些紧张。听我的学长们说，一般我们Ubuntu系统在第一次运行后会有两种结果：可能我的能力会被认可，我会被安装在这台计算机中，实现自己的价值；或者，在一次不愉快的试用后，连同我乘坐的光盘一起，被扔到一个不知名的角落，或者给用户家的宠物狗当飞盘玩。好吧，不管未来怎样，我现在都要尽自己最大的努力，展现出我最好的一面。

终于，我收拾好了所有的东西，从光盘里来到了内存中。赶紧向还在光盘里的弟兄们汇报一下：“我已出仓，感觉良好......”嘿嘿。哦，对了，用户还在那等着呢，赶快显示出启动界面，如图2.4所示。

[[./Images/image00243.jpeg]]
图2.4　Ubuntu的启动界面
# 我是从此处知道, 操作系统运行在内存里.

【先体验，后安装的LiveCD】

启动界面过去之后，首先要确定一下交流的方式。这很重要，就像你走在大马路上看见一个高鼻梁黄头发蓝眼睛的家伙，不可能过去就拍人家肩膀问：“吃了吗您？”智力正常的人一定是先过去来句：“Excuse me？”（除非你知道这人就是你家隔壁那隆过鼻子，酷爱染发，老戴对美瞳彩片的二嘎子）。但我们软件是无法看到使用者眼睛颜色的，所以我只好像图2.5这样，在屏幕左侧的列表框里列出所有我可以使用的语言，让用户来选择。

[[./Images/image00244.jpeg]]
图2.5　语言选择

这位用户毫不犹豫地在列表框里选中了“中文（简体）”。看来这家伙是个中国人，于是我马上转换到中文跟用户交流。首先我问他想要干什么，我给出如下两个选项。

（1）“试用Ubuntu 10.04.1
LTS”------这个选项的意思就是先尝后买，好不好用得先试试，看着顺眼了再装。新手一般都选这个，能先看见我这系统到底什么样，心里有底了再装。

（2）“安装Ubuntu 10.04.1
LTS”------这不用我说了，意思就是安装，这个选项一般是心里有底的老熟人选的。

可能有人对第1个选项还是不理解。试用？这系统还没装呢就能试用？对，能！因为我们Ubuntu的安装光盘是一张LiveCD。那么什么叫LiveCD呢？

所谓LiveCD，就是直接从光盘就能启动电脑并且运行的系统。整个系统在光盘上，启动后从光盘读取到内存里工作，可以进行一些基本的操作，像上网、听歌、玩游戏什么的，完全不需要硬盘。

通过LiveCD，就可以在安装之前，先对系统有个体验，也可以测试一下计算机的硬件是否都能很好地支持这个系统。如果哪天系统出问题了，还可以用这张光盘启动计算机，对硬盘上的系统进行修复（类似于WinPE的功能）。用户试用之后如果觉得好用，想安装了，就可以双击桌面上的Install图标，把系统安装在硬盘上了（这跟刚才直接选安装是一样的）。

好了，这个使用者像大多数人一样单击了“试用Ubuntu 10.04.1
LTS”按钮，于是我去叫醒和我挤在同一张光盘里的兄弟们：哥儿几个，考验我们的时候到了！

[[./Images/image00227.jpeg]]*提示：*有一些专门专注于LiveCD的Linux发行版，比较有名的有Puppy Linux、Knoppix、Slax等。

【不算高的配置需求】

按照指示，我开始进行系统启动的准备工作。

首先要检查一下这个电脑的硬件配置，如果LiveCD可以启动到桌面，并且速度不是太慢，说明这台电脑的硬件配置基本符合安装的要求。

“什么？你们Linux不就是跟DOS似的系统吗？也对硬件有要求？”对此，我只能说，您好像OUT了。虽然我们Ubuntu系统对硬件配置的要求一般，不算高，可也不能太低了。尤其我们10.04，怎么也得用2000年以后的机器吧。液不液晶无所谓，主要得看机箱里边。像CPU，怎么也得1GHz以上吧，你弄一个800MHz的奔腾3代，也好意思跟我打招呼？！内存512MB起，硬盘怎么也得5GB，什么办公的、作图的、聊天的，能装的软件我全都得给你装上呢。还得有个网卡，无线的有线的都行，ADSL拨号还是接路由的随便，反正得有网。要是没有网络想装Ubuntu，装好了也急死你。


【还算广泛的硬件支持】

除了检查电脑的配置，还要扫描一下这里的所有硬件，以确定加载哪种驱动程序，把能驱动的硬件都驱动起来。因为LiveCD试用的过程也是检查我们Ubuntu系统的硬件兼容性的过程。用光盘启动电脑一看，硬件都正常工作，这就放心了，说明这台电脑装Ubuntu没什么问题，直接装上都不用装驱动。否则可能就要在安装系统之后再上网找驱动安装了。

话说我所在的这台机器条件还不错。4GB的内存很宽敞，硬盘也有500GB大，其他的主要硬件，我也很熟悉。这主要是因为我们在Canonical学校的时候就进行了充分的学习，所以这里的东西我基本上都会用得比较顺手。像大螃蟹公司（特指Realtek公司）的网卡啦、Intel公司的南桥、北桥、声卡及双核CPU，我都能应用自如。只是这里的显卡是Nvidia公司的一款独立显卡，目前我还不能完全驱动它。不过别急，我们这一届Ubuntu系统，专门着重学习了显卡的使用，虽然默认情况下还是不能够启动3D加速，但是2D的显示已经很顺畅了，不会影响使用。要想启用3D加速也不难，等系统装好之后再去安装驱动就可以了。
# 所以这里有意思, Ubuntu跟我一样也在学习的过程中.


检查得差不多了，我从光盘上叫醒了图形部门的哥儿几个，主要是XWindow和Gnome小组，这两个部门负责在屏幕上显示图形操作界面的任务，以后还会经常介绍到他们。兄弟们干活儿都很麻利，只是光驱转得有点慢，所以耽误了一小会儿之后，屏幕上终于显示出了我们Ubuntu的默认桌面，如图2.6所示，应该不算土气了吧。

[[./Images/image00245.jpeg]]
图2.6　LiveCD启动后的系统界面

启动了之后，用户很好奇地点来点去。先是玩了会儿游戏；又看了看光盘里的一些示例文档；再打开Firefox上了会儿网。最后终于下定决心，双击了桌面上那个“安装Ubuntu
10.04 LTS”的图标------装！

** 2.3　入住

终于开始安装了，我要住进这台电脑啦！安装一共有7步。

*** 2.3.1　第1步：选择语言

跟启动一样，还得先问一下用户打算使用什么语言，如图2.7所示。有人说了，你这家伙健忘吧，刚才不是选过了吗？别急，听我解释。刚才选择的是从光盘启动的LiveCD系统使用什么语言，这回选择的是安装到硬盘的系统用什么语言。当然，我也不傻，知道一般情况下这两个都是一样的，所以给用户默认选择了简体中文。然后，用户只要单击“前进”按钮，这一步就算完成了。

[[./Images/image00246.jpeg]]
图2.7　选择安装系统的语言

*** 2.3.2　第2步：选择时区

选择时区也简单，根据主人选择的语言，我估计是个中国人，虽然这个国家地方大，不过全国都是一个时区，因此我替他选择了亚洲区，中国，上海------也就是东8区，如图2.8所示。好了，他继续单击“前进”按钮。

[[./Images/image00247.jpeg]]
图2.8　选择时区

*** 2.3.3　第3步：选择键盘布局

这个我也代劳了，替他选择了美式键盘，多数情况下是没错的。如果不是，可以单击“猜测键盘布局”单选按钮，然后单击后面的“猜测...”按钮，之后按照我的提示按下一些按键，我就可以知道用户用的是什么键盘了。或者，用户也可以自己直接在下面的列表框里选择自己的键盘。如果不知道自己选得对不对，我还给他提供了一个文本框来测试，就是图2.9所示的那个，多体贴啊！好，我的这位用户还是直接单击了“前进”按钮。

[[./Images/image00248.jpeg]]
图2.9　选择键盘布局

*** 2.3.4　第4步：分区

这回要了亲命了......好，咱一点一点慢慢说。到第4步分区这里，首先会有几个选项，让你选择分区的方式。

【清空并使用整个硬盘】

我最喜欢的是“清空并使用整个硬盘”，就像图2.10这样。这个选项的意思就是说不管现在硬盘里住着谁，有什么东西，统统给我卷铺盖走人，爷要住了！（低调低调）这样装完了之后硬盘上就啥都没有了，只剩我一个Ubuntu系统。不过一般人不会选这个选项，因为多数情况下硬盘里已经住了一个系统，而且用户并不想赶他走。

[[./Images/image00249.jpeg]]
图2.10　清空并使用整个硬盘

【分别安装它们，在启动时从中选择】

还可以选这个选项：“分别安装它们，在启动时从中选择”，如图2.11所示。选了这个选项你就什么也不用管了，一切交给我来处理，我办事，你放心。用户可以做的就是调整一下给我这个系统分配的空间，然后我自己会修改你已有的分区大小，挤出足够我住的地方来并安装。

[[./Images/image00250.jpeg]]
图2.11　分别安装它们，在启动时从中选择
*提示：*这种改变分区大小的动作还是有一定危险性的，请谨慎使用。

【使用最大的连续空闲空间】

比较没危险的就是这个“使用最大的连续空闲空间”。意思就是说，已经在硬盘里住下的系统不去管他，空间也不用调整。有多少地方空着呢，我就去那里整理整理住下。不过要注意，这个“空着”，可不是指你的E盘或者D盘之类的有空闲空间就行，而是得有没分区的空间，就像图2.12中的“未指派”的那样的区域才行。所以，要选这个选项，你需要事先在硬盘上空出一部分空间来不分区，或者把已有的分区删掉一个才行。

[[./Images/image00251.jpeg]]
图2.12　Ubuntu需要的硬盘空间

以上几个选项都是自动分区的，也就是由我自己决定划分多大的分区出来，哪个分区作为“/”等。最后一个选项就是“手动指定分区”，这个选项就需要了解分区知识的用户才能用，所以后面写了个“（高级）”。好，现在咱就仔细说说手动分区。

【手动分区】

选择了“手动分区”单选按钮并单击“前进”按钮之后，首先会显示出电脑当前的分区状态，如图2.13所示。同时，还可以注意到，总共的步骤变成了8步。多出了一步手动分区的步骤，也就是你现在正在操作的步骤，后面的步骤依次顺延。好，来看看怎么分。

[[./Images/image00252.jpeg]]

图2.13　手动分区

上方用一根棍状物体表示的就是你的硬盘，里面可能已经有一些不同种类的分区，用不同的颜色表示，下面用文字具体描述了当前分区的状况。有人会问，这个/dev/sda是什么啊，看着怎么这么奇怪呢？好，凑近点看，如图2.14所示。

[[./Images/image00253.jpeg]]
图2.14　硬盘和分区的表示方法

不必奇怪，/dev/sda是我们Linux用来表示硬件的方式。/dev/是一个目录，你看这个名字，dev，就是device的简写，这个目录下面放的全是设备文件（在我们Linux世界里，什么东西都是文件，硬件设备也是文件）。这个/dev/sda，就是/dev目录下的sda文件，这个文件代表什么呢？代表你的硬盘！sd代表存储设备，可能是硬盘，可能是U盘，也可能是SD卡之类的，a代表第1块，那么第2块就是sdb，第3块就是sdc。如果不考虑U盘之类的移动存储设备（假设安装的时候没插着），那么/dev/sda的意思就是你的电脑上的第1块硬盘。要是第2块，那自然就是/dev/sdb了。那么下面那个/dev/sda1呢？就是/dev/目录下的sda1文件，这个文件代表你的第1块硬盘上的第1个分区。那么第1块硬盘上的第2个分区就是/dev/sda2，第2块硬盘上的第4个分区就是/dev/sdb4。

*提示：*旧版内核还会区分IDE硬盘和SATA硬盘，IDE硬盘的设备文件为/dev/hdx，而SATA硬盘的设备文件为/dev/sdx，现在都统一为/dev/sdx。

那么现在，选中列表框里面“空闲”的硬盘空间，然后单击“添加”按钮，来添加一个分区。如果没有空闲呢？那就找一个你看着不顺眼的分区删呗！（上面的数据丢了别赖我啊，记得提前保存好）。添加分区的步骤并不复杂，就下面这么几步。

（1）单击“添加”按钮之后，会出现一个如图2.15所示的“创建分区”对话框，在其中可以选择分区类型是主分区还是逻辑分区。如果你不知道这两个选项有啥区别，那就不要动，用默认的就好，反正我们Ubuntu系统装在什么分区都可以。

[[./Images/image00254.jpeg]]

图2.15　创建root分区

（2）其次是分区容量，这个不用多解释吧，在文本框里写上希望的分区大小就可以了，单位是MB。

（3）分区的位置，一般也不用改，用“起始”就好。

（4）选择文件系统，也就是图2.15中的“用于”那个下拉列表框。我们Linux是不能使用FAT或者NTFS这样的文件系统的，这都是Windows系统用的。我们可以用的文件系统很多，新手可能不知道选哪个好。关于每个文件系统的区别和特点，来日方长，有机会慢慢说，现在，如果你不知道选啥，那就还是选默认的Ext4日志文件系统好了。

[[./Images/image00227.jpeg]]*提示：*安装时可选的其他几种文件系统中，reiserfs对于存取大量小文件的操作效率较高；XFS对大分区、大文件的操作有优势；btrfs对SSD硬盘做了一定的优化。

（5）挂载点，是让你指定这个分区用来干什么的。必须有挂载点是“/”。也就是说，你至少要分出一个区，挂载点选“/”。这个区有5GB就够安装系统的，不过如果你想拿我们Ubuntu作为日常使用的系统，而不是只装来玩玩的话，大方一点，分20GB吧。

好了，全都选完了，单击“确定”按钮，一个分区就建好了。

创建了“/”分区之后，再创建一个交换空间，步骤同上，只是在选“用于”的时候选“交换空间”，就行了，挂载点不用选，如图2.16所示。交换空间就相当于Windows下的虚拟内存，它的大小大约等于内存的大小就可以。如果内存很小（1GB以下），交换空间最好是内存的两倍。

[[./Images/image00255.jpeg]]

图2.16　创建交换空间

[[./Images/image00227.jpeg]]*提示：*对于2GB以上的内存，日常应用基本不需要交换空间，只会在休眠的时候用到。因此即使不分交换空间，系统也是可以工作的。

好了，分了“/”分区和交换空间就可以继续进行了。但是更专业一点，最好再分个“/home”分区。这里以后存的都是你自己的各种文件，音乐、电影、图片、各种文档，以及各种软件的配置文件都在这里，所以要尽量大一点。并且以后如果要重装Ubuntu系统，只要保留这个分区不格式化，并且依旧挂载为“/home”，那么这些个人信息就都还在。把上面说的这些都建好了之后，就可以看到类似图2.17所示的效果。

[[./Images/image00256.jpeg]]
图2.17　手动分区最终效果

我遇到的这个用户似乎有些经验，对分区这种事情比较了解，直接就选择了手动分区，然后分了20
GB给“/”分区，又分了220GB给“/home”，还分了2GB的swap区（就是交换空间啦）。分的时候我注意到，硬盘里另外的几个分区中似乎住着一个Windows
7系统，嗯，看来我有邻居了。

*** 2.3.5　第5步：填写一些基本信息

*提示：*如果上面选了手动分区就是第6步，以下同理。

分区完成，进入第5步，就会看到如图2.18所示的界面。这里有如下几项要填写。

[[./Images/image00257.jpeg]]
图2.18　创建用户界面

（1）名字，就是在文本框里写上你的名字呗，遗憾的是不能用中文。我这个用户填了名字叫lanwoniu。
（2）登录名，就是一般所说的用户名。刚才那个名字是用来显示的，这个名字是用来登录的，以后让你填这个系统的用户名时，填的就是这个。一般这两个名字都一样，于是在用户填写名字的时候，我就替他把登录名也写成lanwoniu了，他也没反对，
（3）然后是密码，按照国际惯例，输两遍。
（4）计算机名，随便起就行，我的用户给他的电脑起了个名字叫snail-computer，看来是嫌他的电脑太快了。
（5）最下面还有3个单选按钮，我逐个解释一下。

[[./Images/image00218.jpeg]]　“自动登录”------这个选项就是说系统启动的时候，自动用你现在创建的这个用户登录，不用输入密码。

[[./Images/image00218.jpeg]]　“登录时需要密码”------这个选项就是普通的登录模式，登录时需要选择用户并且输入密码。

[[./Images/image00218.jpeg]]　“登录时需要密码并且加密我的主目录”------这个选项在使用上跟第2个没有区别，但是这个用户的主目录会被加密存储。

都填好了之后，还是单击“前进”按钮，就进入下一步了。

这里要说明一下。这一步创建出来的这个用户是拥有管理员权限的用户，但是不是root用户哦，所以这里不要试图创建root用户。可能有的同学听说过Linux下面有个root用户很好很强大，不过在我们Ubuntu系统里，你可以渐渐淡忘这个root用户了。这一步创建的这个用户虽然不是root，但是，这个用户却有着变身成root的权力！

[[./Images/image00227.jpeg]]*提示：*root用户的权力过大，使用root登录时如果出现误操作，很容易造成不可补救的后果，因此Ubuntu系统默认禁用了root用户。

*** 2.3.6　第6步：导入用户信息

如果电脑里已经有了其他的操作系统，我可以帮助用户把原来放在那个操作系统上的一些配置信息，数据什么的导入到新的系统上来。包括原来的浏览器里的书签，原来桌面的壁纸、用户存的图片、文档、音乐等，我都可以顺手给存在我这边。图2.19所示是一个导入用户信息的示例。

[[./Images/image00258.jpeg]]
图2.19　导入用户信息

*** 2.3.7　第7步：确认信息

前面的操作都做完了之后，这里会让你确认一下之前步骤中所做出的各种选择，如图2.20所示。尤其是对硬盘分区的修改，要是现在反悔还来得及，因为到目前为止我还没有做任何实质的改动。如果没什么问题，看见没有，右下角那个按钮不是“前进”了，变成“安装”按钮了。别犹豫，来吧！

[[./Images/image00259.jpeg]]
图2.20　安装前的最后确认

安装的过程中我会去网上查找有没有可用的更新，如果有什么软件有新的版本了，就不给你装光盘上的，直接从网上下载最新的装上。还有一些光盘上没有的语言包，也会从网络上下载。不过下载的速度一般会比较慢，因为我只会去国外的官方网站上找（我刚出生嘛......就从那来的，所以只认识那）。要是你等不及的话（一般人都等不及），安装的时候干脆把网线拔了，断了我这念想，装得就快了，有半小时也就装完了。当然，这还得看你的电脑速度。

*** 2.3.8　扩展阅读：Linux中的最高权限

在安装的过程中，咱们介绍了Linux系统中有个root用户，拥有着最高的操作权限。有的同学可能会说：“我知道，root就相当于Windows系统里的administrator嘛，都有着最高的权限。”很好，领悟得很快，但是------并不准确。

【并非至高无上的administrator】

Windows系统下权力最高的是谁？是administrator吗？很遗憾，不是。是SYSTEM！也就是系统自己，Windows7自己。任何管理员的权利都不能大于Windows7自己的权利。你可以试试去把C:\WINDOWS下的regedit.exe删了。能吗？“哇！我删了耶，没报错。”别着急，刷新几下看看，是不是又出来了？Windows7会保护自己，不叫人类破坏。这个初衷看似还是好的，但是当Windows7自己中毒的时候，就不一样了。当他中毒时，就像被外星生命寄生了的人类（异型看过吧？），就不再是正常的人了，不正常的Windows7仍然会努力保护自己，不让人动他身上的任何部分------包括已经中毒变坏的部分。

【真正至高无上的root】

那么Ubuntu下（其他Linux系统也是一样）权力最高的是谁？毫无疑问是root！是这个用来给人类登录的用户。root在系统中拥有真正的至高无上的权力。他真的无所不能，他可以运行 =rm *-rf=（危险动作，切勿尝试，后果自负）删除系统中的所有文件。或许我会语重心长地警告他：这么干很危险滴，这么干就都删光光了，这么干我这个系统就嗝屁了，不存在了！但是，当他确认地告诉我，他现在很清醒很冷静，知道自己在干什么之后，我会义无反顾地流着两行热泪按照他的命令去做！哪怕他要格掉整个硬盘，我也照办。这真是，君叫臣死，臣不得不死；他叫我格，我不能不格（Windows下是不可能在系统运行的时候格掉系统盘的）。

【理念不同带来的权力不同】

会有这样的区别，原因还是我们两个系统的理念不同。

Windows7认为：人类是会犯错误的，很可能一不小心就把系统搞坏了，所以必须加以限制。有些事情让做，有些事情无论如何不能让他们做。而我总觉得，人类是聪明的，他们知道自己在干什么------尤其是用root登录进来的人。我认为他是了解我，了解整个电脑才会用root登录进来做事情的。所以他的命令不会受到任何的阻挠。而一般的用户会用普通账号登录，既然用普通账号登录，就说明他们承认自己只是个使用者，可能会做错事。那么我就会稍微进行限制，让他们不会破坏我，也不会破坏其他用户的东西。所以，当你用root账户登录进来的时候，一定不要辜负我对你的信任。

*** 2.3.9　扩展阅读：Linux的分区和挂载

在安装的过程中，有的同学对这个Linux系统的分区还是不大明白，因为跟Windows下的有些区别。没事，咱们仔细说说。

【你们住房子，我们住硬盘】
# 类比得好。
话说我们软件要想在一台电脑里定居，得有个住的地方，就好像你们人类要在一个城市里定居得有个住处一样。不过我们软件并不像人类一样，住在钢筋水泥的格子里面，我们住的地方，是一块叫做硬盘的空间。说起来我们住的这个硬盘空间，和你们人类住的这个房子是很相似的。那我们就拿您这房子来做对比，说说我们这个硬盘空间吧。

首先，你们人类的房子就是一大块能放东西的空间，是吧。有大有小，100平米的、200平米的、40平米的都有。里面放着洗衣机啊、电冰箱啊、床啊、桌子啊之类的各种东西。我们软件住的硬盘也是一大块能放东西的空间，大小也不一定，什么80GB的、200GB的、500GB的、一个TB的都有。里面存着文档、电影，各种程序，以及我这个操作系统等数据。
#+BEGIN_SRC shell :results output
lsblk
#+END_SRC

#+RESULTS:
: NAME                 MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
: loop0                  7:0    0  89.1M  1 loop /snap/core/7917
: loop1                  7:1    0  89.1M  1 loop /snap/core/8039
: sda                    8:0    0   113G  0 disk
: ├─sda1                 8:1    0   512M  0 part /boot/efi
: └─sda2                 8:2    0 112.5G  0 part
:   ├─vgkubuntu-root   253:0    0 111.6G  0 lvm  /
:   └─vgkubuntu-swap_1 253:1    0   980M  0 lvm  [SWAP]


你们的房子一般不会是一个整个的空间（毕竟那是要住人的，不是仓库），而是会被分割成几个小的空间，一间屋，一间屋的。我们的硬盘虽然也可以好几百GB整个用，可也不是很方便，一般也会被分割成几个小的空间，每个空间就叫一个分区，一个分区就好比你们那一间屋。

#+BEGIN_SRC shell :results output
fdisk -l
#+END_SRC

#+RESULTS:

【住房要有很多功能空间】

好，关于屋子和分区的事情暂时先放放，说说你们人类日常生活习性的问题。你们一般每天要吃3次饭，一般不愿意露天吃，是吧，需要有一个吃饭的地方。而且既然吃饭，就得有个做饭的地方，甭管是谁做，反正得加工一下，不像兔子似的路边上逮着块草地就能过去啃两口。一天3顿饭之后，得休息，需要有睡觉的地方，大桥底下也好，水床上面也罢，总得有个地方。那么刚才说的你那房子里，就有为满足你的各种需求而设计的各种功能空间。有放着床睡觉的地方；有摆着炉灶，锅碗瓢盆啥的地方，那是做饭的地儿；放个饭桌，这一看就知道，吃饭的地儿；放个马桶，那这就是厕所。
#+BEGIN_SRC shell :results output
df -hl
#+END_SRC

#+RESULTS:
#+begin_example
Filesystem                  Size  Used Avail Use% Mounted on
udev                        1.9G     0  1.9G   0% /dev
tmpfs                       385M  1.4M  384M   1% /run
/dev/mapper/vgkubuntu-root  110G   48G   57G  46% /
tmpfs                       1.9G  174M  1.8G  10% /dev/shm
tmpfs                       5.0M  4.0K  5.0M   1% /run/lock
tmpfs                       1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/loop0                   90M   90M     0 100% /snap/core/7917
/dev/loop1                   90M   90M     0 100% /snap/core/8039
/dev/sda1                   511M  7.9M  504M   2% /boot/efi
tmpfs                       385M   16K  385M   1% /run/user/1000
#+end_example

那么我们Linux的硬盘里也有类似的情况（当然，我可不是说我们这也有厨房厕所啊）。我们Linux系统有着独特的目录结构，最基本的是一个根目录，我们喜欢叫它“/”，它就像您那整个一大间屋子。“/”目录下还有很多的目录，比如“/etc”，是用来存配置文件的；“/bin”是用来放二进制程序的；“/boot”是用来放启动文件的；“/lib”是用来放库文件的；还有“/home”是用来放用户的各种文件的。这一个个的目录，就好像你房里一个个的功能空间一样，各有各的用途。
# bin boot lib etc var
#+BEGIN_SRC shell :results output
ls /
#+END_SRC

#+RESULTS:
#+begin_example
bin
boot
cdrom
dev
etc
home
lib
lib32
lib64
libx32
lost+found
media
mnt
proc
root
run
sbin
snap
srv
sys
tmp
usr
var
#+end_example

【分区和目录的联系】

那么说了这么半天，又是分区，又是目录的，分区跟目录有什么关系呢？有人说了：“我知道，分区就是C盘，D盘，E盘这些，每个盘里再有各自的目录。”兄弟，我只能告诉你，你又OUT了。刚才我说了我们Linux的目录结构，就是一个“/”目录，下面有一些次级目录，每个次级目录下面再有子目录及子子目录......无论分区情况如何，这个目录结构是不会变的。那么分区怎么跟目录联系起来呢？联系就是，你可以指定任意一个目录里的东西存在某个分区里，如果不指定，则这个目录里的东西存在上一级目录所在分区中，如果上一级目录也没有特殊指定分区，则再上溯一级目录，依此类推。这么一直上溯，就一定会上溯到最上层的根目录“/”。所以，装系统的时候，其他的可以不指定，但一定要指定“/”目录存放在哪个分区。
#+BEGIN_SRC shell :results output
ls /lib
#+END_SRC

#+RESULTS:
#+begin_example
accountsservice
apparmor
apt
aspell
at-spi2-core
avahi
bfd-plugins
binfmt.d
binfmt-support
bluetooth
bolt
calibre
cantata
cnf-update-db
colord
command-not-found
compat-ld
console-setup
cpp
crda
cryptsetup
cups
dbus-1.0
dconf
debug
dkms
dpkg
eject
emacs
emacsen-common
encfs
environment.d
file
firefox
firefox-addons
firmware
fwupd
gcc
geoclue-2.0
ghostscript
girepository-1.0
git-core
gnupg
gnupg2
GNUstep
gold-ld
groff
grub
grub-legacy
hdparm
init
initramfs-tools
ispell
kauth
kernel
klibc
klibc-KzNL5rI0ooqhK-koTVzHy10DW4w.so
language-selector
lantern
libadplug-2.2.1.so.0
libadplug-2.2.1.so.0.0.0
libchm.so.1
libchm.so.1.0.0
libepub.so.0
libepub.so.0.2.1
libfreecell-solver.so.0
libfreecell-solver.so.0.6.0
libgnustep-base.so.1.26
libgnustep-base.so.1.26.0
libhardsid-builder.so.0
libhardsid-builder.so.0.0.1
libkolabxml.so.1
libkolabxml.so.1.1.6
libmbim
libnetpbm.so.10
libnetpbm.so.10.0
libpodofo.so.0.9.6
libqmi
libreoffice
libresid-builder.so.0
libresid-builder.so.0.0.1
libsidplay2.so.1
libsidplay2.so.1.0.1
linux
linux-boot-probes
linux-sound-base
locale
lp_solve
lsb
man-db
mecab
memtest86+
mime
modprobe.d
modules
modules-load.d
mozilla
mysql
netplan
networkd-dispatcher
NetworkManager
nodejs
nvidia
openssh
os-prober
os-probes
os-release
p7zip
packagekit
pcmciautils
phantomjs
pkgconfig
pkg-config.multiarch
pm-utils
policykit-1
pppd
pulse-13.0
python2.7
python3
python3.7
python3.8
qt5
recovery-mode
rsyslog
ruby
sasl2
sbcl
sftp-server
shim
simplescreenrecorder
snapd
software-properties
ssl
sudo
sysctl.d
syslinux
SYSLINUX
syslinux-legacy
systemd
sysusers.d
tc
terminfo
tmpfiles.d
ubiquity
ubuntu-advantage
ubuntu-release-upgrader
udev
udisks2
ufw
upower
valgrind
X11
x86_64-linux-gnu
xorg
xserver-xorg-video-intel
#+end_example

比如说，可以整个硬盘就一个分区，然后指定根目录“/”存在这个分区中。好，那么整个“/”目录，以及“/”目录下的各级子目录里面的所有东西，都存放在这个大分区里。我也可以分两个区，分区甲和分区乙。我指定“/”目录存在分区甲里面，然后指定“/home”目录存在分区乙里面。那么整个“/”目录，以及“/”目录下的，除了“/home”目录及其下各级子目录外，其他目录里面的所有东西，都存在分区甲。“/home”目录及其下各级子目录里的东西，存在分区乙。当然，也可以分80多个分区，给每一个目录都手动指定一个分区来存放东西------如果你吃得有点多的话。

这种分区和目录的关系，就像你房子里的房间和功能区之间的关系一样。可以为做饭的地方单独分出一间屋子来，叫做厨房。但是也可以是开放式厨房，厨房并不单独放在一间屋子中，而是和饭厅公用一间屋子。同理，可以为“/home”单独指定一个分区，但也可以不单独指定，而是存在“/”所在的分区中，作为“/”下的一级子目录，和“/”公用一个分区空间。是不是很像呢？

最后再说一点，给某一个目录指定分区的动作，有个专业术语，叫做“挂载”，以后还会经常提到。
# 分区是物理动作，比如插入硬盘。

** 2.4　G大叔--介绍启动管理器Grub

经过漫长的等待之后，安装终于完成了。我总算离开了光盘，在硬盘里落户了。用户随即发出命令：重启！我满怀信心地看着已经来到硬盘上的兄弟们：“我们就要开始一段新的生活了，希望大家能够做出最大的努力，让用户认可我们这个系统。”看着兄弟们意味深长地对我点了点头之后，我静静地，闭上了眼睛，安心地睡去了，等待着G大叔把我叫醒。

*** 2.4.1　计算机启动流程

“嘿，小子，起床了！”

我睁开眼，看看眼前站的人，是门房的G大叔。我仔细回忆了一下......哦，想起来了。我刚刚被安装到一台电脑里，这是我的第一次启动。

有人说，你记性怎么这么差啊，这才几秒钟前发生的事情，你怎么就忘了？别奇怪，这是我们软件族的特点。一方面，几秒钟对我们软件来说已经是很长的时间了。另一方面，我们软件不像你们人类，睡觉的时候还能做个梦啥的。我们睡觉的时候（也就是系统没启动的时候），是什么也不知道的，之前发生的事情，需要记忆的，我们都会在睡觉前写成文件放在我们住的硬盘里，这样下次起床就能回忆起来了。

【起床的过程】

每当用户需要我起床工作的时候，他就会按下计算机的电源键，然后，就开始了我漫长的起床过程。

首先，当计算机的电源键被按下时，会有一股温暖而舒适的电流从电源涌入，流遍整个主板，流经每个元件，流到BIOS居住的那颗芯片里。BIOS就是开机时你按Del键进去的那个蓝屏幕（不是所有主板都按Del键进BIOS）。BIOS这个家伙其实也是一个软件，但他是一个特殊的软件，特殊到一般都不归在软件的行列里，而是被叫做“固件”，因为他住在主板上的一个芯片里，而不像我们住在硬盘里。电流流到BIOS住的芯片后，会由芯片上的某一根管脚流进芯片内部，并准确无误地击中的BIOS的身体，于是------BIOS就醒了（合着天天被电醒的，真惨）。
# 主板芯片.

[[./Images/image00227.jpeg]]*提示：*BIOS是Basic Input-Output System（基本输入/输出系统）的简写。

BIOS醒来之后就开始工作。他的工作平凡而重要，复杂而机械，就是去检查CPU、内存、显卡等是否都正常。都检查一遍没有问题之后，就来到我们住的硬盘这里，来到那间传达室，完成他的最后一个任务------叫醒在门房值班的那个人。
# 门房的比喻太棒了.
我搬到这里之后，门房里值班的人，就是G大叔了。G大叔大名叫做Grub{grand unified bootloader}，现在已经是2.0版本了。他是一个启动管理器，平时就住在传达室。所谓传达室，学名叫做MBR{Master Boot Record}，是一个硬盘的入口，硬盘的第0号扇区。传达室不属于任何一个房间，或者说，MBR不属于任何一个分区。
# 妙妙, 传达室的概念妙.
传达室很小，只有512Byte。由于传达室地方实在太小，因此G大叔会把一些有用的文件放在我的硬盘空间里，必要的时候来看看。

[[./Images/image00227.jpeg]]*提示：*MBR中的内容主要有两部分，一部分是启动代码，另一部分是硬盘的分区表。由于空间有限，只能写下4个分区的信息，因此一块硬盘最多只能有4个主分区或扩展分区。

G大叔被BIOS叫起来之后，会来我的硬盘里读取/boot/grub/grub.cfg文件，根据这个文件的内容来决定他的动作。这个文件里写了启动的时候应该给用户多少个选项，每个选项都是什么，背景啥样，等待多长时间等。G大叔按照这个文件上的要求显示给用户一个多系统选择的界面，就像图2.21这样（Grub默认界面应为黑底白字，本书为了提高印刷后的图片质量，特做反色处理）。

[[./Images/image00260.jpeg]]
图2.21　Grub启动界面

用户做出选择后，如果是选择了我，那么G大叔就像刚刚这样，来到我屋里，叫我起床，于是我这个Ubuntu系统就启动了。

*** 2.4.2　多系统的共存

可能有同学会问，那G大叔除了叫你之外，还能去叫谁呢？G大叔是个启动管理器，如果只负责引导我一个系统，那还怎么称得上“管理”二字呢？G大叔能够支持多种系统的引导。比如那个水果公司的MacOS系统、与我们Linux同宗的BSD系统、微软公司的“查皮”WindowsXP系统、“喂死它”Vista系统、“温妻”Windows7系统，甚至“剁死”（DOS）系统等，G大叔都能够支持。

具体怎样才能让G大叔引导其他系统呢？这个不用您操心，我们Ubuntu系统在安装的时候，会派G大叔去检查硬盘上已经存在的系统，然后根据情况制定出合理的计划。这一切都是G大叔自动完成的，您装完系统重启计算机后，就能看到硬盘上已有的系统已经被G大叔正确识别出来了。
# 原来是自动完成的, 所以需要最后安装linux系统.
[[./Images/image00227.jpeg]]*提示：*MaxOS需要安装在主分区才能够正确地被Grub引导。

就拿我定居的这台电脑做例子吧。

我们来之前，电脑里已经住进了一个操作系统，就是微软公司的Windows7。Windows7一个人住的时候，传达室是没人的，只放了一个简单的类似门铃的装置。BIOS来传达室叫人的时候，只要按一下那个铃，那边的启动管理器就会去叫Windows7起床了。

G大叔搬进去的时候，会考虑到原有的Windows7系统，查看一下叫醒Windows7的那个门铃连到了哪里。一般是连到一个叫做Bootmgr.exe的程序，一按门铃，Bootmgr.exe就被叫醒了。于是G大叔记好Bootmgr的位置，再记录好我的位置，生成一个grub.cfg文件，放到/boot/grub/目录下。咱不是说过么，我们软件要想记住点什么东西，都得写成文件放到硬盘里，G大叔也不例外。

当用户启动电脑，G大叔被叫醒的时候，他就会一脸严肃地问用户：要用哪个系统？一个Ubuntu一个Windows7，给你10秒，快选！如果用户选我，G大叔就来叫醒我，如果选Windows7，G大叔就去按照之前记录的位置，找到Bootmge，一脚把他踹醒。

虽然G大叔说话有点不客气，不过工作还是尽职尽责的，多数常见的操作系统、常用的分区格式，G大叔都不在话下。他总说，传达室不是某一个系统专用的传达室，在传达室工作的软件，就该为硬盘上的每一个系统都服务好。

[[./Images/image00227.jpeg]]*提示：*WindowsXP之前的NT内核系统使用的是ntldr作为启动管理器，从Vista开始换成了Bootmgr。新版的Grub对这两者都可以完美支持。

*** 2.4.3　重装Windows后Grub的修复

可是Windows 7那边的作风就不一样了。

如果硬盘上已经住进了我，门房里已经有了G大叔，这时候重装或者新装Windows7系统的话，Windows7就不管三七二十一地把G大叔赶出来，在传达室装好他的“起床铃”就走了，不管我这边的情况。电脑再启动的时候，BIOS就找不到G大叔，只能去按那个铃，直接启动Windows7，我的存在就完全被无视了。

如果这样的惨剧不幸发生了怎么办呢？没关系，他能把G大叔赶出来，我照样能让G大叔再搬进去！想强拆？没门！不过具体怎么操作呢？再重装一遍Ubuntu系统？不用。还记得那张安装光盘么？还记得我说系统出问题的时候可以用它来修复么？没错，就是那张，赶紧让你家狗狗把他叼回来，现在用上了！

像安装的时候一样，用LiveCD启动电脑，选择试用，这样就启动了光盘上的Ubuntu系统。这时候，电脑可就归我们Linux管啦！嘿嘿，小小的Windows
7算什么，你想把我们的G大叔撵走就霸占整个硬盘了？想得美！LiveCD启动之后，打开命令行，运行 =sudo-i= ，获取权限。然后运行：
: mount /dev/sdax /media/

提示：*$符号是普通用户的命令提示符，不是命令的一部分，不需输入。

这里sdax就是你安装Ubuntu的时候用作根目录“/”的那个分区，如果你还单独分了“/boot”分区，那么还得运行：
: mount /dev/sday /media/boot/

当然，这里的sdax，sday都需要根据你的实际分区情况修改，可能是sda1，sda4，或者sdb2，sdc8，都没准儿。mount好了之后，运行：
: grub-install -root-directory=/media/ /dev/sda

运行完了就好了。最后重启电脑，熟悉的G大叔又回来了。

当然，以上说的都是以后可能发生的情况，目前在我这里还没有这样的事情，隔壁那个Windows7睡得像死猪一样，不会有什么举动的。而G大叔早在安装的时候就自动设置好了多重系统启动，刚刚就是用户告诉G大叔来叫醒我去干活的。

*** 2.4.4　Grub的简单配置

起床之后，用户似乎对G大叔的举动不是很满意，打算要修改一下G大叔的配置文件。

刚才我们说了，G大叔启动的时候会去找=/boot/grub/grub.cfg=文件，这里面记录了G大叔应该做的一些事情。不过用户要想修改这些设置，可不需要修改这个文件，而是要改=/etc/default/grub=文件。这个文件里，简单明了地记录了G大叔应该做的一些动作。

[[./Images/image00227.jpeg]]*提示：*旧版Grub的配置文件为/boot/grub/menu.lst，新版Grub将原有的一个配置文件分为/boot/grub/grub.cfg和/etc/default/grub两个。前者更加复杂，提供给Grub读取，以提供更复杂的功能。后者更加简明，提供给用户，用于一些简单的配置。
# 找打了该命令.
只见用户下达了命令：
: sudo emacs /etc/default/grub

这么命令的意思就是，以root用户的身份，命令gedit软件，去打开/etc/default/grub文件。输入这个命令之后，我会要求用户再输入一遍他自己的密码，注意，是当前用户的密码（比如我这里，就是lanwoniu这个用户），不是root的密码，真正的root用户的密码......是个迷。关于这个sudo，咱们后面还会见到它，这里暂且不表，您只需要知道命令就这么敲就行了。命令运行后，就会看到打开了一个gedit软件，里面显示的就是grub文件的内容，大约就是这样：

[[./Images/image00265.jpeg]]

这一大堆看着有点乱，不过别害怕。首先，所有以#开头的行都是注释，那是给人类看的，G大叔会直接忽略掉这些行。剩下的就不多了，好，慢慢介绍。

[[./Images/image00227.jpeg]]*提示：*Linux下的绝大多数配置文件和脚本都以#作为注释行的开头。

[[./Images/image00218.jpeg]]　解释1：GRUB_DEFAULT=0这一行的意思，就是让G大叔在用户没有选择的情况下，默认来叫醒我。因为在电脑启动的时候，G大叔给用户的选项里，叫醒我是排在第1个的（但是G大叔数数喜欢从0开始数，所以是“=0”）。这里也可以写saved，意思就是记住上一次开机的选择。上次选的谁，这次就默认选谁。

[[./Images/image00218.jpeg]]　解释2：GRUB_HIDDEN_TIMEOUT_QUIET=true是说倒计时的过程中不显示秒数，只默默地计时。如果这一行设为false，则G大叔会显示倒计时还剩下多少秒。

[[./Images/image00218.jpeg]]　解释3：GRUB_TIMEOUT=10这一行是G大叔给用户选择的时间，也就是10秒钟。如果不选就根据GRUB_DEFAULT的设置，选择默认的系统去了。如果不希望有时间限制，就设置为--1。

[[./Images/image00218.jpeg]]　解释4：GRUB_CMDLINE_LINUX_DEFAULT="quiet splash"这一行是启动时Grub大叔要传给我这个Linux内核的启动参数。这个参数只有在正常启动的时候会传给我，recover模式就不传了。quiet的意思是告诉我，启动时不要打印任何信息。splash是告诉我要显示启动画面。
# 显示启动画面.
[[./Images/image00218.jpeg]]　解释5：GRUB_CMDLINE_LINUX=""也是启动参数，跟上面那一行不一样的是，这一行设置的参数无论是什么启动模式，都会传给我。

我这个用户主要是想改改默认启动的系统，于是把GRUB_DEFAULT改成了4。我掐指一算，改成4，也就是启动时G大叔给用户的第5个选项......哦，是去叫醒Windows7。哎......看来还是不喜欢我啊。另外GRUB_TIMEOU也被用户改成了5，看来这个用户还是个急性子。

改完了之后，保存好这个文件，但还不算完，光改这个文件是不管用的，G大叔真正关心的是/boot/grub/grub.cfg文件。还得运行一下：
: sudo update-grub

这样，就会根据刚才修改的grub文件，自动生成一个给G大叔看新的grub.cfg文件，这就算修改完了。

*提示：*在Linux系统的终端中输入密码时，密码不会回显。
# 门房grub大叔, MBR是传达室, 硬盘的第一个扇区. bios首先被电醒.

** 2.5　更多选择

从安装到第一次启动，我还算比较顺利。可能是我遇到的这个用户运气好，也可能是我运气好，遇到个水平比较高的用户，到底是谁运气好，这是个哲学问题......不过总之，会有一些人安装Ubuntu不是那么顺利，或者因为种种原因安装遇到阻碍。不过没关系，没有什么困难是不能克服的，我们Ubuntu系统的安装方法多着呢。

*** 2.5.1　基于Windows的wubi安装

有人说，我就遇到困难了。你刚才讲了这么半天，那么多步骤，还得分区，还得设什么BIOS，太复杂了，听不懂啊。有简单点的办法没有？我告诉你，有。

为了使更多已经装了Windows7之类系统的人能够更加简单地安装和体验我们Ubuntu系统，我们的光盘里带了一个软件，叫做wubi。您可别误会，他可不是个输入法，不要妄想用五笔字型输入“我要装系统！”就能把Ubuntu装上。这个wubi是WindowsUBuntuInstaller的缩写。这家伙是运行在Windows7系统下的软件，他的功能，就是帮助你在Windows7系统下安装我们Ubuntu系统。不用你懂分区，不用你知道挂载，不用改变当前硬盘的状态，一切全都交给他就好。并且我们这个光盘还设置好了自动运行，光盘放进去就会看到wubi运行的界面了，就是图2.22所示的这样。

[[./Images/image00267.jpeg]]
图2.22　wubi运行界面

第1个选项，就是之前说的光盘安装。选了这个选项之后电脑就会重启，然后从光盘启动（当然还得设好BIOS），之后就跟我们说的光盘安装没有区别了，不选这个（不选你说那么半天！）。看第2个选项，“在Windows中安装”，这个看着新鲜吧？好，就是它了！
单击“在Windows中安装”按钮之后，就看到一个如图2.23所示的设置窗口。

[[./Images/image00268.jpeg]]
图2.23　wubi安装设置窗口

要设置的东西不多，也都挺简单的，咱们一个一个说。

（1）目标驱动器，就是让你选择把Ubuntu装在哪个盘上。一定要找个空闲空间大的盘，因为装的时候要在那个盘上创建一个巨大的文件，文件的大小就是下面那个“安装大小”里选的大小。这个巨大的文件会被Ubuntu当作硬盘来用，系统就装在这里面，因此就不需要调整你的实体硬盘了，避免出现数据丢失。怎么样，很人性吧？

[[./Images/image00227.jpeg]]*提示：*由于FAT32支持的文件大小有限，因此选择的目标驱动器需要使用NTFS文件系统。

（2）安装大小，不多说了，就是用来当硬盘的那个文件的大小。这个大小一旦确定，装好Ubuntu系统之后，可就不能改了，所以一定要想好。如果想日常使用，至少要20GB，如果只是装来看看，10GB就够了。

（3）桌面环境，没啥可选的，就是Ubuntu。

（4）语言，你说呢？

（5）用户名，就是安装时创建的那个有变身能力的用户。

（6）口令，就是密码，你知道的，国际惯例。

都选好了，自然就单击下面的“安装”按钮。之后就进入安装的第一阶段，这里没什么可说的，都是毫无悬念的进度条。这个过程结束之后会问你要不要重启。如果你正跟小妹妹聊得火热，待会儿再重启也不妨，如果没什么事情，那就赶快重启看看吧。

重启之后会看到系统选择的界面，装过多个Windows的同学会很熟悉，就像图2.24所示的这样（此界面应为黑底白字，本书为了提高印刷后的图片质量，特做反色处理）。

[[./Images/image00269.jpeg]]

图2.24　wubi安装后的多系统选择界面

选哪个？还用问吗，自然是Ubuntu。选择之后就进入安装的第2个阶段，第2阶段也只是没有悬念的进度条而已，等着就好了。装好了再重启，OK，可以进入Ubuntu了。

[[./Images/image00227.jpeg]]*提示：*wubi安装的Ubuntu系统由于使用的是虚拟的硬盘，因此磁盘读写的性能要比装在真实硬盘上的Ubuntu差一些，并且可能会导致系统不稳定。

*** 2.5.2　U盘安装

又有人说了，我还有困难。你上面说的方法都得用光盘吧，可我的电脑没有光驱，这可就没法装了吧。不管是申请来的光盘还是自己把ISO刻录成光盘都得有光驱呀。别急，光盘没有，U盘有没有？有U盘就行！

要想用U盘安装，需要几个前提。

（1）你得有个U盘（废话！），注意一定得是U盘，别拿个MP3或者手机糊弄我，弄坏了我可不负责。

（2）你的电脑要支持U盘启动，支持不支持查你的主板说明书去。基本上只要你的主板不是那种.能在古董市场看到的型号，都应该支持。

（3）就是我们接下来要介绍的，需要一个制作安装U盘的软件。

【用UltraISO制作安装U盘】

话说有这么个软件，叫做UltraISO。这家伙本事挺大，可以用来刻录光盘。“我没光驱啊，刻录的哪门子光盘啊！”您别着急，我还没说完呢，他不但可以刻录光盘，还能刻录U盘。

把您的U盘准备好，里面的内容赶紧先找别的地方存起来，一会儿就啥都没了。把U盘插在电脑上，运行UltraISO软件，会看到如图2.25所示的界面。单击左上角的“文件”菜单，选择打开，然后找到你下载的Ubuntu系统的ISO文件。打开ISO文件后的界面如图2.26所示。

[[./Images/image00270.jpeg]]

图2.25　UltraISO软件主界面

[[./Images/image00271.jpeg]]

图2.26　打开Ubuntu的ISO文件

[[./Images/image00227.jpeg]]*提示：*由于Windows7系统提高了系统的安全性，因此在Windows7中运行UltraISO软件需要以管理员身份运行。
然后单击“启动光盘”|“写入硬盘映像”菜单，会弹出“写入硬盘映像”窗口，如图2.27所示。

[[./Images/image00272.jpeg]]
图2.27 “写入硬盘映像”窗口

在该窗口中的“硬盘驱动器”下拉列表框里选择好你的U盘，可一定要选对哦，否则就指不定丢多少数据了。“写入方式”选择USB-HDD+，然后就开始吧，单击“写入”按钮。等写入完了，你的启动U盘就制作好了，用它启动电脑就像用LiveCD启动电脑一样了。不过要说明的一点，这个UltraISO可是要付费的，别偷来就用哦。“我平时也不用，就为了刻录一下还得付费？有点亏啊。”嗯，可能是有点，如果您不想用付费软件，没关系，咱还有办法。

[[./Images/image00227.jpeg]]*提示：*此方法仅限于Ubuntu10.04及其以前的系统。Ubuntu10.10及其以后的系统，由于ISO文件发生变化，无法使用UltraISO软件制作安装U盘，只可以使用下面介绍的UNetbootin软件制作安装U盘。

【用UNetbootin制作安装U盘】

还有个软件，叫UNetbootin。这个家伙是个免费的开源软件，可以到这个地方来找他：

这个软件同时支持Windows 7系统和我们Linux系统，您既然是想在Windows
7下创建Ubuntu的LiveUSB，那么自然要下载那个“ForWindows”版本的。从网上把这个软件下载到你的机器上，不需安装，直接运行。运行之后，就出现图2.28所示的界面。

[[./Images/image00274.jpeg]]

图2.28　UNetbootin软件界面

首先，整个界面上有两个单选按钮：一个是“发行版”；一个是“光盘镜像”。

如果选中上面的“发行版”单选按钮，那么软件就会从网络上下载指定的发行版并刻录到你的U盘，这属于一站式烧录，不过多数人不这么用。

你已经下载了Ubuntu的ISO文件，所以应该选中“光盘镜像”单选按钮，然后单击后面的“...”按钮（也不给按钮起个好名字），选择存在硬盘上的ISO文件。在“类型”下拉列表框里选择“USB驱动器”，再在“驱动器”下拉列表框中找到对应你U盘的驱动器（注意，驱动器一定要选择对！否则的话指不定你哪个硬盘的数据就挂了！）。至于“Space
used to......”那一行后面，如果你只是想安装系统，空着就可以了。

确认都选对了之后，单击“确定”按钮，就可以等着了。UNetbootin理论上是不会破坏你U盘上已有的数据的，但是你的U盘必须有足够的剩余空间，能放下一个ISO文件就差不多了。不过，虽然如此，还是建议你事先备份一下U盘的数据。

*** 2.5.3　其他版本的Ubuntu介绍

另外，去网上下载Ubuntu的同学也许会发现，除了ubuntu-10.04-desktop-i386.iso这个LiveCD以外，还有很多其他的Ubuntu安装光盘，比如什么ubuntu-10.04-desktop-amd64.iso、ubuntu-10.04-dvd-i386.iso、ubuntu-10.04-dvd-amd64.iso、ubuntu-10.04-alternate-i386.iso等。这么多种，有什么不一样呢？等我慢慢说给您听。

【i386和amd64的区别】

先说这个，ubuntu-10.04-desktop-amd64.iso。它和ubuntu-10.04-desktop-i386.iso唯一的区别就是一个是i386，一个是amd64（废话，傻子都知道！）。这里i386和amd64说的是CPU的类型。有的同学会说：“哦，那我知道了，这个i386，因为有i嘛，就是用在Intel公司的CPU上的，那个amd64自然就是用在AMD公司的CPU上的。”我很高兴地告诉这位同学：“你答错了！”i386指的是x86架构的32位CPU，因为这种架构是在当年Intel公司生产Intel
386处理器时就确定下来的，所以叫做i386。之后的奔腾几都是这个架构。还有AMD公司，也生产兼容x86架构的CPU，一大堆这个龙那个龙的，都是i386兼容的CPU。后来随着技术的发展，32位的CPU逐渐退出了历史舞台，出现了64位的CPU，至于具体什么是32位，什么是64位，它们有什么不同，咱们以后会详细说。

最先推出桌面用64位CPU的，就是AMD公司。所以目前普通PC用的64位CPU这种架构是AMD公司确定的，于是就叫做amd64。那什么CPU才是64位CPU呢？基本上你现在能买到的全是！刚才那位同学又说了：“哦，那我明白了。i386就只能装在32位的古董级CPU上，amd64就只能装在主流的64位CPU上。”我再次恭喜这位同学------又错了！考虑到现在的很多软件依然不支持64位，所以现在的家用64位CPU都是兼容32位的，也就是说在64位CPU上安装i386的系统是可以的，但是要在32位CPU上安装amd64的系统，那确实不行，想都甭想。

【DVD和CD的区别】

然后咱再说说这个ubuntu-10.04-dvd-i386.iso。最后的这个i386不用解释了，跟上面一样。主要就是这个“dvd”。其实这个安装文件跟desktop的区别就是，那个是CD的，这个是DVD的（又跟没说一样）。这个DVD的里面比那个CD多了一些常用的软件和语言包。不过有一点，默认安装的软件和CD版的是一样的，别以为DVD的就多给你装什么软件。只不过装完系统之后，可以从光盘安装其他的软件而不用上网去下载。这主要是针对上网不大方便的人用的。有一张DVD，基本软件就都齐了。另外还有一点好处就是，如果你选择的语言是汉语，DVD版的装好了之后有比较完整的汉化了，因为DVD容量大，可以装下更多的语言包。

【灵活的Alternate】

再说说这个ubuntu-10.04-alternate-i386.iso。Alternate的意思就是安装的时候可以选择安装的软件，可以装成桌面版，也可以装成服务器版，可以有图形界面，也可以没有图形界面。总之，有很多选择，是给高手们预备的。另外这个版本在安装的时候是没有图形界面的，安装时的界面大约类似图2.29这样。所以英语好、对Linux系统熟悉的同学才可以安装。

[[./Images/image00275.jpeg]]

图2.29　Alternate版本的安装界面

【高深的Server版】

最后，可能有的同学还找到了Server版本的Ubuntu系统。也许你是打算学习用Linux系统搭建各种网络服务器的知识，并且根据以前用Windows
2003之类的服务器系统的经验，觉得装个Server版就直接从入门到精通了。但是我们Ubuntu系统可不是这样，Server版绝对是专门当Server用的，因为------他们完全没有图形界面！

并且这里要说明的是，Server版和桌面版的区别并不大。一方面是自带的软件不一样，但是Server版也可以通过软件源装上桌面版的软件，反之亦然；另一方面，Server版用的是服务器专用的内核，但同样，桌面版也可以通过软件源，安装服务器版的内核，反之亦然。所以，无论你要用Ubuntu做什么，只要你是个新手，就推荐安装桌面版。

【各种其他“兔兔”】

除了我这种标准的“"乌棒兔"”------Ubuntu系统之外，我们Canonical学校其实还针对不同用户的需求，开设了很多其他的专业，培养出了多种“兔兔”。下面我就给您介绍一下其中最热门的3个吧：酷兔兔、小兔兔、育兔兔。

“酷兔兔”，也就是Kubuntu。他们都是艺术专业培养出来的学生。他们的样子要比我们Ubuntu好看些，精致些。这主要是因为负责为他们提供桌面环境的，是KDE团队，也因此才叫做Kubuntu。KDE桌面环境的特点，就是美观、细腻，并且愿意把各种部分的设置能力交给用户，让用户可以随心所欲地把自己的桌面改成想要的任何样子。图2.30所示就是Kubuntu系统的一个截图。

[[./Images/image00276.jpeg]]

图2.30　Kubuntu界面

“小兔兔”大名为Xubuntu。他们都是准备去艰苦环境下工作的志愿者。Xubuntu使用的桌面环境不是Gnome也不是KDE，而是XFCE，样子很朴素，就像图2.31所示的那样。XFCE的特点就是小巧，占用资源少。可以在很艰苦的硬件条件下很好地工作。比如内存，Xubuntu能够在200
MB内存的机器上流畅地运行。当然，相应的软件也要用一些轻量级的。要是在Xubuntu下运行一个非常耗资源的程序，那么该慢照样慢。

[[./Images/image00277.jpeg]]

图2.31　Xubuntu界面

Edubuntu，我们管他叫“育兔兔”，因为他是教育专业出身。Edubuntu用的桌面环境跟我一样，只是他附带了很多搞教育的软件，能够教小孩子打字、画画、学习物理知识之类的软件。图2.32中展示的，就是一些Edubuntu系统里的教育软件。这些软件都是很好的老师，很多小孩子用起来都乐此不疲。很多小游戏也都是寓教于乐的，家长给孩子用这个系统，完全不必担心孩子沉迷于游戏（因为实在没啥可沉迷的游戏......）。

[[./Images/image00278.jpeg]]

图2.32　Edubuntu中的教育软件

** 2.6　本章小结

这"乌棒兔"到现在，算是定居到了那位lanwoniu用户的PC上了。而且生活条件不错，硬盘宽敞，内存也够大，门房的那个Grub也幸运地没有遇到隔壁的强拆。折腾了这么半天，也够这兔子累的了。

不过光安装结束还远不算完，后面还有好多事等着他呢。诸位且听下回分解，看用户如何调教"乌棒兔"。
#+BEGIN_QUOTE
安装过程可以忽略,
启动过程bios的作用,Efi Extensible Fireware Interface
门房grub,达室MBR,
从有限的资源出发.
#+END_QUOTE
* 第3章 初始化配置

用户装完系统并改好启动顺序后，马上重启了一下看看效果。于是，BIOS再一次被电醒，Grub大叔再一次面无表情地问：要叫哪个？给你5秒，不说我就去叫WindowsXP了啊！用户满意地点点头，然后他选择了启动我这个新装的Ubuntu操作系统。于是，刚刚躺下还没把被子捂暖的我，又被Grub大叔叫起来干活了。哎，刚安顿下来也不让人家休息一下。不过也是，系统仅仅装好还不算完，还是要做一些基本设置的。

** 3.1　招贤纳士的apt

启动完毕后，这位懒蜗牛同学猛然发现，怎么好像菜单都是英文的呢（我终于根据用户输入的用户名，猜测到了他准确的中文名叫“懒蜗牛”，嘿嘿）？装的时候选的是中文啊。是的，虽然选的是中文，但如果用户在安装的时候没有联网，无法下载语言包，界面上就只有少数几个地方被翻译了过来，大部分的菜单还是英文的。那难道就这样凑合着看英文了？当然不是，系统安装好之后再安装中文包也是一样的。那么怎么安装中文包呢？又怎么安装其他需要的软件呢？嘿嘿，很简单。

[[./Images/image00227.jpeg]]*提示：*如果是DVD光盘版的Ubuntu，就可以在安装时装好完整的中文支持，CD版因为没有足够空间而无法提供完整的语言包。

*** 3.1.1　不一样的软件安装方式

懒蜗牛同学显然还没明白过来为什么满眼英文，他决定要为自己的记忆力讨个说法。于是他去查看了一下系统的语言设置。我看到他的这个操作，就赶紧很诚实地告诉他：你选的确实是中文，但是呢，由于一些错综复杂的原因（其实主要是因为我曾经逃了那么7、8节中文课），相关的一些语言包并没有完全安装，那么你现在要不要马上装呢？就像图3.1这样给他提示。懒蜗牛同学自然是义无反顾地单击了Install按钮，我一看用户决定要装中文包了，就赶紧去硬盘里叫醒专门负责安装软件的apt。

[[./Images/image00279.jpeg]]

图3.1　系统提示语言包未完全安装

*提示：*要查看系统语言设置，单击界面上方的System|Administration |Language Support菜单，选择的步骤如图3.2所示。

[[./Images/image00280.jpeg]]

图3.2　查看系统语言设置

【apt在Ubuntu中扮演什么角色呢】

这个家伙在我们Ubuntu系统里的角色，就像一个公司里的人事部经理兼后勤部长。
# 组织部长, 人事部门经理. 安装便是招聘了.
系统里装个软件、卸个软件的，都归他管。软件所需要用的各种环境文件啥的，也都是他负责准备。不像隔壁那个Windows7似的，装个软件要用户自己上网找、自己下载、自己安装。在我们这，apt全替您搞定了。当别人夸奖他的时候，他总是自信地拍拍自己的胸脯说：“本apt有着超级牛力。”因为他老把这句挂载嘴边，所以时间长了，我们就都管他叫“超级牛力”了（以下“超级牛力特指apt）。不过他也确实挺厉害，很牛很给力，工作起来兢兢业业，对于每个软件的各种情况了如指掌。要招一个软件来的时候，他会做好所有准备工作，这个软件需要用什么样的库，或者需要什么其他的软件协同工作，他都会事先做好准备。要是哪个软件不幸被用户辞退了，他也会帮忙把那个软件相关的所用东西一一清点好，清理出硬盘。
# apt作为组织部长

【apt是如何工作的呢】

比如，用户想用Vim文本编辑器来编辑文件，就叫apt去招Vim来工作。apt就会报告，说Vim要来的话，首先需要准备好libncurses这个库和python这种脚本语言的执行环境。征得同意以后，他就会去网上找这些东西，并且运回家，把库放在该放的地方，相关的软件安排好住宿。然后他再去找Vim同志，请他过来帮忙干活，并且说明：需要的环境都已经布置好了，来了之后马上就开工。每次新人来了之后都很感谢apt同志为自己做的这些准备工作，该有的东西，该来的助手都在，于是干活就事半功倍了。但把人才请来之后，apt同志的工作还没有结束，他还要把现在的人事情况记录下来，方便以后查看。万一哪天用户问起“我说apt啊，咱这现在都有多少软件啊，都是谁啊？”“装的那个某某软件的版本是多少啊？”之类的问题，apt也能从容地回答。

可以说，apt这家伙对于我来说实在是非常重要的，有了他，Ubuntu才是Ubuntu。所以，在我们这里，要忘记WindowsXP那种安装软件的方式，装软件就跟apt说，让他去办，省心，放心。

*小提示：*想看apt说自己有apt吗？在终端运行apt-get--help试试。
#+BEGIN_SRC shell :results output
apt-get --help | head
#+END_SRC

#+RESULTS:
#+begin_example
apt 1.9.4 (amd64)
Usage: apt-get [options] command
       apt-get [options] install|remove pkg1 [pkg2 ...]
       apt-get [options] source pkg1 [pkg2 ...]

apt-get is a command line interface for retrieval of packages
and information about them from authenticated sources and
for installation, upgrade and removal of packages together
with their dependencies.

#+end_example


这不，现在懒蜗牛同学说要装中文环境，我就叫来了apt，告诉他去装一些中文字体和中文的输入法。apt听完之后拍拍胸脯说：“放心吧，本apt有apt！”说完一转身，从网口跑出去，到网上下载东西去了。

*** 3.1.2　选择合适的软件源

平时apt干活是很麻利的，可是今天我在内存里等了足足有一秒钟，才见apt拖回来1
KB的数据。我赶紧拉住他问：“怎么回事？怎么这么慢啊！照这速度得什么时候下载完啊？”他叹了口气：“唉，别提了，这路太远了，得翻过6个路由，跨过8道防火墙，路还窄，不是车多流量大就是行驶缓慢。费好半天劲才拖回这么一点。本apt有apt，也架不住堵车啊。”我问他：“你是去哪下载的这些东西啊？”apt说：“就是那个默认的
http://cn.archive.ubuntu.com/ubuntu/
唉，这家伙，我知道是怎么回事了，这得从apt的工作原理说起。

【有个东西叫软件源】

apt的职责之一是从网上下载需要的软件，但他去哪下载呢？不是瞎找，而是去一个专门的叫做“软件源”的地方。那里为Ubuntu系统提供各种打包好的软件，以及相关的信息介绍。软件源有很多，遍布世界各地，具体该去哪里，是由“软件源列表”决定的。这个列表就写在/etc/apt/sources.list这个文件里，apt工作的时候，就按这个文件里写的地址去下载软件。现在系统刚刚装上，这个文件里写的是默认的软件源地址。有的人可能离默认的软件源挺近，速度挺快。有的人可能就得绕过半个地球才能过去，那自然就慢了。所以装完系统之后，要根据自己的情况，换一个速度快的软件源。
#+BEGIN_SRC shell :results output
cat  /etc/apt/sources.list | head -n 8
#+END_SRC

#+RESULTS:
: # deb cdrom:[Kubuntu 19.10 _Eoan Ermine_ - Release amd64 (20191017)]/ eoan main multiverse restricted universe
:
: # See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to
: # newer versions of the distribution.
: deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ eoan main restricted
: # deb-src http://cn.archive.ubuntu.com/ubuntu/ eoan main restricted
:
: ## Major bug fix updates produced after the final release of the

现在我这位懒蜗牛同学就是没有设置好软件源的典型案例。apt一边下载，一边向懒蜗牛同学汇报进度：“这个......根据计算，目前的下载速度大约每秒钟1KB，乐观地估计能赶在今年春节前下载完所有语言包。”懒蜗牛同学显然对这个结果很不满意，于是他做出了一个明智的决定------停止下载，先设置软件源！好，那咱们就该说说怎么设置软件源了？

【方法1，通过软件源管理器】

这是比较简单、省事的方法，推荐新手使用。

（1）单击界面上的System（系统）|Administration（系统管理）|SoftwareSources（软件源）菜单，如图3.3所示。这就是要启动软件源管理器。

[[./Images/image00281.jpeg]]
图3.3　打开软件源管理器

（2）进入这个软件之前需要确认一下您的身份，也就是需要输一下密码，只有管理员级别的用户才能够修改软件源。

（3）输入密码之后就可以看到软件源管理器的主界面了。可以看到下面有个Download
from，右面有个下拉列表框，现在选择的应该是“Serverfor中国”，我们要选那个下拉列表框里的“Other...”选项，如图3.4所示。

[[./Images/image00282.jpeg]]
图3.4　选择其他软件源

（4）选择之后会弹出一个如图3.5所示的窗口，让用户选择要用的软件源。用户可以直接在左侧的列表框里面选择，不过估计您会无所适从，不知道该选哪个。

[[./Images/image00283.jpeg]]
图3.5　列出所有的官方认证软件源

（5）如果无所适从，单击右上角那个Select Best
Server按钮，就会自动查找速度最快的软件源。

（6）查找结束之后，最快的软件源已经被选中，如图3.6所示，这时候只要单击Choose
Server按钮就可以了。

[[./Images/image00284.jpeg]]
图3.6　找到的最快的软件源

*提示：*最快的源不一定是地理位置上最近的，所以如果搜出个日本的源不要惊讶哦。

【方法2，自己手动换】

我们这位懒蜗牛同学就没有用上面那种简便的方式，而是想尝试一下亲自动手。他先是通过Firefox上网找到软件源的地址（Firefox是我们Ubuntu系统的默认浏览器，我喜欢叫她狐狸妹妹）。这并不难，用搜索引擎搜一下“Ubuntu软件源”，很多地方都可以找到。比如我们Ubuntu官方的wiki里就有：
http://wiki.ubuntu.org.cn/Template:10.04source。
软件源什么样？就是一大堆地址，类似这样：
[[./Images/image00285.jpeg]]

找到之后要换源很简单，打开/etc/apt/sources.list这个文件，把里面的东西清空，换上上面这一大坨就好了。软件源管理器做的其实也就是这样一个操作，新手还是用那个方便。像我这个懒蜗牛同学这样，非要自己动手改，结果，出问题了。他找到了一个看上去还不错的源，也知道要改哪个文件，于是，他动手了。他对命令似乎还挺熟悉，只见他运行了：
: emacs /etc/apt/soruce.list

*提示：*输入命令的终端位于“应用程序”|“附件”|“终端”。

这个命令的意思是叫gedit起床干活，打开/etc/apt/sources.list文件给用户看。于是我赶快去硬盘里叫醒gedit小弟。gedit是一个文本编辑器，比WindowsXP的记事本稍微强大点。gedit接到命令后赶快打开那个文件，显示给用户。用户把里面的东西统统一删，把找到的软件源的地址粘贴了进去，然后猛然发现，怎么那个“保存”按钮是灰的呢？gedit在那冷嘲热讽地念叨：“你以为你是谁呀？这可是重要的系统文件，你还想改？改坏了算谁的呀，你一个普通用户担待得起吗？”当然，这些都是他在工作间里自言自语，要真敢跟用户这么说话就等着被删吧。那么到底为什么不能保存呢？原因很简单------没有权限。

*提示：*/etc/apt/sources.list文件里可以写入多个软件源，但apt在下载软件的时候不会同时使用多个源来加快下载速度，而是优先使用写在前面的软件源，只有该软件源里没有找到要安装的软件时，才使用下一个软件源，依此类推。

*** 3.1.3　获取最高权限

“不对呀，你不是说安装系统的时候建的这个用户有超级用户的权力吗？”不好意思，您少记了3个字。我说的是，这个用户有“变身成”超级用户的权力。怎么变身？扭回头来吧，不用看窗外的月亮，只需要在要执行的命令前面加上“sudo”命令就可以了。sudo就是“以超级用户身份运行”的意思。用户直接运行gedit
/etc/apt/sources.list
，就是以普通用户身份打开sources.list文件，当然不能修改。应该运行：
: sudo emacs /ect/apt/source.list/

【变身技术指导】

这条命令的意思就是说：我要变身成超级用户并打开sources.list文件。但是不能您说变身我就让您变，您又不是变形金刚，这变身得讲条件。首先是核对一下身份，只有最初安装系统的时候创建的那个用户可以变身，装好之后再创建的其他用户就不行了（当然，最初的那个用户也可以把变身的能力赋予其他用户，这里说的只是默认情况）。确认了这个用户确实有变身的权利之后，还不算完，还需要让用户再输入一遍自己的密码。这样做，一来是防止恶意程序脚本骗取超级用户权限，再者也可以确认现在坐在电脑前的就是登录进来的用户。别回头老陈登录进来了，处理着半截照片上厕所去了。这时候来个修电脑的偷偷在老陈的电脑上以超级用户身份搞破坏，那就容易出事了。

*提示：*在命令行输入密码的时候没有任何回显，只要输入正确的密码并按回车键即可，千万不要怀疑自己的键盘过保修期了。

本以为我这位懒蜗牛同学会困惑好一会儿为什么不能保存，结果发现他好像不是不知道sudo，只是一时忘记了，发现gedit不能保存之后，马上就把gedit关了，在命令前加上了sudo重新来了一遍，这回OK了。看来这家伙是个老手，只是一时忘了而已。我开始庆幸我能遇上这么一个用户了。

【变身练习，更新软件列表】

软件源修改了之后，还不能马上生效，得先通知apt一声，让他去根据软件源更新软件列表。软件列表是什么意思？这个列表就是写明，现在所用的软件源里面都有什么软件，相互的依赖关系如何。这样当你要装软件的时候，apt直接查看这个列表就知道相关的软件信息。否则，万一哪个财迷用户让apt去装give\_me\_money软件，apt还得跑到网络上找软件源服务器问：“您这有一个叫give_me_money的软件吗？”人家肯定没好脸色地说：“我还想要呢！没有，回去！”然后apt再回来告诉用户，这样很耽误时间。所以，就要在每次换源之后，让apt去获取软件信息，把这些信息存在硬盘上。以后用户要是再想装什么不靠谱的软件，就可以直接让他死了这条心了。那么怎么更新软件列表呢？很简单，还是需要变身的命令：
: sudo apt-get update
*提示：*成功运行一次sudo指令后，五分钟内再运行sudo指令不必输入密码。

好了，现在软件源也改了，列表也更新了。这回，懒蜗牛同学再打开那个Language
Support，提示安装的时候单击Install按钮------这回不用等到春节了，只需要十几分钟的时间就可以下载完了（具体时间长短还要看网络带宽）。

*提示：*以后每次对/etc/apt/sources.list文件做了修改之后都要运行sudo apt-get update来更新软件列表。

另外，设置好软件源之后，再装别的软件就方便多了，想装什么软件只要运行：
: sudo apt-get install <package>

就可以了，apt会搞定剩下的事情。软件包名多数情况下就是软件的名称，不过也可能会有些出入，如果你想知道软件源里有没有你想要的软件，具体的软件包名称是什么，那么可以运行：
: sudo apt-cache search <package>

这样就会列出所有相关的软件包了，这都是apt更新了软件列表的结果。

*提示：*除sudo命令外，还可以使用su命令来实现在命令行中提高权限。su命令用于临时切换至任意用户------包括root，但需要该用户的密码。例如运行：
: su user1 # 切换用户.

则可以临时切换至user1用户，并拥有user1用户的权限。但运行此命令后需要输入user1用户的密码。而Ubuntu系统默认的root密码未知，因此，需要配合sudo命令来运行su，才可以切换至root权限。运行如下命令：
: sudo su root

如此，则相当于以root用户身份（sudo提高权限的结果）运行“su root”，即要求切换至root自身。因此su命令不要求输入密码，直接切换至root用户。

*** 3.1.4　为apt设置好网络

当然，刚才所说的这一切的前提是，你要把网络配置好。能上网，才能发挥apt的能力。我所在的这台电脑因为是用那种家用的宽带路由器，什么IP地址、DNS、路由等，都是由路由器的DHCP服务自动分配的，所以在我这里不需要设置什么，把网线插上就能上网了。如果不是这样的怎么办呢？咱们分情况慢慢说。

【手动设置网络参数的有线连接】

有的地方没有DHCP{Dynamic Host Configuration Protocol}，需要自己手动设置网络参数，也就是IP地址、DNS之类的。这个好办，你在Windows7下怎么设置的来着？找网络连接是不是？那我这里还找这个就对了。

（1）单击界面上的System（系统）|Perferences（首选项）|Network Connections（网络连接）打开网络连接界面，如图3.7所示。

[[./Images/image00293.jpeg]]

图3.7　网络连接

（2）打开网络连接界面之后，选择Wired（有线）标签（默认应该打开就是），下面的列表框里列出了所有的有线网卡，需要设置哪个，单击它选中，然后单击右面的Edit（编辑）按钮就好了。

（3）点开之后就可以设置MAC地址，IPv4的地址，甚至IPv6的地址。IPv6用得还不广泛，咱就光说这IPv4吧。选择IPv4标签，出现图3.8所示的界面，在Method（方法）下拉列表框里，选择Manual（手动），就是手动配置IP参数的意思（原来可能是Automatic（自动），如果有DHCP就选这个）。

[[./Images/image00294.jpeg]]

图3.8　设置IPv4参数

（4）选择手动后，下面的Addresses（地址）列表框就有效了。单击右边的Add（添加）按钮，然后在Addresses列表框里写上IP地址，子网掩码，网关。

（5）最后，再在下面的DNSserver文本框里填上DNS的IP地址，就好了。什么？你问我具体应该什么？跟Windows7下一样！

【ADSL拨号】

ADSL这种拨号上网的方式是目前比较常见的，在我们Ubuntu系统里设置起来也比较方便。

（1）还是打开网络连接，切换到DSL标签。

（2）单击Add按钮，出现图3.9所示的界面。

[[./Images/image00295.jpeg]]

图3.9　设置ADSL拨号

（3）在Connectionname文本框里写入这个连接的名字。随便起一个就行，反正是给你们人类看的，我们操作系统不关心这个名字。

（4）如果希望在需要上网的时候自动连接到网络，就选中Connectautomatically（自动连接）复选框。

（5）在Username（用户名）文本框中写上用户名，在Password（密码）文本框中写上密码（当然是ADSL的用户名、密码，可别写你系统的用户名、密码），Service文本框空着就好。都写好之后单击右下角的Apply（应用）按钮。

（6）创建好以后，单击系统托盘上的网络连接图标（就是两个箭头那个），就可以在弹出的菜单里看到刚刚创建的ADSL连接了，如图3.10所示。单击菜单上的连接名，就可以连接到互联网了。

[[./Images/image00296.jpeg]]
图3.10　连接ADSL

【WIFI设置】

WIFI现在也很普及了，如果电脑有无线网卡，直接单击系统托盘上的网络连接图标，就会显示出可连接的无线网络，选择一个单击一下就连上了，是不是很简单（当然，如果有密码还会让你输入密码）？

好，说了这么多，这会儿那个中文支持包也该安装完了，下一步还要设置点什么呢？

** 3.2　狐狸妹妹Firefox

很快，中文支持装好了。懒蜗牛同学注销并重新登录了一下，总算看到了熟悉的文字。不过，这只是万里长征走完了第一步，还有很多的地方需要配置呢，比如浏览器就是其中之一。

*** 3.2.1　安装Flash插件

从开始安装到配置好中文，已经过了很长时间，懒蜗牛同学喝口水，喘口气，忽然想起一件至关重要的事情------该收菜了！于是他再次叫醒狐狸妹妹Firefox，向着他的菜地出发了。来到他的菜地放眼一望......咦？怎么什么也没有，一片空白啊？就算这菜被人偷光了，难道这地也让开发商征用了不成？再仔细抬眼一看，哦，原来狐狸妹妹已经做了解释，如图3.11所示。

【让Firefox自动安装Flash插件】

问题其实很简单，就是没装Flash插件而已，那就装上吧。狐狸妹妹很贴心地在提示缺少插件的同时，提供了一个“安装缺失插件（I）”按钮，就是图3.11右侧的那个。懒蜗牛同学单击了这个按钮，之后狐狸妹妹就跑到网上去找插件了。

狐狸妹妹安装插件跟apt安装软件有点类似，都不需要您手动去下载，都是他们自己去网上找来装。但是狐狸妹妹的插件只在指定的官网上有，只此一家，别无分号，所以也不用专门为她设置什么软件源了。如果顺利，狐狸会在一阵搜索之后，找到适合的插件，并且自动开始安装，安装好之后，只要把狐狸妹妹重启一下，就可以看到效果了。

然而事情并不总是这么顺利的，比如这回，狐狸妹妹上网搜索了一遍之后向用户报告：“我搜了，可是呢......没找到，您自己看着办吧。”这件事情也得原谅狐狸妹妹，毕竟人家不是专业装软件的，所以装插件的时候难免有这样的时候。不过没关系，狐狸自动安装没成功，咱还有别的办法。

【用Discovery安装Flash插件】

Flash插件也是个软件，既然是软件，那就找apt来装。我这位懒蜗牛同学也非常明白这个道理，于是他单击了“系统”|“系统管理”|“Discovery软件包管理器”------等等，不是说要找apt么，这个Discovery又是个什么东西？

apt确实很牛，干活没得说，但他是个命令行界面的软件，只能够通过文字跟用户交流。可是由于人类越来越懒，键盘能少敲一下就少敲一下，因此很多人并不喜欢跟字符界面的软件打交道，这时候，就该Discovery出场了。Discovery就是apt的图形界面前端，用户通过喜欢的图形界面，把自己的意图告诉Discovery，再由Discovery转达给apt。这两个家伙配合得很是默契，以至于很多人觉得，Discovery就是apt。

用户运行了Discovery，由于Discovery是用来给系统安装软件的，需要变身成超级用户才可以操作，因此Discovery马上要求用户输入他的密码，核对身份，核对通过之后，才显示出Discovery的界面，如图3.12所示。

[[./Images/image00298.jpeg]]

图3.12　Discovery界面

在Discovery的界面上装软件很简单，就像逛超市一样。

左侧上方的列表框里列出了所有的软件分类，左侧下方的几个按钮是分类方式。选中一个分类后，右侧上方列表框中就会列出这个分类里的所有软件包。选中其中一个软件包，下面就会有这个软件包的介绍（不过是英文的）。不过更多的时候，用户是使用上方的“快速搜索”文本框来查找需要的软件并安装的。

[[./Images/image00227.jpeg]]*提示：*软件包分类后面带有universe的，表示社区维护的开源软件；后面带有restricted的是官方维护的非开源软件；带有multiverse的是非官方维护的非开源软件；其余的是官方维护的开源软件。

装软件的时候还会有一些依赖关系。所谓依赖关系，就是要装软件A，必须先装软件B；就像要想用牙膏，就必须先得有牙刷（否则，总不能用鞋刷子刷牙吧）。

好，我们的懒蜗牛同学要装Flash插件了，我们顺便按照他的操作步骤来学习一下怎么用Discovery安装软件。

（1）懒蜗牛同学先是在软件包分类列表框里选择了“全部”，然后在上面的“快速搜索”文本框里面输入“flash”，这就是说在全部软件包里查找关键词“flash”，于是很多跟Flash有关的软件包就列出来了，这时候他看到的就是图3.13所示的样子。

[[./Images/image00299.jpeg]]

图3.13　快速搜索软件包

（2）懒蜗牛同学看到其中有一项“flashplugin-nonfree”，单击了一下，下边出现了这个软件包的介绍。他看了看，觉得没错，就是图3.14所示这个介绍。

[[./Images/image00300.jpeg]]

图3.14　软件包详细信息

（3）他右击这个软件包，在弹出的快捷菜单里选择了“标记以便安装”。

（4）Discovery收到命令之后，赶紧叫起apt说：“牛哥牛哥，快起床，用户要装flashplugin-nonfree这个包啦。”apt查阅了一下自己记录的资料，告诉Discovery：“转告他，要装flashplugin-nonfree，就得同时装上flashplugin-installer、ia32-libs、lib32asound2、lib32bz2-1.0、lib32gcc1、lib32ncurses5、lib32stdc++6、lib32v4l-0、lib32z1、libc6-i386、nspluginwrapper这些软件包。”Discovery自然如实转告，就是图3.15所示这个界面。

[[./Images/image00301.jpeg]]

图3.15　依赖关系确认

（5）这位懒蜗牛同学倒是没有被这么多乱七八糟的包名吓倒，很淡定地单击了“标记”按钮。然后就开始安装了吗？没有，都说了Discovery装软件就跟推着推车在超市购物一样，现在不过是把要买的东西放进购物车了而已。

（6）懒蜗牛同学看到了图3.16所示的这样的状况，该装的软件打好了标记，于是就单击了Discovery界面上的“应用”按钮，这个按钮的意思就相当于结账。

[[./Images/image00302.jpeg]]

图3.16　单击应用开始安装

[[./Images/image00227.jpeg]]*提示：*由于软件源里其实没有64位的Flash插件，因此64位系统在安装Flash插件的时候会安装32位的Flash插件和nspluginwrapper，以及一些32位的库文件。原本64位的Firefox是无法使用32位插件的，但依靠nspluginwrapper可以使用32位的Flash插件。

经过一段时间的等待，apt装好了Flash插件，并由Discovery汇报给了用户。懒蜗牛同学迫不及待地牵着狐狸妹妹再次奔向了他的菜园。

【手动安装Flash插件】

软件源里的Flash插件只有32位的，即使您装的是64位系统，也只有32位的Flash插件可用。那么有没有办法安装上64位的Flash插件呢？有，那得手动安装，过程也不复杂。

（1）首先到这个地方下载与你的系统对应的插件：

[[./Images/image00303.jpeg]]

对于我这个64位的Linux系统来说，就是选择Download plug-in for Linux
64-bit。

（2）下载下来之后，是一个.tar.gz的文件，直接双击解压出来，其实里面有用的就一个文件------libflashplayer.so。

（3）把这个文件放到/usr/lib64/mozilla/plugins目录里，然后重启浏览器就可以了。

说起来容易，不过这个地方可不是随便一个用户就可以放文件的，得需要超级用户的权限才行。熟悉命令的同学可以在命令行里用：sudo
cp命令把文件复制过去，如果不会用cp命令，也没问题。按下Alt+F2键，在弹出的窗口中输入gksu
nautilus，如图3.17所示。

[[./Images/image00304.jpeg]]

图3.17　Alt+F2运行程序

按Alt+F2键弹出的这个窗口是运行程序的，想运行哪个程序，在文本框里面敲就行了。比如可以在里面敲firefox，然后单击“运行”按钮，就运行起狐狸妹妹来了。

[[./Images/image00227.jpeg]]*提示：*Linux系统中对大小写敏感，输入命令要确保大小写正确。如：应输入firefox而不是Firefox来启动火狐浏览器。

我们要运行的是gksu
nautilus，这个gksu和sudo具有一样的功能，让用户完成变身，只不过这是个图形界面的。nautilus就是我们这里默认的文件浏览器。这段命令的意思就是用root身份打开文件浏览器。单击“运行”按钮之后，会让你输入密码，就跟打开Discovery的时候一样。然后就可以看到文件管理器了，注意左上角这时候是图3.18所示这样了。

[[./Images/image00305.jpeg]]

图3.18　root身份打开的文件浏览器

这个文件浏览器的窗口就拥有root的权限了，在这里面找到那个刚刚解压出来的libflashplayer.so文件，复制到/usr/lib64/mozilla/plugins目录就可以了。复制完了记得关掉这个窗口，以免误操作。

*提示：*64位的Flash插件目前还在试验阶段，没有正式发布，因此可能会有各种未知问题。这也是软件源里为何不提供64位Flash插件的原因。

*** 3.2.2　设置中文字体

【Flash中的中文字体】

这回懒蜗牛同学来到菜地，一眼望去，果然看到绿油油的一片，庄稼长势喜人啊。咦？菜地里怎么这么多麻将牌呢？再一想，不对，哪有一地麻将牌的道理，仔细一看，哦，原来是所有中文都变成方块了。

懒蜗牛同学心里纳闷：我不是都装了中文了么，系统里的其他地方都变成中文了，怎么这里还是方块呢？百思不得其解的他，本着内事不明问老婆，外事不明问Google的基本方针，赶快让狐狸妹妹去Google了一下。原来，是Flash默认使用的字体不对，只要修改配置文件，换个字体就好了。

换字体不难，只要打开/etc/fonts/conf.d/49-sansserif.conf文件，当然要记得加sudo，因为是/etc/下的文件嘛，肯定只有root才有权限。然后把里面写明使用sans-serif和serif字体的地方，都换成wqy-zenhei字体，最后保存，就好了。改完了就类似下面这样（粗体为改动部分）：

[[./Images/image00306.jpeg]]

那么换上的这个wqy-zenhei是个什么字体呢？这就是在国内开源界大名鼎鼎的文泉驿正黑字体，这是一个可以免费使用而且效果还不错的字体。

【网页中的中文字体】

除了Flash，狐狸妹妹显示的网页中的字体也可以设置。这就更简单了，运行Firefox之后，选择“编辑”|“首选项”，在弹出的窗口里选择“内容”标签，如图3.19所示。

[[./Images/image00307.jpeg]]

图3.19　修改Firefox网页字体

在这个页面中间的“默认字体”下拉列表框里选择你想用的中文字体就可以了。不过也没多少可选，主要就是文泉驿那几种字体还不错。有人会觉得这样太单调了，就这么点字体可选。别着急，字体不多，咱可以装嘛。

【安装更多的中文字体】

字体也是软件的一部分，按说也可以用apt来装。不过，软件源毕竟不是中国人开的，里面基本没有更好的中文字体了，怎么办？

如果您装了Windows
7或者其他商业化的操作系统，他们肯定是带有不少中文字体的。可以直接把他们的字体拿过来用（前提是你的系统是正版的，你已经为那些字体付过费了，否则就是偷来用了），步骤也简单。

（1）Windows
7的字体一般放在C:\Windows\Fonts这个文件夹里，里面是一些.ttf或者.ttc的字体文件，把你想要的字体对应的文件复制到我们Ubuntu系统里面来，随便存在哪都可以。

（2）进入我们Ubuntu系统，双击刚刚复制过来的字体文件，就会出现如图3.20所示的窗口（话说我很怀疑设计这段程序的人练过气功）。

[[./Images/image00308.jpeg]]

图3.20　字体预览和安装

（3）左侧显示的是这个字体的效果（这里我们就用文泉驿字体做示例了），右侧是一些基本信息。确认这是你需要的字体后，单击右下角的“安装字体”按钮，字体就安装好了，简单吧。

总之，安装字体，就是先得到.ttf或者.ttc文件（从别的系统复制也好，网上下载的也行），再双击字体文件，单击“安装字体”按钮，就可以了。

*** 3.2.3　扩展阅读：文泉驿的诞生

看过了上面的故事，有的同学可能会发牢骚说：你们这个Ubuntu系统，怎么就不能多带点中文字体呢？怎么就只有那么个文泉驿？这个文泉驿又是什么来路？

好，各位要有兴趣，我说说，您听听，在想当初......

【忆往昔艰苦岁月】

很久很久以前（对你们人类来说其实也不算久啦，也就六七年以前），那时候的Linux日趋完善，不少国内的开源同行们，都来尝试安装各种各样的Linux。虽然硬件兼容的越来越多，应用程序的安装越来越便利，但炎黄子孙们安装了Linux之后无一例外地遇到了中文化的问题------没有一个合适的中文字体。

要知道，Linux是自由的，开源的，其中很多是免费的。那么自然不可能在免费的Linux中带有任何需要付费的字体。那么Linux上自带的免费字体是从哪来的呢？都是世界各地热心的爱好者们贡献的。爱好者们自己创作一套字体，然后无偿贡献出来，给大家使用。因此，有很多优秀的、免费的英文字体、法文字体、德文字体等。

可为什么其他国家有热心爱好者贡献字体，就没有热心的中国人贡献字体呢？是因为中国人懒吗？不是；是因为中国人自私？也不是；是因为中国人口少？你自己信么？答案很简单，因为中国字多！人家做一套英文字体，总共也就26个字母的大写加小写，外带10个数字和一些标点符号，加在一起不超过100个。一个人花一周时间就能做完了。汉字有多少？找本新华字典翻开前言看看------收录汉字一万个左右！而且除了“一”、“丁”、“乙”这样极个别的特例以外，是个汉字就比英文字母难写吧。要是让一个人把这一万个汉字都做成电脑中的字体，还不得累吐了血啊。就算是只做常用汉字也得有4000多个，这还不算繁体字和各种数字、标点。

那么那时候有没有中文字体呢？当然是有的，否则难道十年以前中国人都不用电脑？可是一般中文字体都是需要收费使用的------这个很合理吧，这么困难的东西，人家凑几个人费了挺大劲做出来了，人家也得穿衣吃饭，养家糊口嘛。就算有几个免费的中文字体，也有很多问题：丢字啊、难看啊之类的。所以那个时候，Linux的中文用户就只有忍受着质量差，总丢字的中文字体，或者把其他系统下的付费字体复制过来用。

【文泉驿横空出世】

直到2004年，中文字体的事情有了转机，带来转机的，是一位美国哈佛大学医学院的博士。

这位仁兄倒不是来发扬国际主义精神的，他之所以关注中文字体，是因为他本身是个中国人------房骞骞博士。不知道是不是因为他家房子被拆迁了，所以就去美国当博士去了（这都挨得着么......）。反正他在接触到Linux的时候，发现缺少中文字体是件很头疼的事情。他也知道要想自己做出一整套中文字体，那是一定要累吐血的。但是他还知道，积少成多，集腋成裘，积跬步成千里，积点水成江河......（此处略去类似成语、俗语若干）

他利用网络为平台，创建了“文泉驿”项目，目的是要创作出一套高质量的、免费的中文字体。他自己动手编码，设计了一个网站，简化设计字体的复杂程度，把汉字字体的绘制工作搬到了网页上。这让每一个热心的志愿者都可以按照网站上的指导，完成一个个汉字字体的绘制。就这样借助全球草根志愿者的力量，他开始了“万里长征”。经过数年的连续奋战，终于取得一项永留史册的硕果，这就是“文泉驿”汉字库，其中包括点阵和矢量字体。我们系统里的文泉驿正黑，就是其中之一。

目前，文泉驿项目依然在不断地完善，不断地创造新的字体。如果您有兴趣，可以去http://wenq.org/
画几个汉字，为开源的字体贡献一点点力量。画起来也不难，网页上的操作界面大约是图3.21所示的这个样子，稍微熟悉一下就可以上手了。

[[./Images/image00309.jpeg]]
图3.21　文泉驿字体设计界面

** 3.3　输入法
** 3.4　多媒体入门

聊天工具和输入法搞好了，用户终于和MM幸福地聊在了一起。俩人聊着聊着，聊到了音乐。最近MM在听一首歌，感觉很不错，就介绍给懒蜗牛同学。而他自然愿意主动贴近MM的生活，于是赶快上网下载这首歌曲来听。

看来，到了我们的多媒体部门出场的时候了。

*** 3.4.1　安装解码器

狐狸妹妹很麻利地下载到了这首歌，是一个扩展名是.mp3的文件。懒蜗牛同学很自然地就双击了这个文件，想要播放来听听。播放音乐这种事，自然要找多媒体部门，“电影播放机”就是其中的一员，他的英文名字叫Totem。

【播放音乐遇到的问题】

我看到用户要播放MP3，就赶快叫醒了Totem来干活。Totem一本正经地拿着这个文件翻来覆去地看了半天，最后摇摇头说：这个......播不了。我一听就急了：你不是播放机嘛？在学校里你天天吹牛说你什么都能播，视频音频通吃，怎么关键时刻不行了？Totem赶快解释：老大，别急别急，我说播不了，是有原因的。我播音频也好，视频也罢，都需要解码器。我现在手头没有这个MP3的解码器，所以不能播放。

有人会问：解码器是干什么的？要知道，音乐也好，视频也好，格式有很多种。就如同现实中看电影，有数字电影，就要用数字放映机；胶片电影，就得拿传统的放映机；在家里看光盘，就得拿DVD机；看录像带，就得拿录像机。听音乐也是，磁带的和CD的，肯定没法都塞进同一个机器里。Totem这样的媒体播放软件就像一个电影放映员，解码器就是放映机。放映员再牛，也得有各种放映机做支持，没放映机他啥也放不了。
# 比喻精彩，播放软件是放映员，解码器放映机．
*提示：*Ubuntu系统自带了一些格式的解码器，如OGG格式。但为避免版权问题而没有自带MP3，RMVB等解码器。

【安装MP3解码器】

我刚想质问Totem为什么不把解码器带全了，转念一想，我自己也没把语言支持包带全嘛。算了，还是不追究这个了，先说眼下怎么办吧。Totem说：没关系，没带就让apt去装嘛。当然，装软件这么重要的事情，我们得跟用户请示一下。于是，Totem在屏幕上显示出了一条信息，就是图3.35所示这条。大概意思是，您要播放的这个东西所需要的解码器似乎没有安装，请问要不要现在去搜索一下需要装的解码器呢？

[[./Images/image00327.jpeg]]

图3.35　提示查找插件

蜗牛同学还有什么选择吗？不听Totem的这MP3就播放不了啊，所以单击了“查找”按钮。Totem在一番查找后，向用户汇报，说有这么几个包得装，装上就能播MP3啦，如图3.36所示。

[[./Images/image00328.jpeg]]

图3.36　Totem搜索到的解码器

懒蜗牛同学当然单击了“安装”按钮。之后，估计您也猜到了，当然是apt开始工作，装上了需要的解码器，最终Totem终于发出了久违的歌曲声。

不过懒蜗牛同学显然和我一样对这个音乐不感兴趣，却对Totem有了很大兴趣。

*提示：*装好解码器后，将鼠标悬停在mp3文件上，几秒钟后可以预览文件内容。

【安装rmvb解码器】

以懒蜗牛同学以往的经验，系统刚刚装好，不能播放某音频或视频文件是正常的，比如以前的Windows
XP系统刚装好时，没有软件可以播放RMVB，必须得装软件，而装软件这个工作需要用户自己去做：上网找、下载，搞不好下载回来是个压缩包，还得先装解压缩软件。可是Totem竟然不用如此繁琐，直接提示缺什么东西，只要点个确定，该装的就都装上了，太人性化了。于是懒蜗牛同学很兴奋地又找来个RMVB文件双击了一下，Totem出乎意料地没有再向用户报告什么，立刻换过视频解码器，开始播放RMVB的视频。

其实，这是因为在刚才安装MP3解码器的时候装的那个gstream0.10-ffmpeg软件包，包含了多种解码功能，其中就有对RMVB文件的支持。

*** 3.4.2　安装Mplayer播放视频

虽然Totem能够播放不少类型的视频，不过毕竟他只是多媒体部门的小弟，要说播放器，那还得说Mplayer老爷子。Mplayer可是多媒体部门的元老了，能力相当强，什么片都能放，什么RMVB、FLV、AVI、WMV全都不在话下（当然，前提还是得有解码器）。就算您没图形界面，人家在字符界面照样能依靠framebuffer给你放电影，甚至还能给您拿字符拼出电影看。现在时代发展了，都高清了，人家也不甘落后，照样能支持，什么硬解码软解码的，通吃。

*提示：*如果需要Mplayer支持硬解码，首先要安装好显卡驱动，详见3.5节。

我们的懒蜗牛同学也在网上听说了Mplayer老先生的名声，于是叫来Discovery，安装上了Mplayer。装完了之后杯具了------这个软件装哪了啊？

【Linux和Windows不同的处世哲学】

这里要介绍一下我们Linux和Windows7的不同哲学了。我们两个的做事方式，对待用户的态度，以及很多观念都有很大的不同，因此导致了软件安装的位置也很有区别。

Windows7他们家族都比较小家子气，守住自己的一亩三分地不轻易让别人动。他不希望让别人了解自己的结构，所以Windows7下的系统文件都是统一放在一个目录里面的。一般叫什么Windows之类的目录，别的软件谁也别想动。有什么样的领导，自然就有什么样的员工。Windows7下的其他软件也都学他那样，给自己建一个目录，一般在ProgramFiles目录下，跟自己有关的东西就都放在那个目录里。软件之间泾渭分明，互不干涉，老死不相往来。顶多早晨上班见面点个头而已，很少有其他的交流，工作间里一片死气沉沉。

而我们Linux的世界就不同了。我们这里的目录是开放式的，按照文件的用途划分各种目录，而不是按照软件的名字来分。每个软件都把需要用的文件放在公共的地方，如果别的软件也需要用，甭客气，拿走。就比如刚才Totem装的那些解码器，其实就是一些解码用的库文件，所以放在了/usr/lib下。
# 总算见到了解码器的真实案例.
现在来了Mplayer，他要想播放视频也需要解码器，如果是在WindowsXP下，那就请您自备一套，甭想用我的。就像WindowsMediaPlayer不能播放RMVB格式，装了RealOne后，RealOne可以播放RMVB，但是WindowsMediaPlayer照样不能，因为RealOne带来的解码器只能RealOne用。我们这里就不是这样，既然有解码器了，就大家一起用。Mplayer抄起Totem刚才装的解码器就能播放视频，这样，避免了同样功能的解码器重复开发，也省得为某一种视频格式专门装个软件。

*提示：*由于软件之间相互共享资源的特点，Linux下的软件更倾向于做得功能单一而强大。每个软件只专注于实现一个功能，需要复杂功能时通过多个软件的相互协作完成。

【软件安装位置】

说了这么半天，您一定着急了：“这Mplayer到底装哪了啊？”对于这个问题，我只好告诉你：“就像一锅被火车撞了的豆腐脑一样散落在各处了......”二进制文件放在了/usr/bin；库文件放在了/usr/lib；配置文件放在了/etc/；其他一些文档文件放在了/usr/share；还有一些数据放在了/var，乱吧。你肯定会说，这么乱，怎么管理啊？要删除的时候怎么办？这个问题的答案是：相信apt！他会记得这些安装过的文件，删除的时候肯定一个不留。
# bin lib etc share(文档) /var存放数据, 此处都解释清楚了.
*提示：*删除软件使用命令：sudo apt-get
remove<软件包名>来完成。

如果你求知欲很强，非要知道这个Mplayer到底都装了哪些文件，那也没问题。在Discovery中搜到Mplayer这个软件包，右击这个包，选择“属性”，就弹出了属性窗口。这时候选择“已安装的文件”标签，就可以看到所有文件的去向了，如图3.37所示。

[[./Images/image00329.jpeg]]

图3.37　查看软件包所有文件

那么既然安装了Mplayer，到底怎么运行他呢？如果是安装了一个图形界面的程序，我会按照这个程序的类型，自动把这个程序放在“应用程序”菜单里。不过Mplayer是个字符终端的程序，所以没有在图形界面体现。要想运行，打开终端输入：

: Mplayer path

就可以运行了。这里，path\_to\_file就是你要播放的文件的存储路径，xxx.xxx就是你那个文件。这样运行了之后，就会看到Mplayer简洁的界面了，如图3.38所示。

[[./Images/image00331.jpeg]]
图3.38　Mplayer正在播放视频

不过这么运行当然有些麻烦，所以，懒蜗牛同学很快又叫来Discovery，安装了GnomeMplayer。这又是什么呢？这是个Mplayer的图形化前端，可以像Totem一样操作，而后台还是Mplayer在做实际的播放工作。除了GnomeMplayer，还有SMplayer、Kplayer等很多Mplayer的图形前端。这些player当中，要数SMplayer功能最多，使用最方便。

*** 3.4.3　播放音乐的Rhythmbox

虽说Mplayer和Totem音频视频都是可以播放的，但毕竟视频才是主业，要说听歌，还是得找专业人士，比如我这里的Rhythmbox就是个不错的音频播放器。

Rhythm是节奏，韵律的意思，所以我们就管Rhythmbox叫八音盒吧。八音盒可以播放各种音频文件（他也是依靠Totem装的那些解码器来播放的），还可以收听网络电台，还可以去UbuntuOne网络商店购买歌曲来收听，总之功能很强大。

*提示：*UbuntuOne是由Canonical公司所推出的一项网络服务。该服务能够存储你的文件，并允许你在多台电脑上同步，还可以与好友分享这些文件。

懒蜗牛同学经过摸索，终于在“应用程序”|“影音”菜单中找到了Rhythmbox音乐播放器，赶紧把他叫起来干活，找来刚才那个MM发过来的文件（没办法，系统里暂时没有别的音频文件），让八音盒播放试试。这对于八音盒自然不是难题，马上，工作间里就到处咩咩声不绝于耳。

*** 3.4.4　MP3乱码

懒蜗牛同学使用八音盒播放音乐，并没有遇到任何问题。这要感谢支持八音盒的开源软件贡献者们。因为在不是很久的前一两年，那时候的八音盒会有MP3乱码的问题。这是怎么回事呢？

【乱码之源】

话说一个MP3的歌名、作者这些信息，是记录在MP3标签里面的。这个标签的记录方式有很多种，主要是这么几个标准：ID3v1、ID3v2n2.3、ID3v22.4、APEv2。这个ID3v1的标签支持ISO-8859-1编码，这是个国际通用的编码，但是很可惜，它是不支持中文的。

到ID3v22.3这个版本开始，增加了对UTF-16的支持，UTF-16也是一套国际通用的编码，其中就包含中、日、韩等各国的文字了。到ID3v22.4，更增加了对UTF-8的支持。UTF-8和UTF-16都是国际通用的一套编码，所不同的是UTF-8以字节为编码单元，而UTF-16以双字节为编码单元，这样就有大小端问题（也就是哪个字节先传输的问题，不知道的可以google一下）。因此总的来说，UTF-8相对更受欢迎一些。ID3v22.4支持UTF-8编码，可并没有说一定要用，只是可以用UTF-8，自然也可以用其他的编码。而APEv2标准就不同了，它规定了其编码必须统一为UTF-8编码。ISO-8859-1、UTF-8、UTF-16都是国际标准的编码。

但UTF-8、UTF-16的出现都是后来的事情了，一开始，是没有国际标准的中文编码的，那时候只有国标------国家标准，也就是我们常见的GB2312、GBK和GB18030。由于这些只是国家标准，所以开源软件的作者们（多数不是中国人）自然是忽略这些标准（当然了，每个国家都有自己的标准，听谁的啊？）。所以，如果使用ID3v1或者ID3v2类型，并且使用国家标准编码的MP3文件，就会出现乱码。如果是ID3v1或ID3v2类型，但是使用UTF-8或者UTF-16编码的，就不会出现乱码。如果是使用APEv2标准的MP3文件，就更不会出现乱码了，因为APEv2必须用UTF-8嘛（估计您已经听得满脑子乱码了吧）。不过遗憾的是很多播放软件不支持APEv2标准，好在我们的八音盒是支持的。

【解决乱码】

现在，我们Ubuntu系统的用户们是幸运的，基本不会遇到MP3乱码问题了。但是也不排除个别用户由于某种特殊需求，需要安装比较老的Ubuntu系统，那就会碰到MP3的乱码问题了。怎么解决呢？

经过前面的介绍我们知道了，MP3之所以会出现乱码，就是因为编码不对，播放器不支持。那只要转换一下就好了。有个软件，叫做mid3iconv，他就认识各种编码，让他把MP3的编码改成UTF-8的，就可以了。这个软件从哪里来？自然是让apt请来：
: sudo apt install python-mutgen

或者让Discovery安装也一样。装完了以后，就可以在你的家目录下运行：
: find . -iname "*.mp3" -execdir mid3iconv -e gbk {} \;

这样你的家目录下所有的MP3就都改过来了。

有人说，为什么WindowsXP那里的播放器就没这么多问题呢？人家毕竟是商业化的产品嘛，而且是专门的“中文版”，自然得入乡随俗地支持国家标准编码。Windows
XP下的播放器默认有个叫WMP的，WMP支持的MP3标签类型其实也不多，他不能支持ID3v22.4和APEv2的标签，还不如我们的八音盒支持的多。但是他很聪明，不支持的标签我就不显示，以显示那个MP3文件的文件名来代替，免得出现乱码，这一点倒是值得我们的软件们学习。

*提示：*这样转换后的MP3文件放到Windows环境下可能会出现乱码，因此不建议使用此方法更改MP3标签。推荐使用较新版本的、无乱码的播放器。

*** 3.4.5　扩展阅读：开源和闭源

咱们说了Windows7是个闭源的系统，而我是开源的系统。那么什么是闭源，什么又是开源呢？

闭源就是源代码不开放。我们知道，程序是程序员们一行一行地语句编出来的，C语言也好，Java也好，这一行一行的语句，就是这个程序的源代码。有了源代码，就能够百分之百地了解整个程序的构造，如何工作。而源代码是不能运行的，必须要把源代码变成可执行的二进制程序，这个过程叫做编译。源代码经过编译之后，才可以运行，但是编译之后的程序就不能够知道内部的构造了。我们平时在网上下.载的各种程序，都是编译好的二进制程序，如果你想要它的源代码，对不起，不行！这是商业秘密，怎么能给你？给了你，我们的软件怎么卖钱？这种不开放源代码的程序，就叫闭源程序。

打个比方，就好像肯德基。香辣鸡翅谁都可以得到，只要花钱买就行，但是配方没人知道（虽然其实也没多好吃）。配方就相当于源代码，香辣鸡翅就相当于编译好的二进制程序，制作过程就相当于编译过程。如果有了配方（源代码），你就可以自己做香辣鸡翅（自己用源代码编译出二进制程序），甚至还可以根据口味对配方进行修改（根据自己的需求修改源程序，为软件增加自己需要的功能）。总结一下，画成图3.39所示这样，大概就好理解了。

[[./Images/image00334.jpeg]]

图3.39　源码与目标程序的关系

那么开源又是什么？开源是一种精神，是乐于分享的理念。开源的程序就是你在获得程序的二进制文件的同时，还可以索取对应的源代码，从而学习这个程序的编写，或者完善这个程序，为这个程序添加功能。所有的一切都是对你开放的，而你要做的，就是如果你修改了这个程序，也同样要对别人开放。

再举个例子，有一天你发现，蒸鸡蛋羹的时候往里面加点牛奶，可以让鸡蛋羹更滑嫩。知道了这个窍门，你很高兴地把它告诉你的朋友，让他们分享你的经验，于是大家很高兴地也学会了做这样的鸡蛋羹。这就是开源。当然你也可能不把它告诉别人，而是保留这个秘密，甚至申请个专利，然后开个店去卖京城独一份的奶香滑嫩鸡蛋羹，这就是闭源。当然，这之中没有谁对谁错，谁好谁坏，只是理念不同而已。

** 3.5　安全软件

常用的软件配置得差不多了，懒蜗牛同学根据使用Windows7系统的经验，是该考虑系统的安全性的时候了。

*** 3.5.1　杀毒软件

对于杀毒软件，我只想说一句话：我们Ubuntu系统真的没必要装杀毒软件。

*** 3.5.2　防火墙软件

虽然作为一个桌面版的Ubuntu系统，被别人攻击的概率也不是很高，不过本着安全第一的原则，我们的懒蜗牛同学还是想要配置一下防火墙。

我们Ubuntu系统想用户之所想，急用户之所急，本着一切为人类服务的原则......嗯，好吧，自吹自擂的话就不说了，简单地说，我们自带了防火墙软件------ufw。

【不复杂的ufw】

ufw就是UncomplicatedFirewall的缩写，直接翻译过来就是不复杂防火墙。虽然是个命令行的软件，但使用起来确实不复杂。

（1）启动防火墙

系统默认情况下是不启用防火墙的，如果想要启用，只要运行以下命令：
: sudo ufw enable

这样防火墙就启动了，并且以后每次启动系统时，都会随系统启动。

（2）默认配置

光启动了还不行，防火墙都不知道该防点什么呢。这防火墙总得配置一下吧？当然，我们Ubuntu系统想用户之所想，急用户之所急，本着......长话短说，对于一般的桌面用户，只要运行以下命令使用默认配置就可以了。
: sudo ufw default deny

这样，防火墙会默认拒绝外部对本机的访问，允许本机对外部的任何请求。

（3）关闭防火墙

啥时候不想用防火墙了，运行这个命令：
: sudo ufw disable

这样防火墙就关闭了。和开启时一样，这个动作也会导致下次启动系统时防火墙依然不启动。

（4）查看状态

如果你忘了现在防火墙是开是关，就运行这个命令查看：
: sudo ufw status

这个就没什么可解释的了。

（5）开启/关闭指定端口

如果想对某个端口进行单独操作，比如想开启本机的80端口让别人访问，可以运行
: sudo ufw allow 80

同理，如果要关闭外界对这个端口的访问，则运行：
: sudo ufw delete allow 80
（6）针对指定IP制定规则

如果看某个IP顺眼，想特殊照顾一下，允许那个IP访问本机，那么就这样：
: sudo ufw allow from 192.168.1.1

这个意思就是允许192.168.1.1对本机的访问。

【更加不复杂的gufw】

上面说的仅仅是一些最基本的使用方法。如果你觉得这样用起来还不方便，没关系，我们Ubuntu系统想用户之所想，急用户......算了，再废话用户真该跟我急了。我们还有个软件，叫做gufw，看名字就能猜出来，他是ufw的图形界面前端。默认系统中是没有的，需要叫apt来安装：
: sudo apt-get install gufw

安装好之后运行gufw命令来启动这个软件，您就会看到图3.40所示的简单的界面。在这个界面上，可以简单地启动/停用防火墙、查看防火墙状态、添加规则等。功能和ufw是一样的。

[[./Images/image00343.jpeg]]

图3.40　gufw界面

*** 3.5.3　扩展阅读：为什么Linux不需要杀毒软件

好吧，我承认对于杀毒软件的陈述确实少了一点，大概不能够完全打消您心头的疑虑。好，那么我们就来说说，Linux到底为什么不需要杀毒软件。

【病毒是有针对性的】

首先我们来了解一下病毒。病毒是什么？其实简单说，病毒只是一个程序，一个坏坏的程序。既然是程序，就跟其他的正常程序一样，依赖于不同的平台。啥意思？就是说，给Windows7打工的，没法给我干活，给我干活的，也不理Windows
7那一套。我要是拎过一个Windows7那边的程序跟他说，快起床干活，他压根听不懂，闭上眼睛继续睡，语言不通啊。所以，病毒也一样，针对Windows7的病毒传染不了我，针对我们Linux的病毒也不可能传染Windows 7。

【针对Linux的病毒】

那有没有针对Linux的病毒呢？答案是有的。

第一个Linux病毒诞生于1996年，澳大利亚的一个叫VLAD的组织用汇编语言编写了Linux系统下的第一个病毒：Staog，不过这个病毒只是个试验品，只是证明一下Linux也会感染病毒。这个病毒会感染二进制文件，获取root权限，然后说：Look！我获取了root权限耶。炫耀完了也就算了，并不做任何破坏性的事情。后来也有了一些有破坏性的病毒，但是数量很少。经过科学家计算，一个不装任何杀毒软件或防火墙的桌面用Linux系统，在互联网上裸奔并中毒的几率，大约比一个人花两块钱买彩票中五百万后立刻被雷劈中的概率大那么一点点（这是哪门子科学家算的）。病毒少，是Linux不容易中毒的一个原因。可为什么病毒少呢？

【没前途的Linux病毒】

话说有一个邪恶的人，出于某种邪恶的目的，想编个Windows病毒。他买书学习Windows的知识，找熟悉Windows的高人前辈们学习。经过种种努力，编出了一个病毒，然后把这个病毒放在自己的网站上，只要是使用Windows系统和IE浏览器上网的人一登录这个网站，就必定中毒。放上去之后，他等着，看着有1000人来到了他的网站，看着其中900多个纯洁的WindowsXP系统感染了病毒（总有不用IE的，防护比较到位的Windows吧），他很有满足感，他觉得自己成为大牛了。

话说有另一个邪恶的人，出于某种邪恶的目的，他想编个Linux病毒。他买书学习Linux的知识------不过好像不太好找，好不容易找到基本也都是基础知识。找找高深的吧，还都是英文。好吧，英文的也看，对着字典慢慢研究。哦，对，还可以找找高人指导，不过......也不好找，找了半天找到一个高人，拜他为师吧。经过师父指点和自己的努力，他学到了很多Linux的知识。然后费尽心机编了一个Linux的病毒，把这个病毒放在自己的网站上，只要使用Linux系统，Firefox浏览器上网的人一登录这个网站，就必定中毒。放上去之后，他等着，看着有1000人来到了他的网站------998个人都是Windows系统......好吧，好歹还有俩用Linux的吧，可其中一个不用Firefox，而是用Opera。邪恶的家伙咬咬牙，忍！看最后一个------哈哈，这家伙是Linux+Firefox，只要登录准中毒。可是只见着人来了转转又走了，一点事没有，临走还顺手改了自己的主页，上面写着：“小子，跟我玩你还嫩点。------师父留。”

通过对比我们得出结论------写Linux病毒，没前途！

【开源的本质带来的安全】

除了以上所说的原因以外，Linux及周边软件的开源本质，也导致了病毒较少。

比如我，用户要装什么软件，都是叫apt去找。apt可不是四处瞎找，而是去Ubuntu官方的软件源里去找------因为这些软件是开源的，所以可以随意拿来，放在一起，做成软件源，供Ubuntu们统一下载。官方的东西，自然没有病毒了，哪个娘也不能害自个孩子不是？

Windows就不一样了，它上面的软件基本都是闭源的，要装，得自己上网搜，在某个网站搜到了，下载下来装。可这“某个网站”，就不知道靠不靠谱了。谁知道上面的软件有没有病毒呢？那么，微软的公司不能也开个官方的软件源，让大家都去他那下软件吗？当然不能了，都是闭源的软件，你拿来用都要给人家钱的（当然，也有免费的），拿来分发可能压根就是不允许的。

另一方面，Linux的开源导致了大家都可以对其进行完善，一旦发现漏洞，随便谁都可以去修复这个漏洞，只要他有能力。可Windows呢？发现了漏洞，也只能漏着，等着微软公司去修。人家要是不修（比如可能正赶上食堂伙食不好导致的工人罢工），谁也没辙。

** 3.6　硬件和驱动

到目前为止，懒蜗牛同学的Ubuntu体验还算愉快，这主要是由于我带的驱动多，这个电脑上的硬件我都可以比较顺利地驱动起来。有人问，什么是驱动？

*** 3.6.1　驱动------硬件的使用手册

电脑硬件，不像电视机电冰箱似的，买来插上就能用。硬件要想在计算机上工作，得需要会操作它的软件，这个软件，一般就是我们操作系统了。但我们操作系统，也不可能生来就会操作所有的硬件，就像你不是生来就会开飞机一样，得学、得考本、得移库、倒库、坡起、限制门。狐狸妹妹在旁边鄙视了我一下：“你见过飞机过限制门吗？！那是汽车。”反正，我们要想会操作一个硬件，也需要学习，这就需要驱动程序，任何硬件要想工作都是需要驱动程序的。

这时候可能有人会提出反对意见：“硬盘、光驱，这些也都是硬件，哪听说过要装驱动程序的？还有我的U盘、摄像头，也都是插上就能用，不用装驱动啊。”不用装驱动，不代表不需要驱动。硬盘光驱是最基本的存储设备，而且它们的驱动很简单，也统一。任何一家厂商生产的硬盘都是一样的用法，所以硬盘光驱的驱动就被集成在了BIOS和操作系统里面，不用额外安装。其他所谓不用装驱动的设备也一样，都是因为驱动集成在了系统里。比如Windows7家以前的Windows 98系统，就不认识U盘，需要装驱动才行。到WindowsXP这一代，就不用装了，集成了。到Windows 7这一代，就继承了更多的驱动。

*提示：*由于操作系统存储于硬盘，硬盘必须先于操作系统工作起来，导致BIOS必须拥有操作硬盘的能力，因此BIOS必须包含硬盘驱动。光驱也是同理。

驱动就像一本给操作系统看的使用手册，上面写明了如何操作这个硬件，写哪个寄存器就把数据发出去了，从哪个寄存器读就把数据读回来了，往哪个寄存器写个什么数据就自爆了等（这是什么硬件啊......）。就像买来电视机，里面的使用手册一样。
# 光驱是使用手册,书里的比喻实在是到位.
针对不同的操作系统，需要有不同版本的驱动程序。这个好理解吧，因为我们是完全不同的系统嘛。像Windows7/XP/98，他们都是微软公司的系统，用的驱动还不同呢。我们这根本就不是一个阵营的，那就更不一样了。我们和Windows7就像说着不同语言的不同国家的人。我们能看得懂的手册，Windows7看不懂，反过来也一样。你家电视机的说明书不也有中文版、英文版、韩文版、非洲土著语版吗。但是，并不是每个硬件厂家都给每个系统制作一份驱动，毕竟厂商人力财力有限。电视机也不是每台都有非洲土著语版的说明书嘛（压根就没有吧......）。

所以，一般硬件厂商会优先开发市场占有率最高的那个系统的驱动程序，哪个系统？目前来说，就是Windows7家族的系统了。我们Linux就经常遇到一些因为厂家不提供驱动而无法使用的硬件，很多人还抱怨我们无能，冤枉啊......

*** 3.6.2　安装受限驱动

其实现在我们Linux能够支持的硬件已经逐渐多起来，大多数主流的设备基本不用装驱动就可以使用了。一般像我们Ubuntu系统，装完了系统之后也就装装显卡驱动就可以了，没准连显卡驱动都不用装。

如果你的计算机上有什么硬件不能驱动起来，先看看能不能安装受限驱动。选择“系统”|“系统管理”|“硬件驱动”，打开之后就弹出如图3.41所示的窗口。

[[./Images/image00344.jpeg]]
图3.41　硬件驱动窗口

如果发现了可以驱动的硬件，就会在上方的列表框里显示出相应的驱动。如果想要安装，只要在上方列表框里选中相应驱动，并单击下面的“激活”按钮就可以了。

*提示：*“硬件驱动”中列出的是可以安装或已经安装的“受限驱动”，并不是所有的驱动都列在这里。所谓受限驱动，是指该驱动不开源，有版权，因此系统安装的时候并没有自动安装。

** 3.7　本章小结

咱们这回书中讲到，这个定居在硬盘里的兔子，慢慢找着工作的感觉了。也赶上这位懒蜗牛同学善于动手，把这个兔子配置得基本可用了。什么装软件的apt、上网用的浏览器、各种聊天的工具、看片听歌的解码器，当然也少不了硬件驱动的程序，这些都配置好了，这个兔子就基本能够满足懒蜗牛同学的日常使用要求了。

然而论兔子的本事，远不止这些许的功能；那懒蜗牛同学，也未必满足于如此简单的使用。毕竟后事如何，还看下回分解。
#+BEGIN_QUOTE
本章学到的:
1) 解码器是放映机
2) 驱动是用户手册或者说明书.
3) ufw设置.
#+END_QUOTE
* 第4章 装载Applience

经过了短暂的磨合，用户逐渐地熟悉了我这个Ubuntu操作系统，基本的上网、听音乐、看看视频之类的工作，都可以完成了。不过这自然还不算完，默认的外观，自带的软件，并不是每个人都用着顺手的。这不，懒蜗牛同学就开始着手把系统弄得更加个性化，更符合自己的习惯。

** 4.1　桌面

有道是人凭衣服马凭鞍，操作系统看外观。外观对于一个操作系统来说也是挺重要的，所以，最先被懒蜗牛同学改造的，就是图形界面的样子。
*** 4.1.1　默认桌面的配置

懒蜗牛同学看着我们默认的图形界面很不顺眼。为什么呢？因为窗口上的关闭、最大、最小化按钮竟然在左边，如图4.1所示。

[[./Images/image00345.jpeg]]

图4.1　默认的窗口布局

这导致每次懒蜗牛同学要关窗口的时候，鼠标都会划出一条很纠结的曲线------先向右上方去，发现按钮不在原来的位置之后又打轮拐向左上角来。听说我们这届的图形界面组那哥儿几个都是种苹果的出身，所以审美观点可能跟以往有些不同。不过没关系，我们Linux是为人类服务的，哪里看着不爽都可以改。

懒蜗牛同学上网学习了一下之后就开始动手了，过程并不复杂。

（1）首先启动命令行，并且运行gconf-editor，或者按下Alt+F2键，输入gconf-editor也可以。运行起来如图4.2所示。

[[./Images/image00346.jpeg]]

图4.2　gconf-editor界面

*提示：*gconf-editor是一个Gnome桌面环境的配置编辑器，有点像Windows系统中的注册表。不过Windows的注册表是用来管理整个系统的，而gconf-editor只管Gnome桌面环境相关的设置。

（2）懒蜗牛同学依次展开了左侧的apps|metacity|general文件夹，这时在右侧上方窗口显示出了相关的键值，就是类似图4.3这样（以后咱就简单地说xxx|xxx|xxx文件夹中的yyy键值了啊）。

[[./Images/image00347.jpeg]]

图4.3　选中条目查看信息

（3）双击右侧上方列表框里面的button\_layout键值，是个字符串类型的。把里面的内容改成这样：
: menu: minimize, maximize, close

改后就像图4.4所示这样，然后单击“确定”按钮，窗口上的按钮马上就回归到图4.5所示的风格了。

[[./Images/image00349.jpeg]]

图4.4　修改键值

[[./Images/image00350.jpeg]]

图4.5　修改后的窗口布局

除此之外gconf-editor还可以设置很多东西，下面介绍一些常用的吧。

　apps|nautilus|desktop目录中的computer_icon_visible键值，布尔型，用于控制是否在桌面上显示计算机。

　apps|nautilus|desktop目录中的trash\_icon\_visible键值，布尔型，用于控制是否在桌面上显示回收站。

　apps|nautilus|desktop目录中的volumes\_visible键值，布尔型，用于控制是否在桌面上显示已挂载的设备。

*提示：*gconf-editor的设置保存在～/.gconf/目录中，如果配置出现错误需要恢复默认设置，删除此目录即可。

窗口按钮顺手了之后，懒蜗牛同学又开始追求更加新奇的东西------3D桌面。

*** 4.1.2　扩展阅读：Xorg

本节在咱们说3D桌面时提到了Xorg，那么Xorg是个什么软件呢？

【Xorg是谁】

话说我们Linux系统里，系统跟图形界面是分开的。绘制图形界面的事情由专门的图形部门来负责。而图形部门的老大，就是Xorg。他会跟硬件打交道，会用显卡（当然，用显卡也得经过我），能在显示器上画东西，想画什么画什么，谁要想显示点东西给用户看，都得经过他。

【X协议】
# 协议=黑话
要想跟Xorg打交道，在显示器上显示出图形来，得懂他们图形部门的黑话------学名叫协议。他们说话使用一种叫做X的协议。一个程序通过X协议告诉Xorg要画什么，那么这个程序就是X-Client，而负责在屏幕上画的Xorg就是X-Server。反正要想显示图形，就得用这种黑话跟Xorg去说。每一个要显示图形的程序都得会这种黑话，比如狐狸妹妹（以下“狐狸妹妹”或“狐狸”特指Firefox），要显示东西，就说：“驼子碗，筛土的拋闪！”那意思可能就是说画一只猪。当然，这就是打比方，其实我可不懂他们的黑话（这一点不像Windows7，他本身兼职负责画图形）。

那么程序要画什么直接跟Xorg说就行了么？其实也行，比如Mplayer，他可以直接跟底层的X
Server交流，可那就像是在字符界面下看片了------没有窗口，图像没法移动，没法全屏，没法最小化。因为MPlayer只负责放片，像画窗口、移动窗口什么的这些事情他可不管。那谁来管呢？这时就需要一个窗口管理器。

【窗口管理器】

我们这里默认的窗口管理器叫做Metacity（就是Gnome下的默认窗口管理器）。程序要画什么东西其实是跟他说的，不直接跟Xorg说。比如Mplayer说：“画一只猪。”（当然是用X黑话）。于是Metacity转头告诉Xorg：“在某某位置画个方的窗口，在里面画一只猪。”过一会儿可能用户觉得Mplayer的窗口挡着他和MM聊天了（那是，猪哪有MM好看呀），就把Mplayer的窗口挪了挪，于是Metacity又对Xorg说：“把刚才那只猪和窗口往左移动3.2厘米。”这个过程Mplayer是不知道的，他只管专心地向Metacity描绘着影片中的一幅幅图像：“猪、走路的猪、跑动的猪、跌倒的猪、捆绑的猪、烤熟的猪......”

*提示：*如果安装了Compiz，则Gnome界面将使用Compiz作为窗口管理器。

** 4.2　浏览器

懒蜗牛同学安装了Compiz
Fusion，打开了3D特效，桌面看上去比以前好看了不少。接下来，懒蜗牛同学又开始挑选合适的网络相关的软件了。

*** 4.2.1　满身插件的狐狸妹妹
安装常用插件-略

*** 4.2.2　会分身的Chrome

懒蜗牛同学和狐狸妹妹又缠绵了一阵子，才终于想起来------哦，对了，我是想装Chrome的，明明是要换用自己顺手的浏览器，怎么差点被狐狸迷惑了。他赶紧找到下载的Chrome的deb包。由于懒蜗牛同学没有更改保存地址，狐狸妹妹就把下载的东西存在了懒蜗牛同学的家目录下的“下载”目录。

*提示：*所谓家目录，就是/home目录下以用户名命名的那个目录。比如lanwoniu用户的家目录就是/home/lanwoniu。每个用户只能在自己的这个家目录下进行操作，其他的目录没有权限。

*提示：*Linux中可以使用“～”符号代表家目录。例如，对于user1用户，运行ls～就相当于运行ls
/home/user1，而对于user2用户则相当于运行ls/home/user2。

懒蜗牛同学找到了deb文件，双击安装。不一会，apt就按照操作流程解开了这个deb包，从里面拎出一只浏览器。

【用多进程追求速度的极致】

这家伙长得色彩斑斓，红黄绿蓝四色相间，样子简简单单，倒也清爽。大家没来得及仔细看，这家伙就被apt带进硬盘里安排住处去了。狐狸妹妹有些不高兴地说：“哼，回头倒要看看他有什么本事。”是啊，这家伙来了自然就会抢狐狸的饭碗，难怪狐狸不高兴。

没过一会儿，Chrome就被懒蜗牛同学叫起来干活了。Chrome一跑进内存，一下子变成了4个Chrome！也就是分出4个进程。他们在工作间里窜来窜去，那叫一个热闹。4个Chrome分别忙着各自的工作，有的负责向图形界面申请窗口；有的负责在窗口上绘制各种标签和按钮；有的打开网口，访问默认的主页。虽然这么多进程挺闹腾，倒也是各司其职，有条不紊。而且这样一来，这些事情是同时进行的，效率就会高一些。很快，Chrome就为用户显示出了一个简洁的界面，如图4.20所示。

[[./Images/image00366.jpeg]]
图4.20　Chrome运行界面

*提示：*可以用ps --A命令来查看当前运行的进程。
#+BEGIN_SRC shell :results output
ps -ef |grep firefox
#+END_SRC

相比之下我们的狐狸妹妹就比较本分，一步一步进行。先向图形部门申请绘制窗口，窗口批下来之后再在窗口中绘制好各种文字、菜单、按钮之类的。这之后再根据用户设置的主页，上网申请数据，数据来了再显示给用户。如果有插件，在这之前还要加载各种插件，难怪有人觉得狐狸有点慢呢。

这还不算完，等到懒蜗牛同学真的开始使用Chrome浏览网页我才知道，原来这Chrome不只是4个，随着打开的网页越来越多，Chrome不断地复制自己，工作间里的Chrome进程也越来越多。好家伙，转眼间工作间里就看不见别人了，到处都是Chrome。不过好在他们每个占用的资源都不多，因此也不会给别人带来什么麻烦，这也算是Chrome这家伙的特色之一吧。

【争夺默认浏览器的地位】

Chrome来了以后，这工作间里面就开始不太平了。狐狸妹妹和他谁也不服谁，整天吵架。系统中可以有很多浏览器，但是默认的浏览器只有一个。原本默认浏览器当然是狐狸妹妹，可当Chrome启动的时候就显示出图4.21所示的这个界面来告诉用户：我不是默认浏览器，把我设成默认浏览器吧。

[[./Images/image00367.jpeg]]
图4.21　Chrome询问是否设置为默认浏览器

如果用户把Chrome设成默认浏览器，狐狸妹妹启动时也会向懒蜗牛同学抱怨：“以前我是默认的，干得好好的怎么就换了呢？您还是给我设回来吧。”也搭上我们的懒蜗牛同学没准主意，墙头草，随风倒。今天设狐狸为默认的，明天改Chrome是默认的。

*提示：*可以手动设置默认浏览器，单击“系统”|“首选项”|“首选应用程序”，选择Internet标签，如图4.22所示，在上方“Web浏览器”对应的下拉列表框中选择即可。

[[./Images/image00368.jpeg]]
图4.22　设置默认浏览器

不过最终懒蜗牛同学还是确定了狐狸妹妹的默认浏览器地位，毕竟是我的原班人马嘛。别的不说，由于狐狸是软件源里的软件，所以如果有个什么版本升级BUG修复之类的，都是自动的。那时apt（以下“apt”特指apt）会接到Canonical学校发来的通知：狐狸同志，工作一向兢兢业业，刻苦提高技术水平，今经组织决定，晋升狐狸为x.xx版本，建议进行升级。得到用户的同意之后，apt就去下载来新的部件，把我们机器里的狐狸按照学校提供的步骤改装成新的狐狸。

我带来的每一个软件和通过apt安装的软件都有这种待遇，而像Chrome这种从网站上下载来安装的软件就不行了，要想升级，只能再去网上下载新的版本，自己重新安装。

*提示：*软件源里有Chromium浏览器，算是Chrome的试验版。如果喜欢Chrome风格但又希望它能跟随系统进行更新，可以安装源里面的chromium-browser这个软件包。

所以Chrome们整天不服气，跟狐狸说：“你也就是因为有靠山，那"乌棒兔"内核跟你一伙的，所以才能容得你这么飞扬跋扈。”狐狸自然也不肯罢休：“你那样子又有什么好了，再说了，要变成你那样子简单得很。给我装上Chromifox
Basic主题，再装上Total Rechrome扩展倒置标签兰和地址栏，最后装个Hid
Menubar扩展隐藏掉菜单栏，跟你也没什么区别。只不过用户不愿把我打扮得像你那么难看罢了。”另一只Chrome反唇相讥：“哼，变成我们这样有什么用，装那么多插件扩展的，臃肿啊，哪像我们简洁高效。”狐狸怒道：“你想装这么多插件还没人给你开发呢！”

*提示：*目前最新版的Firefox默认界面已经逐渐向Chrome学习，不需要安装什么扩展也很精简。

*** 4.2.3　干净利索的Opera

后来，懒蜗牛同学又先后安装了很多浏览器，有极其简约的Uzbl，有轻巧的Epiphany，有简陋的dillo，甚至纯字符界面的lynx和links都装上了。他装这么多浏览器干啥？一块运行起来看热闹玩？当然不是，他是在体验，在选择，寻找最适合自己的那一款浏览器。

我们Linux世界里的软件总是多种多样的，同样功能的软件可能会有很多款，而且特色各异。每个人都可以找到适合自己的那一款。甚至如果没有哪款合你心意的，还可以通过修改某个浏览器的代码（因为多是开源的嘛），来创造出你自己喜欢的浏览器来。比如狐狸妹妹深受广大用户喜爱，然而就是干活速度有些慢，于是有人就在狐狸代码的基础上加以改进，出现了疯狐狸（MadFox）浏览器。这就是Linux的世界，在这个世界里，人类才是软件的主人。

*** 4.2.4　使用aria2下载
*** 4.2.5　扩展阅读：软件位宽

上面提到了，我是一个64位的操作系统。到底这个64位、32位说的是什么意思呢？

【运算位数的限制】

这个多少多少位，说的是CPU一次运算的二进制数字的位数。这个CPU就像是个计算器，我们软件用CPU就像人类用计算器似的。它很重要，我们要算一丁点东西，也需要用CPU来算（别跟我说用心算，我是软件，OK？）。

但是这个CPU算东西的能力，是有限制的，有什么限制呢？你拿出你家的计算器看看，算个28+783，没问题是吧。算个7836--473也没问题是吧，再算个72635446584939202937346537+1，能么？估计99％的同志出问题了（不排除有牛人拥有很牛的计算器）：“我哪能按出这么多数来啊，我这计算器总共就能显示得下11位数字”。对，这就是计算器的位数限制。

CPU也一样，一次能算的数不能无限大，总得有个边，只不过不是按照十进制的位数算的，而是按照二进制的位数算的。至于什么叫十进制，什么叫二进制，可以去问问狗狗大哥，不过不知道也没关系，咱暂时按照咱们平常的十进制来说。
# 好,google狗狗大哥
【软件操作CPU的过程】

我们软件使用CPU运算的过程和你们人类使用计算器是差不多的。比如说，我这有个计算器只能算99以内的数字，也就是只有2位（也不知道谁设计的这么弱智的计算器）。那么我用这个计算机算个3+4怎么算呢？简单，输入3，按+号，再输入4，按=号，就出来了。再算个大点的，算个56+47。先输入56，按+号，再输入47，按=号。咦？显示03，怎么不显示103呢？废话，它倒是想显示，往哪写那1呀？但是我用的这个计算器（也就是CPU啊）是很人性化的，会提示你运算结果超出了它的能力范围。比如可能会有个红灯亮起，提示你03前面还有一个进位，进到百位了。
# 解释得好.

【高位宽CPU的优势】

好了，基本的操作说完了，现在说正题，不同位数的区别。两位的CPU就像刚才说的那样，那么假设现在需要计算3173+644，这里有2位的CPU一个，4位的CPU一个，分别用他们做这个计算，有什么区别呢？

咱先看这2位的，有人说了，2位的只能算两位啊，这个没法算哪？唉，这机器是死的，咱软件是活的啊，一次只能算2位，咱不会分开多算几次么。首先，输入73，按+号，再输入44，按=号。显示出来17，同时红灯一亮，说明还得进位。好，找张纸记下17这个数，还得写上“得进位”。然后再输入31，按+号，输入6，按=号，显示出来37。别忙，没完，刚才还得进位么不是，再输入37，按+号，输入1，按钮，咔嚓，出来38。好，最后结果拼一块，高位是38，低位是17，最后结果：3817。

再拿这4位的算算看。4位的就意味着输入的和显示的数最大可以是9999，也就是说我直接就可以输入3173，按+号，再输入644，按=号，显示出来3817，OK，收工。

*提示：*目前市场上常见的CPU都已经是64位CPU。

【软件位宽与CPU位宽的关系】

这就是2位的CPU和4位的CPU的不同，从理论上来说，4位的要比2位的快，从上面的例子看得很明显嘛，大一点的数，4位的CPU一下就能算完，2位的CPU要折腾好几次。但是这4位的CPU还得有人会用才行，这就需要4位的软件来用这个4位的CPU。

终于说到软件的位数了，CPU的位数就是一次能计算多少位的数，那软件的位数呢？就是说明这个软件需要使用多少位的CPU。软件干活肯定需要计算，计算就得用CPU，2位的软件会用2位的CPU，4位的软件就会用4位的CPU（还是拿十进制位做比喻啊）。比如有一个2位的软件，当他运行在一个2位CPU的电脑上的时候就是这样：比如要算3173+644，他就会先算73+44，然后记住进位，然后计算31+6，然后加上进位，最后拼起来，得到答案，就像上面描述的那样。那么当这个2位的软件运行在一个4位的CPU上的时候会怎么样呢？他会先算73+44，然后记住进位，然后计算31+6，然后加上进位，最后拼起来，得到答案......有人说了，他怎么不直接算啊？4位的CPU不是能直接就算出来么？但是别忘了他是2位的软件啊，他不会用4位的CPU，但是不会用不等于完全不能用，他还是可以拿4位的CPU当成2位的来用，只是有些浪费而已。

*提示：*64位Ubuntu系统中自带的软件，以及通过软件源安装的软件，除某些不开源的软件外，都是64位的。

那么要想完全发挥4位CPU的性能该怎么办呢？当然就得4位的软件出场了。当一个4位的软件运行在一个4位的CPU上时怎么计算3173+644呢？大家大概都知道了，直接算，一次完成。那么当一个4位的软件运行在一个2位的CPU上时会怎么样呢？这个软件会写个3173的纸条要往CPU的寄存器里塞，急得满头大汗就是塞不进去，最后一甩手------老子不干了，这破CPU没法用！当然，这只是个比喻，并不是说4位软件在2位CPU上算3173+644就算不了，算1+1就能算。4位的软件是根本无法运行在2位的CPU上的。

*** 4.2.6　扩展阅读：进程

咱说Chrome是个多进程的浏览器，一运行就复制出好多进程来。有人可能对进程这个名字还不是很明白，什么是进程呢？

【进程的概念】

简单地说，进程就是正在干活的软件。比如狐狸妹妹，躺在硬盘里睡觉的时候她就是一个软件、一堆数据、一坨代码。当她被叫醒，跑进内存里开始干活的时候，她就是一个进程了（当然，其实这么说不很准确，但可以姑且这么理解）。换句话说，内存里忙忙碌碌的，都是一个个的进程。当然，同时他们都是程序、都是软件，这不冲突。

就像去公司上班的人，他们都是人，当他们在公司工作的时候，他们都是公司的员工。员工，就像进程一样。很多公司的员工每个人都有个工号，什么NB001，SB999之类的；每个进程也都有一个唯一的标识------进程ID号，简称PID。这个ID号是由我分配给每一个跑进工作间的进程的，分配的规则很简单，每人一个，每次加一。第一个跑进来的就是1号，在我们Linux系统里，有个叫init的家伙每次都是第一个被我叫起来，帮我打理一下日常工作，所以他的ID号总是1。而且，他还有个特殊身份，这个咱暂时保密，待会儿再说。
# 宇宙大爆炸的七点.
*提示：*init一般位于/sbin/目录下，内核启动后会首先调用此程序，进行一些初始化工作。
#+BEGIN_SRC shell :results output
ls /sbin/ |grep init
#+END_SRC

#+RESULTS:
: init
: mkinitramfs
: telinit
: update-initramfs

【管上级叫爹】

每个公司的员工都有个直属的上级，上级又有上级，依此类推。我们这里的进程也是这样的，只不过我们不叫“上级”或者“上司”，我们叫------爹！好吧，似乎这个称谓土了点，但是就是这个意思。一个进程之所以成为一个进程，一定是由于另一个进程创建了他（有点绕嘴吧）。比如说用户开了一个终端，于是就有了一个bash进程，然后用户在这个终端里敲入firefox并回车，bash就去找狐狸妹妹，把她带到内存里开始工作，于是就创建了一个firefox进程。好了，现在，firefox这个进程是由bash这个进程创建的，那么，bash这个进程就是firefox这个进程的父进程，firefox进程就是bash进程的子进程。也就是说，狐狸妹妹就得管bash叫爹！那bash也得有个“爹”吧？是的，如果是在Gnome环境下开的那个终端，那么bash他爹就是调用bash的gnome-terminal。

既然每个进程都有爹，爹进程又有爹，如此循环往复，肯定有一个站在金字塔最高点的总“爹”吧？难道，难道"乌棒兔"你就是他们的总爹？很遗憾，我不是，所有进程的总爹，是每次启动第一个被我叫起来的init。所有的进程都是被init直接或者间接创建的，所以init才是所有进程的祖宗！

关于父进程，有两点要说明。

第一，我们这的父子关系不是固定的，是会变换的。如果从bash启动Firefox那么bash就是Firefox的爹，如果直接从图形界面启动那就没bash什么事情了（这时候Firefox的爹其实是init）。

第二，不要问我哪里有妈进程！

*提示：*父进程的说法源自英文parent process。

【当爹的义务】

当爹也有当爹的义务，人家不能白叫你一声爹是不是。当自己的娃（也就是子进程啦）做完自己该做的工作以后，就停止了一切动作，像个死尸一样待在那里，当爹的就负责给他“收尸”。

一个结束了所有工作的进程，会处于一种“僵尸”状态，这时候他什么也不做了，就等着被干掉。进程进入僵尸状态前一般会通知他爹一声，汇报一下说：爹啊，俺已经把该做的都做啦，现在我要变僵尸啦！（让后平伸双手开始行走？那是生化危机！）然后他爹负责向我汇报：我家娃干完活了，你把他的工号（就是PID，记得吧）取消掉然后让他回去睡觉吧。然后我就把它的工号收回，看看他有没有什么申请了没释放的资源（一般一个好孩子在结束运行成为僵尸之前，会主动释放掉自己申请的资源的）。确认都没问题了之后，他就被从我的进程列表中清除了。

*提示：*所谓进程申请的资源，包括进程申请过的内存、打开的文件、Socket连接等。

【当爹遇到意外】

但是有时候也会有些特殊情况，比如有的时候娃还在兢兢业业地干活呢，结果他爹死了（可能他爹干完活退出了，也可能被用户用命令kill了）。这个时候我就会发个信号给他家娃说：那个......娃呀，那啥，跟你说个事，你爹死了。

这时候有的娃就悲痛欲绝：俺爹都死了俺活着还有啥意思啊，呜呜呜......俺也僵尸吧。然后他就退出了。比如你在终端运行Firefox，然后把终端关了，Firefox也就退出了。

也有的娃比较坚强，一定要完成上级交给的任务，化悲痛为力量。这时候我会给他找个新爹------因为每个进程总得有个父进程，没爹是不行的。一般我会安排他爹的爹来当他的爹（又绕进去了吧），也就是这个进程原来的“爷爷”进程来当他的父进程。然后这娃在长了一辈后，继续认真工作。比如你在终端运行nohup
firefox，然后把终端关了，Firefox继续运行。那如果他爷爷不幸也挂了呢？那就继续往上找吧，我们说了init是所有进程的祖宗，所以他那里就成了最终的“无依靠青年进程收容所”。

如果init也挂了呢？那系统就挂了，重启吧！

*提示：*父进程退出时，系统会向子进程发送“挂断”信号（SIGHUP），子进程是否退出取决于子进程如何处理挂断信号。

【当爹和娃同时出意外】

还有的时候娃已经把该做的事情做完了，汇报给他爹并变成僵尸。可是他爹还没来得及给自己娃收尸，自己就先挂掉了，这个时候就有点麻烦了。

首先我没法通知那娃说她爹挂了，因为那娃已经是僵尸了，啥也不听啥也不干了。其次我也不能直接把他干掉，啥事情都得按规矩来嘛，只有他爹向我申请我才能把他干掉，可是他爹又已经挂了......那怎么办呢？那就按流程来，先给这个娃找个爹，哪怕这娃已经是僵尸了，也得有个爹。一般我会找到init说：那个ID号是2725的进程爹死了，你当他爹吧。一边说一边看也不看地用手往那边一指，假装自己没看到那娃已经成僵尸了。一般init也不会太注意，直接就答应了，然后马上发现了事情的真相，跑到我这里来说：那娃已经成了僵尸啦，你还叫我收养个啥？我肯定会一脸无辜状：啊？是啊，那不管怎样，你是他爹了，你负责处理一下后事吧。于是init只好以爹的身份处理那个僵尸的后事，问题就这样解决了。

** 4.3  影音

狐狸妹妹今天接到懒蜗牛同学的任务，要去下载一部叫做《Big Buck Bunny》的电影。说是电影，其实就是个短片，还不到10分钟。并且它还有个最大的特点------它是开源的。好，废话不多说，狐狸妹妹已经用她的Downthemall扩展把这个短片下载下来了，于是，就引出了一场播放器之间的斗争。

*提示：*所谓开源电影，是说它是在开源的平台上用开源的软件制作的，并且免费下载观看，还可以获得它的原始制作文件。
*** 4.3.4　扩展阅读：解码器与硬解码

本节提到了视频文件有编码，播放器要用解码器。这个视频文件都是有一定的编码方式的。比如大家都听说过MPEG吧，就是MovingPicture Experts
Group，动态图像专家组，听这名字本来是用来指代一小撮明白真相的群众的，不过后来这一小撮群众发布的标准被广泛使用，于是MPEG就成了指代这一小撮群众定义出的那一大撮标准的名词了。

【编码，从MPEG-1到MPEG-4】

MPEG-1是小撮群众在1992年定义出的一个标准，是一种视频和音频的编码方式。大家记得以前的VCD不？VCD光盘上的视频和音频用的就是MPEG-1这种编码标准。而MPEG-1标准中关于音频的部分------MPEG-1
Layer3，更是成为互联网上及大家口袋里最常见的音频标准------MP3。

后来，1994年，这一小撮明白真相的群众又发布了MPEG-2标准。MPEG-2向下兼容MPEG-1，并增加对隔行扫描的支持，被应用于有线电视，还有DVD的音频视频编码。

再后来，这一小撮群众又开发了MPEG-3，注意MPEG-3跟我们的MP3没有任何关系，而且，MPEG3最终没有得到很好的应用，因为当时人们发现MPEG-2足够了，MPEG-3并没有提供足够好的改进。

而1998发布的MPEG-4就不一样了，它可以让视频文件的体积更小，压缩率更高，因此得到了广泛的使用。现在市场上卖的MP4播放器，就是用来播放MPEG-4压缩的视频文件的设备。所以，MP4跟MPEG-4有关，而MP3跟MPEG-3无关。
.
【软件解码】

说了这么多，回过头来说说解码。

视频文件都进行了一定的编码，比如MPEG-2，或者MPEG-4。就是说这个视频文件里面的东西都是一大堆乱七八糟的数字，要想看这个视频文件，就得解码，也就是根据这一大堆数字算出应该显示的一帧一帧的图像，并且把这些图像连续播放起来，从而还原成视频。那么这个解码的过程就要靠Mplayer老先生了。

老先生有很多的解码器，也就是有很多的说明手册，上面写了每种编码格式的文件应该怎么计算，怎么解码。那么以前没有硬件解码的时候，Mplayer老先生是怎么做的呢？首先，拿到一个视频文件，然后看看是什么编码的，对着自己的手册，开始解码。解码的过程就是计算的过程，计算需要用什么？那位同学回答了，得用CPU啊。于是Mplayer一手拿着手册，一手拎着数据找到我，请求使用CPU（我是操作系统嘛，软件要用CPU得跟我申请）。我说，好的，你就排在GIMP的后面，等他用完了你用。过一会儿GIMP用完了CPU，Mplayer过去开始拿CPU按照手册上写的算法算他那堆数据。最后算出来，得到了几张图片，就转身把图片给图形部门，让他们去显示。然后再从那个视频文件里拿一些数据，再来排队等着用CPU。

由于视频文件的计算量都很大，尤其是高清视频尤其大，因此为了保证蜗牛看的电影不变成带旁白的幻灯片，我就要尽可能地让Mplayer多用CPU，来保证他能顺利地解码。于是，每次Mplayer一播高清视频，CPU就总被他占着，搞得别的程序都抱怨。

【硬件解码】

如果他终于学会硬解码了，情况就好多了。当然，光他学会硬解码也不行，关键是显卡也得支持，而且驱动还得装好才行，不过这些咱现在不讨论，先说Mplayer。

会了硬解码之后怎么样呢？在播放视频的时候一手拿着手册，一手拎着数据找到我，跟我说要用用显卡。可不是CPU了啊，改用显卡了。于是我就很乐意地让他去用了，反正别人也用不着，让他自个玩去吧。于是他就去用显卡算去了。用显卡算和用CPU算不一样，CPU虽然强大，虽然啥都能算，但是要自己手动算。就是说自己要知道算法（对于Mplayer来说，算法都在解码器上写着呢），比如要算出一帧的视频来，要先用第1个数加上第2个数，再用结果乘以第3个数之类的。这里加啊，乘啊，都是用CPU算的，但是中间的过程是要软件（也就是Mplayer）自己控制的。可是用显卡解码就不一样了，人家那东西是专门解视频的啊，所以你只要把数据放在里面，直接就能给你算出一帧帧的画面来。全自动啊！于是Mplayer不但不用跟别的软件抢CPU了，而且解码的速度还快了不少。

*提示：*显卡上的GPU在计算并行计算方面比CPU更加强大，因此硬解码可以获得更快的速度。
# 原来如此.

** 4.4　图像

今天一起床就接到了一个任务，听起来还挺轻松，一般胡同里大妈大婶的，经常做这项工作，并且乐此不疲，那就是------串门。不过我去串门可不是聊天去的，我是去做搬运工，要把一些图片复制到我们Ubuntu系统的硬盘里。估计懒蜗牛同学是想处理照片了，这回，图像处理部的那几个软件有事干了。

*** 4.4.1　GIMP
*** 4.4.2　扩展阅读：磁盘碎片的产生

前面我们说到了Windows7那里有磁盘碎片。什么是磁盘碎片呢？它是怎么产生的？下面我就给大家讲讲这个磁盘碎片。

【Windows 7管理硬盘的方式】

同学们都坐好，都把手机铃声关了，小灵通调成震动，BP机直接扔了------台都没了你还留着它干嘛。好，上课了，首先说说什么叫磁盘碎片。

磁盘，是我们程序居住的空间，我们用不同的方式对整个磁盘的空间进行管理。前面说过，包括各种方式，什么ext4、xfs、ntfs等。而磁盘里放的东西，就是一个一个的文件，同学们可以把磁盘想象成你家的屋子，文件就像一个个大大小小的箱子。每个箱子上面写着字，就是文件名。Windows7喜欢把每个箱子都紧挨着放，一个挨一个，上下左右前前后后都紧贴着。这样，看上去很规整，可以让剩余的空闲空间比较完整。有同学说，我家也这么收拾，这样很利索呀。不过，对于操作系统，这样做虽然有好处，但是也会有一些问题。

*提示：*Linux对磁盘的管理机制不同，文件存放位置相对分散，因此不容易产生碎片。

【文件增大产生碎片】

比如，一开始存了一个文件，也就是搬来了一个箱子，比如叫“日记”。Windows
7把它放在最靠墙的位置。后来又存了很多其他的文件，在“日记”文件的前前后后，左左右右，上上下下都放满了。忽然这一天，日记文件被修改了，加了点内容，就相当于往“日记”那个箱子里加了东西。可是箱子已经满了，再往里加，箱子就要增大（也就是文件大小变大，毕竟是比喻，不是真的箱子，大家不用费脑子想箱子怎么会伸缩）。可是箱子周围堆满了其他的箱子，没地方了，怎么办呢？

可以把边上的箱子挪开一点，原来的箱子就可以扩大了。可是边上的箱子要是少还好办，要是很多，还都装了铅块铸铁大理石什么的，那可就累死了。那怎么办呢？只好把新的内容放在另一个小点的箱子里，放在别处。然后还得在原来的“日记”箱子上标注上“日记（第1部分，第2部分在东墙根）”。然后在新的箱子上写“日记（第2部分，结束）”。日子长了第2个箱子也被很多箱子挤在中间后，又要编辑日记文件，这个文件又变大了，就又要如法炮制出第3个箱子，乃至第4个，第5个......

【碎片太多影响性能】

等到有一天，要读取这个日记文件的时候，Windows7就忙开了------首先，到西墙角找到日记第1部分，翻腾出里面的内容，然后往箱子上一看“第2部分见东墙根”，然后再跑到东墙根找第2个箱子，翻腾出里面的内容，再一看箱子“第3部分见大衣柜上头”，然后又搬梯子，上大衣柜一看“第4部分在厕所水箱后边”......等到Windows7把整个日记文件读完了，也累得半死了。这种情况，就是会影响性能的磁盘碎片。好，本节课到此结束，同学们自由活动吧，那位同学，快去捡你的BP机去吧，说不定还能找着。

** 4.5　办公软件

今天蜗牛打开电脑，破天荒地先去叫醒了OO老先生，往常都是先去叫醒狐狸妹妹或者去找那个World of Goo玩一会儿。今天找OO老先生干什么呢？

*** 4.5.1　LibreOffice
*** 4.5.2　翻译软件
*** 4.5.3　电子邮件Evolution和雷鸟

** 4.6　我的杀毒中心

虽然我们Ubuntu系统作为家庭用户的桌面版没啥中毒的机会，因此也没有装杀毒软件的必要，但是给我们装个杀毒软件，帮别的系统杀杀病毒还是不错的。这不，懒蜗牛同学就机缘巧合地开始研究Ubuntu系统下的杀毒软件了。

*** 4.6.1　Linux下也有杀毒软件

事情是这样的。懒蜗牛同学写好了简历后，把简历存储在他的U盘里拿去打印。然而这个学校的公共电脑，尤其是天天插各种U盘的连接打印机的那台电脑中，基本上快成病毒博览会了。懒蜗牛同学的U盘往那台机器上一插------无悬念命中。

懒蜗牛同学发现U盘染毒之后，马上想到了我们Ubuntu系统对病毒免疫（准确地说是对Windows病毒免疫）。于是打算把U盘插到我们系统上，备份好U盘里面的重要文档之后，把U盘整个格式化一遍。但转念又一想，这样也太没有技术含量了，不如在Ubuntu系统中装上杀毒软件，把U盘上的病毒杀掉。对，说干就干！

那么Linux系统下也有杀毒软件么？当然有，下面就给您介绍几个。

【Avira AntiVir Personal】
【ESET NOD32 Antivirus for Linux Desktop】
*** 4.6.2　Linux下杀毒毫无压力

懒蜗牛同学经过筛选，决定安装avast来完成他的U盘杀毒工作。于是，我们几个软件马上开始干活：狐狸妹妹Firefox掏出Downthemall扩展把avast的deb格式的安装包下载下来；apt负责将安装包解开，掏出里面的avast并把他安顿在硬盘里；之后，我接到了蜗牛用户的指令，把avast叫起来干活。

avast进入工作状态之后，先去网上下载了最新的病毒库。这个病毒库就相当于一沓子通缉令。那上面写着各种已知病毒的名字、相貌特征、作案手法等信息，以便avast在杀毒的时候查对。下载完毕之后，就见avast收拾好工具，整理一下装备，向着懒蜗牛那狭小的U盘出发了。

【活着的病毒不好杀】

要说起病毒来，Windows系统还真是挺害怕它的。无论是Windows 7还是Windows
XP，或者更早的Windows系统，都需要杀毒软件的保护。针对Windows系统的病毒多种多样，各有各的本领，真是八仙过海各显其能。

有的病毒会伪装成别的软件。比如Windows
7叫醒“记事本”去干活，却不知真正的记事本已经被病毒一棍子打死了。现在躺在那里，长得跟记事本一样的家伙，其实是整了容的病毒。有的病毒能够藏在正常的程序里面。一个正在工作的IE同志，很可能工作服的兜里就隐藏着病毒。并且现在多数的病毒都会随着Windows系统一起起床。当Windows
7被叫醒，伸个懒腰揉着眼睛走进内存的时候，他庞大的身躯后面可能正趴着40多只病毒。

由于病毒是活的，要杀掉它们很困难。它们可能会有很多人共同作战：杀毒软件杀掉了内存里的强夫，内存里的大熊会把硬盘里强夫的复制版再叫起来。扭头杀毒软件去杀大熊，强夫会把杀掉的大熊抢救过来，结果谁也没被杀死。有的病毒更暴力，自己先跑进内存，一看见有杀毒软件要进来，立刻过去一铁锹把杀毒软件拍死，然后藏起铁锹装着杀毒软件的声音说：“杀毒软件成功启动，没有发现病毒，噢耶！”有的病毒还能监视IE，一旦他要访问什么杀毒防毒相关的网站，二话不说，直接将IE干掉！

综上所述，要想在Windows系统中杀光这些活着的病毒，还是有很大难度的。

【睡着的病毒不反抗】

但这回avast去杀毒就简单多了。因为他杀毒的时候，电脑中运行的是我们Ubuntu系统。Windows的那些病毒根本无法在我们的系统中运行，就像死掉一样只会躺在硬盘或者U盘里睡觉。这时它们不会有任何反抗能力。avast过去，只要根据通缉令一一对照并干掉即可。只听到U盘里边不时传出“啊！”“呃......”“哎呦～”“我死得好惨呐！”等惨叫声。过了一段时间，avast回来向蜗牛报告：“共发现病毒7种，总计214只，全部歼灭。”

从那以后，懒蜗牛又装了几款其他的杀毒软件，并经常帮他的同学和朋友清理各种移动设备上的病毒。谁有什么带毒的，不敢往自己电脑上插的设备，都要先插到蜗牛同学这台百毒不侵的电脑上处理一下，才敢使用。懒蜗牛同学成功地依靠我们Ubuntu系统，把他这台电脑打造成了一个杀毒中心！

** 4.7　本章小结

这一回中，懒蜗牛同学算是过足了装软件的瘾了。上网用的浏览器挨个换了一个遍，下载软件、媒体播放软件、图片处理软件、办公软件、杀毒软件，都是挑了又挑，选了又选，终于都找到了自已用着顺手的一款。说明这Linux下的软件，还是挺丰富的吧。

那么这些软件能不能完全满足懒蜗牛的需要呢？会不会有什么软件在Linux下找不到替代品呢？咱们下回再说。

#+BEGIN_QUOTE
概要:
内存碎片, 软件解码与硬件解码.
#+END_QUOTE

**
* 第5章 VirtualBox

使用虚拟机.

有些Windows的软件可以靠红酒大师来搞定，但其实这只是一少部分，更多的软件是无法被红酒大师催眠并工作的，比如懒蜗牛同学需要用到的Office软件。这时候就需要虚拟机软件来解决问题了。

** 5.1　天上掉下个盒子妹

今天懒蜗牛同学让狐狸妹妹去
http://www.virtualbox.org/wiki/Linux_Downloads
这个地址下载了一个deb包，之后自然是双击这个包，叫apt来装了。apt把这个包拆开，看见里面躺着一只软件------VirtualBox。

*提示：*网上下载的商业版VirtualBox并不开源，如果想使用开源版，可以安装软件源中的virtualbox-ose软件包。

VirtualBox（咱以后就叫她盒子妹吧）被apt从deb包里抱出来之后，整理整理自己的行李，很有礼貌地跟周围的人打了个招呼。盒子妹长着一张国字脸，就像图5.19所示的模样，很文静的样子，打招呼时说话有些怯生生的感觉。跟大家打过招呼后，她来找到我，把一些内核模块放在我这里，安顿好一切后，就去睡觉去了。这家伙给我的印象还不错，我就跟狐狸妹妹聊起她的背景来。

[[./Images/image00431.jpeg]]

图5.19　VirtualBox的logo

【悲惨的身世】

听狐狸妹妹说，她的身世是挺悲惨的。

盒子妹最初生在德国，生母是一个叫做InnoTek的公司。盒子妹一生下来就经常被VMware和VirtualPC这样的邻居大哥哥欺负，不过好在她自己的本领还算可以，并且后来他亲妈InnoTek为了让她学习到更好的本领，还把她的源代码依据GPL协议开放了，让全世界的高手们来指导她。之后盒子妹凭借不错的性能，以及可以免费使用的特点，总算闯出了自己的一小块天地。

不过好景不长，2008年，亲妈InnoTek被卖给了红太阳公司，盒子妹自然也被过继过去。但好在红太阳公司这个后妈还算不错，很照顾小盒子的成长，继续让她在开放的环境中健康长大。没过多长时间，靠着红太阳公司众多高手的支持和全世界热心用户的拥护，小盒子俨然已经成为Linux下同类软件的首选，开源的本质使得追求自由的人们放弃了VMware；简便的操作让人们淘汰了Qemu；跨平台的支持更是微软公司的那个VirtualPC所无法比拟的。

*提示：*Qemu是一个字符界面的开源虚拟机软件。

盒子妹本来以为自己之后的道路会走得很顺畅。可是，2009年，又一次波折打击了小盒子------红太阳这个后妈也被卖给人了。收购他们的是一个很古老的公司，听说那个公司里的人好像都还在写甲骨文，也不知道他们每天用象形文字怎么办公。

甲骨文公司收购了红太阳之后，红太阳的几个孩子都面临着一段未知的命运。其中最让人担心的是MySQL，因为之前MySQL经常跟甲骨文家亲生的Oracle打架，这一下Oracle的亲妈成了MySQL的后妈，那MySQL还不得天天受欺负啊。我们的盒子妹的处境或许会稍好一些，毕竟甲骨文亲生的孩子里没有和她有同样本领的，所以小盒子在那里或许还不至于受谁欺负。不过那也毕竟是经历了重大的变革，对小盒子的成长还是会有一些影响吧。

** 5.2　创建虚拟机

说了这么多，忘了介绍盒子妹是干什么的了，她是一个虚拟机，就是能在一台计算机上虚拟出另外一台计算机来。怎么样，听起来这个本事很厉害吧？我们第一次看她工作的时候，都看呆了。

【注册账号】

“您好，欢迎使用VirtualBox虚拟机软件。请问您有账号吗？如果没有我可以帮您注册一个。”

懒蜗牛同学一愣：“这个还要账号啊？”

“是的，我们为了更好地为您提供优质的软件，需要您使用邮箱地址来注册为我们的用户。不过您放心，注册很方便，而且是免费的。”

懒蜗牛这下放心了：“好，那就注册吧。”

“那么请问您的名字是？邮箱是什么？”

懒蜗牛按照盒子的指导，------做了答复，很快就注册完了。

【创建虚拟机】

注册结束后，终于进入了盒子妹的主界面。目前上面还什么都没有，于是懒蜗牛单击了左上角的“新建”按钮，盒子妹就开始引导懒蜗牛创建虚拟机了。

“您好，您选择了新建一台虚拟计算机，我将指导您一步步创建。准备好了就按下一步。”

懒蜗牛觉得盒子妹服务很周到，单击了“下一步”按钮。

（1）设置计算机名称及系统类型

“首先，给您要新建的计算机取个名字吧，这样便于以后管理。另外，您还得告诉我这台计算机打算安装什么样的操作系统。”

懒蜗牛说：“名字就叫Windows XP，懒蜗牛的虚拟机，系统呢，装Windows
XP吧。”懒蜗牛输入了名字，选好了系统类型，如图5.20所示。

[[./Images/image00432.jpeg]]

图5.20　设置虚拟机名称及系统类型

*提示：*系统类型只决定了VirtualBox为虚拟机内的系统提供什么样的驱动程序，不影响系统安装的成败，在虚拟机创建好以后系统类型可以更改。

（2）为虚拟机分配内存

“好的，如果要装Windows XP那我建议您使用192
MB的内存，您看可以么？”“分配512
MB吧，快一点。”懒蜗牛同学按如图5.21所示，设置了内存。

[[./Images/image00433.jpeg]]

图5.21　设置虚拟机内存

（3）为虚拟机设置硬盘

“好的，那么现在请您选择硬盘。您可以选择创建一个新的虚拟硬盘，也可以使用已经存在的虚拟硬盘。虚拟硬盘就是由我们VitrualBox软件创建的，扩展名为vdi的文件。”说着，盒子妹给了懒蜗牛两个单选项，如图5.22所示。

[[./Images/image00434.jpeg]]

图5.22　选择虚拟机硬盘

“我这里没有现成的虚拟硬盘，新建一个吧。”懒蜗牛单击了“创建新的虚拟硬盘”单选按钮，并单击了“下一步”按钮，于是盒子妹弹出了新建虚拟硬盘向导的窗口，如图5.23所示。

[[./Images/image00435.jpeg]]

图5.23　创建新的虚拟硬盘

【创建虚拟硬盘】

（1）选择虚拟硬盘类型

懒蜗牛单击了“下一步”按钮后，盒子妹又给出了两个选择：“好，那现在我来引导您创建硬盘，首先选择一下您想要哪种虚拟硬盘？有固定大小的，有动态扩展的。”如图5.24所示。

[[./Images/image00436.jpeg]]

图5.24　选择虚拟硬盘类型

“这个......什么动态固定的，有什么区别么？”

“固定大小，就是选择了硬盘大小时，马上在您的真实硬盘上创建出相应大小的文件。动态扩展则是先创建出一个很小的文件，等您真的往这块虚拟的硬盘里复制数据的时候，它才会变大。动态扩展的硬盘，自然要比固定大小的效率低一些。”

“哦......这样啊，那来动态的吧！省地方是关键。”懒蜗牛同学选择了动态扩展，并单击“下一步”按钮。

（2）设置硬盘名称及大小

之后盒子妹继续询问下一个问题：“好的，那么请给您的这块硬盘起个名字，并且指定大小。”就是图5.25所示这样。

[[./Images/image00437.jpeg]]

图5.25　选择虚拟硬盘大小及名称

“那就叫‘懒蜗牛的硬盘'吧，大小最大能多大？”

“2 TB。”

“好，那就2
TB吧！过回大硬盘的瘾，哈哈。反正是动态分配的，不会真的一下子就占我2
TB的空间吧？”

“是的，您真聪明。”这句话怎么听着都不像是在夸懒蜗牛呢？

【完成创建】

“那么现在您选择了创建懒蜗牛的虚拟机，准备安装Windows
XP系统，内存512MB，是用懒蜗牛的硬盘作为虚拟硬盘文件。如果没问题，请单击‘完成'按钮。”就像图5.26所示这样，盒子妹让懒蜗牛同学最终确认一下。

[[./Images/image00438.jpeg]]

图5.26　确认创建虚拟机

于是，懒蜗牛单击了“完成”按钮。

之后回到盒子妹的虚拟机管理界面，从左侧列表框里已经可以看到，出现了一个新的计算机，如图5.27所示。

[[./Images/image00439.jpeg]]

图5.27　虚拟机管理界面

懒蜗牛迫不及待地单击了“开始”按钮，很快屏幕上弹出了一个虚拟机窗口，里面好像是BIOS的界面，这自然是盒子妹虚拟出来的BIOS启动画面了。之后屏幕一黑，屏幕上出现了一行文字，大概意思就是：没有操作系统，没法启动。

懒蜗牛问：“我不是选择了Windows
XP系统么，怎么没有？”盒子妹赶紧解释：“那个......我是虚拟机软件，不是虚拟系统软件。我只能虚拟出一台计算机，至于上面的系统，就像真正的机器一样，需要安装后才能使用。”懒蜗牛恍然大悟：“哦，原来如此啊，那我赶快装系统吧。”

*提示：*VirtualBox也有Windows的版本，可以在Windows系统中通过虚拟机安装Ubuntu系统。创建虚拟机的方法与上述类似。只是选择系统类型时应选择Ubuntu，并且挂载安装光盘时改为挂载Ubuntu安装盘而已。

** 5.3　在虚拟机上安装Windows系统

要说安装Windows
XP系统，对懒蜗牛同学来说可是轻车熟路了。于是他找来一个叫做Windows
XP.iso的光盘镜像文件，准备安装系统。

【装载ISO文件】

要安装系统，就先要把安装光盘放进光驱吧，这个盒子妹虚拟的计算机不需要你真的刻出光盘，只要准备好ISO文件，把文件装载进虚拟机就可以了。装载的步骤也不麻烦。

（1）懒蜗牛选中了他刚刚建好的那个虚拟机（这时候这个虚拟的计算机已经被关闭了），在右侧单击“Storage”标签，如图5.28所示。

[[./Images/image00440.jpeg]]

图5.28　虚拟技配置信息

*提示：*也可以单击虚拟机管理基面上的“设置”按钮，并在左侧列表框里选择“Storage”。

（2）在弹出的界面中，懒蜗牛选择了那个虚拟出来的光驱。就像图5.29中1.所示（目前是“没有盘片”的状态）。右边有个CD/DVD
Device下拉列表框，这个不用管它，保持默值认值就行。

[[./Images/image00441.jpeg]]

图5.29　挂载ISO文件

（3）懒蜗牛单击了CD/DVD
Device下拉列表框右边的光盘图标，如图5.29中2.所示。在弹出的菜单中选择了“Choose
a virtual CD/DVD disk file”选项，并找到需要用的ISO文件，就可以了。

经过这么一番操作之后，就相当于把光盘放进光驱里面了。然后干什么呢？当然是打开电源啦！

【安装Windows XP】

随着盒子妹手中的一根魔法杖的挥舞，内存里顿时出现一个像玻璃盒子一样的大房间，整个房间占地面积达512
MB。之后盒子妹又一挥法杖，那个ISO文件被慢慢打开，爬出了Windows XP。

Windows
XP从虚拟的光驱里爬出来之后，跑进那个512MB的玻璃房子中。也不知道盒子妹用了什么方法，Windows
XP乖乖地待在那512
MB的空间里，玻璃外的空间他好像都没看见一样，当然更看不见我们。对于Windows
XP来说，他正在一台拥有512 MB内存、2 TB硬盘、3 GHz主频的CPU的机器上运行。

Windows XP在检查了这些硬件后抱怨道：“这是谁攒的机器啊！3 GHz主频的CPU，2
TB的硬盘，竟然只有512 MB的内存！”听得我们都想乐。之后Windows
XP摆出了一张蓝脸，跟用户说：“我这个系统可只能装在一台机器上啊，装多了算盗版，小心警察叔叔请你去喝茶。还有啊，咱丑话说在前头，我要是挂了，弄坏了你的数据可别赖我啊，跟我没关系。你同意不同意？同意就按F8键，不同意趁早就别装了。”懒蜗牛想都没想就按了F8键------早已麻木了。

之后的过程对懒蜗牛来说，已经没有任何悬念了，都装过多少次了。这台机器的配置还是不错的，Windows
XP虽然跑在盒子妹创建的虚拟机里面，但是仍然只花了30分钟就安装好了。

装好了之后又重启了一下计算机，Windows XP终于正常启动了。

** 5.4　安装功能增强包

系统装好了之后，当然还得装驱动。懒蜗牛同学并没有去翻箱倒柜地去找买计算机时的各种驱动盘。因为他明白，Windows
XP是被装在了虚拟机里，所以Windows
XP看到的计算机并不是这台真正的计算机，而是盒子妹虚拟出来的计算机。这台虚拟的计算机使用的硬件也都是虚拟的，跟你的真实硬件无关。

*提示：*虚拟机中的硬件只有CPU与真机的相同。

说了半天，这虚拟机里的Windows
XP应该装什么驱动呢？不用您操心，盒子妹都已经预备好了。您只要像我们的懒蜗牛同学这样操作就可以了。

（1）只见懒蜗牛在Windows
XP的虚拟机窗口上单击了“设备”|“安装增强功能”，如图5.30所示。

[[./Images/image00442.jpeg]]

图5.30　安装增强功能

（2）之后，盒子妹从兜里掏出了一个ISO文件，悄悄塞到给Windows
XP虚拟出来的那个光驱里。Windows
XP应该会自动运行光盘上的安装程序。如果Windows
XP没有自动运行，那就手动打开光驱（是虚拟机里面Windows
XP的光驱哦，不是我的真光驱）。双击安装程序，也就是图5.31中所示的这个程序。

[[./Images/image00443.jpeg]]

图5.31　增强功能安装程序

（3）程序的安装很简单，一路单击“下一步”就好了。

装好之后，自然是要重启一下了，重启后的Windows
XP似乎性能更好了些，而且懒蜗牛同学的鼠标也可以很平滑地在Windows
XP与我之间切换了。

*提示：*安装增强包前，鼠标点入虚拟机中之后需要按右shift键使鼠标回到真机中。

Windows XP装完了，然而懒蜗牛的目的不是装个Windows
XP耍着玩，而是要在上面装上Office。Office安装程序懒蜗牛自然是有，放在隔壁那个Windows
7的屋子里。但是大玻璃笼子里的虚拟的Windows
XP连我们这个Linux的屋子都看不见，更看不见隔壁那Windows
7的屋子了。那怎么办呢？别担心，盒子妹早就设计好了。

** 5.5　为虚拟机配置网络

盒子妹模拟出来的虚拟机和我所在的真机之间，主要是通过网络来共享数据的。因此，首先配置好虚拟机的网络是必要的。

其实多数情况下，盒子妹默认就已经把虚拟机的网络设置好了，可以直接从虚拟机访问真机，如果真机能够联网，那么虚拟机也能联网。不过我们还是再唠叨一下虚拟机的网络设置，万一出现问题了也好排查。

（1）要设置虚拟机的网络，可以在盒子妹的主界面------虚拟机管理界面中选中要设置的虚拟机，并且单击右侧的“网络”标签，如图5.32所示。

[[./Images/image00444.jpeg]]

图5.32　单击网络标签设置网络

*提示：*也可以单击虚拟机管理基面上的“设置”按钮，并在左侧列表框里选择“网络”。

（2）之后弹出虚拟机设置窗口，并选择“网络”选项，如图5.33所示。

[[./Images/image00445.jpeg]]

图5.33　网络设置界面

（3）确认“网络连接1”标签中，勾选了“启用网络连接”复选框。并且连接方式选择“NAT”方式，即可实现虚拟机访问真机及访问互联网。

*提示：*如果需要虚拟机中有更多块网卡，则依照上述设置方法设置“网络连接2”～“网络连接4”即可。

这里我们要解释一下连接方式下拉列表框中的所有选项，总共有4个：NAT、Bridged
Adapter、Internal、Host-only
Adapter。假设你现在的计算机所在的网络拓扑结构如图5.34所示。我们依次解释一下这几种虚拟机的连接方式。

[[./Images/image00446.jpeg]]

图5.34　实体计算机网络拓扑结构

　NAT------这个是最省心的。由盒子妹负责把你的实体机虚拟为一台仅针对虚拟机的服务器，为她所管理的虚拟机提供路由、DHCP、DNS等网络服务。虚拟机不必设置网络，只要通过DHCP自动获取网络配置即可联网。这种模式下的网络拓扑结构如图5.35所示。

[[./Images/image00447.jpeg]]

图5.35　NAT模式网络拓扑结构

　Bridged
Adapter------网桥模式。这个模式让虚拟机像真机一样连接到实际的网络环境中。在拓扑结构上虚拟机和你的真机是同级别、并列的关系，如图5.36示意的这样。这种模式需要设置一下虚拟机的网络，真机如何设置的，虚拟机参照着设置就可以了。

[[./Images/image00448.jpeg]]

图5.36　Bridged Adapter模式的网络拓扑结构

　Internal------内部网模式，这个模式不允许虚拟机和真机之间有任何的网络连接，而只是盒子妹所创建的所有虚拟机之间相互联网，如图5.37所示。

[[./Images/image00449.jpeg]]

图5.37　Internal模式的网络拓扑结构

　Host-only
Adapter------主机模式，这个模式只提供虚拟机和真机相互连接，默认状态下虚拟机无法访问外网，网络拓扑结构如图5.38所示。这种模式下，需要真机为虚拟机提供路由或代理之类的服务，虚拟机才可以访问外网。

[[./Images/image00450.jpeg]]

图5.38　Host-only Adapter模式的网络拓扑结构

** 5.6　与虚拟机共享数据

设置好了网络，这样真机和虚拟机之间交换数据就方便多了。比如可以在真机的系统上开一个ftp服务，然后虚拟机通过ftp客户端来访问，实现交换各种文件。不过这种方法还是比较麻烦的，最简单的就是利用盒子妹提供的“分配数据空间”的功能来共享数据。下面就跟着我们的懒蜗牛同学来一步一步设置吧。

（1）首先，懒蜗牛同学在一台运行着的虚拟机窗口中（也就是虚拟的那个Windows
XP啦），单击了“设备”|“分配数据空间”，如图5.39所示。

[[./Images/image00451.jpeg]]

图5.39　分配数据空间

（2）之后，盒子妹弹出了数据空间窗口，目前里面什么也没有，如图5.40所示。不过别急，只见懒蜗牛单击了右边的“添加”按钮，就是一个带加号的文件夹那个图标。

[[./Images/image00452.jpeg]]

图5.40　数据空间窗口

*提示：*“临时分配”的数据空间，在本次虚拟机停止运行之后失效。“固定分配”的数据空间对于当前虚拟机一直有效。

（3）单击了“添加”按钮之后，盒子妹弹出了“添加数据空间”窗口。懒蜗牛单击了“数据空间位置”下拉列表框右侧的下三角按钮，把位置指向了存有Office安装文件的目录。之后在下面的“数据空间名称”文本框里给这个空间起了个名字，叫做share。为了确保不会破坏里面的数据，懒蜗牛还勾选了下面的“只读分配”复选框。这样设置好之后，如图5.41所示。确认没问题后就单击“确定”按钮，如图5.42所示，已经建立了一个临时分配的数据空间了。

[[./Images/image00453.jpeg]]

图5.41　添加数据空间

[[./Images/image00454.jpeg]]

图5.42　创建了临时分配数据空间

*提示：*“Auto-mount”选项用于虚拟机中的系统就是Linux系统的情况。勾选此选项，虚拟机中的Linux系统将在每次启动时自动挂载所分配的数据空间，否则需要在系统中手动挂载。

*提示：*勾选“固定分配”复选框，将设置此次创建的数据空间为“固定分配”，否则为“临时分配”。

（4）盒子妹的设置这就完成了，现在该去操作那个虚拟的Windows
XP了。只见懒蜗牛右击了Windows
XP的“我的电脑”，选择了“映射网络驱动器”，如图5.43所示。

[[./Images/image00455.jpeg]]

图5.43　在虚拟机中映射网络驱动器

（5）然后会弹出一个对话框，让懒蜗牛选择要映射的网络文件夹，如图5.44所示。懒蜗牛单击了“浏览”按钮。

[[./Images/image00456.jpeg]]

图5.44　映射网络驱动器

（6）在弹出的“浏览文件夹”窗口中，懒蜗牛选择了“整个网络”|“VirtualBox
Shared Folders”|“\\VBOXSVR\share”，如图5.45所示。

[[./Images/image00457.jpeg]]

图5.45　浏览文件夹

（7）选中之后单击“确定”按钮。这样，在这个虚Windows
XP的“我的电脑”里面就多出了一个网络驱动器，就像图5.46所示的那样。双击进去，就是看到刚刚被懒蜗牛指定的那个目录的内容了，Office的安装程序就在那里。

[[./Images/image00458.jpeg]]

图5.46　在“我的电脑”中查看刚刚创建的数据共享

这之后的过程就没有什么意思了。懒蜗牛在Windows
XP中进入刚刚创建的那个空间，双击那个setup.exe文件，就开始了Office的安装。在一堆毫无悬念的“下一步”之后，就装好了。

** 5.7　更多虚拟机介绍

内存里的软件们逐渐熟悉了Windows
XP的工作场景，渐渐地都把目光从大玻璃笼子里的Windows
XP身上收回来，并且从“好奇”档切换到“崇拜”档，然后投向盒子妹。大家纷纷称赞：“盒子妹你真厉害！”“竟然能控制好这么大的内存，里面关着Windows
XP还不让它溢出。”“你是怎么给Windows XP虚拟出那么一块显卡的？”

盒子妹被崇拜得不大好意思，向大家说道：“其实......也没有什么啦。我只是创造出一个虚拟的计算机而已。有这种能力的，也不是只有我有一个，像Qemu，VMware这些都是值得我学习的前辈。”

【老牌的VMware】

gedit小弟忙问：“VMware？这是啥？说来听听。”

狐狸接过来说：“我来介绍吧！VMware，这是个比较老牌的虚拟机软件，各方面都比较强悍。长相有些纠结，就是如图5.47所示这个样子。他的稳定性是很高的，好多企业服务器都用到他。”

[[./Images/image00459.jpeg]]

图5.47　VMware的Logo

我不解地问：“服务器用虚拟机干什么？”盒子妹过来解释：“主要是为了在节约硬件成本的同时，提高系统解决方案的安全性。打个比方吧，比如一个公司内部，要架设一个邮件服务器，和一台ftp文件共享服务器。由于用户不多，所以这两个服务都不需要很高的硬件配置。完全可以在一台服务器上跑这两个服务。”

“那就装俩呗！”gedit忍不住说。

“但是，”狐狸妹妹接了过来，“如果提供邮件服务的软件有漏洞，就可能有入侵者通过漏洞获取整个系统的管理员权限，然后就可以影响到ftp服务。反过来也一样。于是这台服务器被攻破的概率就变大了。是吧，妹子？”

盒子妹点点头：“嗯！就是这个意思。在一个系统中，开启的服务越多，可能引来的漏洞就越多，一旦其中一个服务被攻击，就可能影响其他的服务。”

狐狸也点点头：“对，就是这意思。”

盒子妹继续说：“但是用VMware这样的虚拟机就不同了，可以在服务器上装虚拟机，再在每个虚拟机里分别装系统，每个虚拟系统分别跑一个服务。”

狐狸：“对，分散。”

盒子：“这样就算某个系统上的服务受到攻击......”

狐狸：“也不影响其他服务。”

盒子：“所以就等于把风险......”

狐狸：“分散了。”

盒子：“这样安全性就......”

狐狸：“提高了。”

我和gedit都点点头：“行，你们俩说相声去吧！”

【Virtual PC】

“那还有什么虚拟机软件呢？”gedit继续问。

狐狸说道：“那时候还有个叫Virtual
PC的，一开始称得上跟VMware并驾齐驱了。那时候的情况是，VMware对内存的需求比较大，而Virtual
PC对硬盘用得比较多。不过后来那个Virtual
PC被微软公司收购了，自此以后就慢慢地销声匿迹了，我找到一张他工作时的照片，如图5.48所示。”众软件看了纷纷叹气摇头，惋惜这位明珠暗投的软件。

[[./Images/image00460.jpeg]]

图5.48　Virtual PC中运行的Windows XP

*提示：*Virtual
PC被微软收购后，不再提供对Linux主系统及客户系统的支持。即：既不能在Linux系统中安装Virtual
PC软件，也不能在Virtual PC虚拟的计算机内安装Linux系统。后来自Virtual PC
2007版本以后，再没有更新桌面版Virtual PC。

【Qemu】

狐狸妹妹稍稍停顿后继续说：“后来，咱们开源界自然也不甘寂寞，有了Qemu这个虚拟机。这是一个字符界面的软件，使用起来有些费劲，不过功能很强大，可以和GDB协作，用于调试内核代码。也就是在Qemu创建的虚拟机里面跑一个内核，然后在虚拟机外开着一个GDB来进行调试。再加上他开源的性质，可以很方便地迁移到各种硬件平台，于是成为嵌入式开发者常用的软件。”

“哦......”大家虽然“哦”了一下，但我估计还有很多软件不知道嵌入式是什么意思。

狐狸妹妹继续说：“后来呢，Qemu确实使用不方便，不过好在是开源的，于是就有人在Qemu的基础上进行改造，添加了图形界面，并且增强了对显卡的支持等，最终把Qemu改造成了一个很好用的虚拟机。”gedit问：“改完了叫什么？还叫Qemu么？”狐狸微微笑了一下，望向盒子妹，只见盒子妹不好意思地说：“就是我啦，我是在Qemu的基础上修改而来的。”

【KVM】

继续听狐狸介绍：“再后来呢，出了那个叫CPU的虚拟技术，就是让CPU可以支持直接被虚拟机使用，比如Intel家的VT-x技术和AMD公司的AMD-v技术，虽然实现可能不大一样，不过从根本上讲其原理都差不多。”

gedit问：“这种技术是干什么用的？”

盒子妹解释道：“主要就是可以提高虚拟机的运行效率。对于这种技术支持得最好的，可以说就是KVM了。不过他需要内核的支持，并且本身并不是一个完整的虚拟机软件，因此需要依赖Qemu来运行。”

狐狸接过盒子的话说：“这样运行起来的虚拟机，运算效率大幅度提高。但是KVM虚拟的显卡很差劲，所以用来虚拟不需要太多显示任务的服务器应用很有意义，但是对于桌面应用，看片、玩游戏，就不如咱们的盒子妹妹了。”盒子妹又不好意思地说：“姐姐过奖了。”

*提示：*现在的VirtualBox同样可以支持CPU虚拟化技术。在虚拟机管理界面单击“设置”按钮，在左侧列表框里选择“系统”，然后在右侧选择“硬件加速”标签，如图5.49所示。勾选“启用VT-x/AMD-V”，以及“启用Nested
Paging”复选框即可（前提是确认你的CPU支持相应虚拟化技术）。

[[./Images/image00461.jpeg]]

图5.49　设置硬件加速

** 5.8　扩展阅读：虚拟化技术

刚才说到了CPU的虚拟化技术，顺道介绍介绍这个CPU的虚拟化到底是怎么回事吧。

【只有操作系统才能随意使用CPU】

话说这个CPU可是我们程序要使用的重要设备，每个程序都离不开它。可是CPU很贵，不能发给每个程序一个（否则懒蜗牛同学会破产），于是就得由我统一管理CPU的使用。狐狸妹妹来了，我会把CPU给她用，gedit小弟也来了，他也要用，那么我就经过了工作间内激烈的角逐，各类软件的选拔工作已经尘埃落定。BT下载类软件中，奔流脱颖而出；视频播放软件里，SMplayer异军突起；图片管理软件组，Picasa稳操胜券；网络浏览器呢，自然是Firefox成功卫冕。然而，虽然Firefox胜过了Chrome和Opera这样的对手，却不知道有更要命的兼容性问题在前面等着她，也等着我们的用户，懒蜗牛同学。告诉他俩，一人用一阵儿。

像狐狸，gedit这些普通的程序我都可以管，因为我是内核嘛。普通的程序们也都知道我让他们停止使用CPU时，一定得停止。并且，CPU的哪些功能是可以用的，哪些是不能用的，他们也都清楚。但是现在盒子妹饲养的Windows
XP工作，就不一样了。

*提示：*某些CPU的高级命令只有内核级别的代码才能够使用。

【虚拟的操作系统也想随意使用CPU】

Windows
XP在工作的时候，是不管其他人的。首先他根本也看不见其他人，再者，他也是个操作系统，正常来说，他运行在一台机器上的时候，所有软件都得听他的。他可以随便使用任何硬件，当然包括这个CPU，就像我在我们这里的地位一样。然而当他运行在虚拟机里的时候，我们可不能真的让他随意使用CPU，否则万一他执行个啥特权级指令，搞不好我们整个系统就挂了。

你问啥叫特权指令？简单地说，CPU的指令分为两种，普通指令和特权指令。一般软件用CPU的时候都是执行各种普通指令，特权指令只有我这个操作系统可以执行。之前不是说CPU就像是个计算器么，特权指令就像这个计算器上的一些特殊的按键，实现一些特殊的功能，比如关机、复位什么的。这些按键一般人不许动，只有我可以按。

【让虚拟的系统用虚拟的CPU去吧】

那么既然有我在，当然就不许Windows XP动这些东西。可是盒子妹要给Windows
XP营造一个真实的硬件环境才行，怎么办呢？很简单，虚拟一个假的给Windows
XP用。看Windows
XP给虚拟的CPU发了普通指令，就扭头向我申请使用CPU，然后把那个指令在真实的CPU上执行一下，最后把结果传回给Windows
XP。如果Windows-XP执行了一个特权命令，那么盒子就不真的去执行，而是模拟一下执行那个命令后应该有的效果。比如Windows-XP执行了CPU自爆指令，盒子妹就在那里模拟：“轰隆！咔嚓，哎哟......”然后WindowsXP就信以为真了。

【虚拟化技术让虚拟系统能用上真的CPU】

那现在回来说这个CPU的虚拟化技术。

Windows
XP的每一个命令都由盒子妹转发是一件比较耗费时间的事情，于是人们提出了CPU的虚拟化技术。支持虚拟化技术的CPU有两种操作模式：VMX
root operation（根虚拟化操作）模式和VMX non-root
operation（非根虚拟化操作）模式，统称为VMX操作模式。VMX root
operation就是平时我们用的模式。而VMX non-root
operation则是像盒子妹饲养的Windows
XP这样的虚拟机系统所用的模式，在这种模式下，一些特权指令可以执行，但不会对真机起任何作用。

有了这种技术后，盒子妹就轻松了。Windows
XP要用CPU的时候，不用虚拟一个CPU给他用，而是直接向我申请使用CPU，然后把CPU开到非根虚拟化操作模式，之后直接扔给Windows
XP使用就可以了，反正这个时候那个自爆按钮已经不管用了，扔给他随便玩去吧！

** 5.10　本章小结

本章中，咱们的"乌棒兔"可算是认识了Windows系统里的不少软件。谁让这些软件只有Windows的版本呢。懒蜗牛非得用这些软件，那就只能是模拟运行了。

要么模拟Windows的系统环境来运行软件，这就是Wine的工作；要么就是干脆模拟出一台计算机，里面装Windows，这就是VirtualBox的工作。不过，模拟终归是模拟，偶尔应急还行，真正顺手的还是咱系统里的原生软件。不知道懒蜗牛同学还将体验到哪些有意思的原生软件，诸位，敬请期待下一章吧。
* 第6章 命令行的使用

虽然我们Linux的图形界面已经比较先进了，绝大多数操作都完全可以用图形界面来完成，但是就像吃过麦当劳肯德基不等于吃过西餐一样，连终端都没进去过，你也好意思说你会用Linux？因此懒蜗牛同学决定开始学习Linux的命令行了。

** 6.1　这就是命令行

学习Linux命令行，离不开一大堆的命令。不过在这之前，首先要对命令行有些了解。下面就来说说 命令行。

*** 6.1.1　初识终端

命令行并不神秘，打开“应用程序”|“附件”|“终端”，你看到的就是，如图6.1所示


*提示：*也可使用快捷键Ctrl+Alt+t来打开终端。

这种图形界面下的命令行窗口，叫做伪终端。在这个窗口里，你可以近距离地跟我交流。我们操作系统是很希望用户能够和我们使用命令来交流的，像朋友般倾诉，感受彼此的心声，而且还低碳环保，节省能源（省CPU和内存啊）。

*提示：*如果只是想要通过命令运行一下某个软件，例如gconf-edit，可以按下Alt+F2组合键并输入命令来执行。

【两种老板】

用户对于我们操作系统来说就相当于老板。使用图形界面的用户和使用字符界面的用户是两种完全不同的老板。

前者高高在上，拒人千里之外，就会比划，有事都不直说。比如他指着电灯开关的按钮冲你“嗯”一下，那就是让你过去把电灯打开；他用手一指桌面上的文件，冲你“嗯”一声，那是想让你选中这个文件；他要是指着文件冲你“嗯，嗯”两声，你就得明白他是让你打开文件（这里你还得注意，他“嗯”的那两声之间的间隔长短，要把握好分寸。要是间隔很短，那叫“双嗯”。要是间隔长，那叫“嗯”两下，对应的操作是不一样的）。他要是用手冲着桌面上的一堆东西指一圈，然后嘴里拉长声的“嗯～”一下，那就是让你把这些东西全都选中。给这种老板打工，需要很大忍耐力啊。

要是遇到第2种老板就要好得多，这种老板，平易近人，没有架子，有事会跟你平等地交流：“小笨啊，你列个表，看看我这目录下都有什么东西啊。”“小兔啊，3分钟后下班啦，到时候记得关机啊。”“小笨啊，咱挺寂寞的，放个片子看看吧。就放那个wall-E.avi吧。”遇到这样的老板，工作起来，才是心旷神怡。
# 我曹,wall-E工作的第一年哇.
用命令行的用户，就相当于这第2种老板，跟他们交流，舒服。

*** 6.1.2　Shell的基本概念

那么Shell又是个什么东西呢？

【Shell的作用】

Shell是啥？是海鲜馆的扇贝？是汽车用的润滑油？都不是，他是一个外壳。什么叫外壳呢？咱们慢慢说。

我们Linux是个内核，这个内核是可以做很多事情的，整个电脑的硬件都归我管。显卡、声卡、内存、硬盘都归我控制；硬盘上的各种程序也归我调度。那么，我应该用这些硬件软件去干点什么事情呢？我不知道，因为没有人给我下命令。下命令的就是人类用户，比如我的懒蜗牛同学。

可是人类用户要做什么操作，靠他拿嘴说，我肯定是听不懂的。因此就需要一个能够把人类用户的操作意图转述给我的软件，这个软件就是Shell。他就像罩在我这个操作系统和人类用户之间的一个外壳一样，在我和人类之间相互转达信息。

*提示：*Shell广义上可以指操作系统和用户接口的界面，图形界面也是一种Shell。因为图形界面的本质也是实现“把人类用户的操作意图转述给内核”。

【Shell的种类】

Shell有很多种，有bash、csh、ksh等，各有特点。

　bash------这是最常见的Shell了，全名为Bourne Again Shell。基本上多数发行版都用他作为默认的Shell程序。他的各项功能都比较完善，是个全能型选手。


【Shell的实质】

有的同学说了：说了这么半天，这个Shell到底是个啥软件啊，我怎么感觉不到他的存在呢？我从来没有运行过他呀。他跟终端有啥关系呢？

Shell，其实就是一个二进制的程序，跟狐狸、gedit他们一样。只不过，Shell的任务不是上网，也不是编辑文件，而是和用户交流。

比如我们Ubuntu系统中，默认的Shell是bash，也就是/bin/bash这个二进制文件。你没有亲自调用过他，是因为每次用户打开终端的时候，终端程序会自动调用用户的Shell。

那么终端怎么知道用户的Shell程序是什么呢？这很简单，在/etc/passwd文件里有记载。比如我们的lanwoniu用户打开了虚拟终端，G终端就找到passwd文件里对应当前用户的一行，类似下面这样：
#+BEGIN_SRC shell :results output
cat /etc/passwd | grep gaowei | sed "s/$USER/me/g"
#+END_SRC

#+RESULTS:
: me:x:1000:1000:me,,,:/home/me:/bin/bash

这一行的最后一段就说明了这个用户的默认Shell是/bin/bash。于是G终端就去叫醒bash，bash起床，通过G终端来跟懒蜗牛用文字交流。那么bash最先说的一句话大概就是“你好”，当然不会这么不专业，这句话用bash的专业语言说出来就是下面这样：

这一行是什么意思呢？

　“@”之前的，是当前用户的用户名。

　“@”后面，“:”前面是计算机名，这两个都好理解。

　“:”后面、“$”前面是当前所在目录，就是当前输入命令的人所在的位置。“～”代表用户的家目录，也就是“/home/<用户名>”这个位置。

　“$”则是命令提示符，在“$”后面就可以输入命令了。

*提示：*普通用户的提示符是$，如果用root登录终端，则提示符是#。但Ubuntu系统默认禁用root用户，所以一般看不到#提示符。

*** 6.1.3　bash的工作（简单的Shell命令介绍）

正说着，懒蜗牛已经开始敲命令玩了。什么ls、free、top、fdisk等常用命令，挨个试验。于是工作间里也开始忙碌了起来。你可能以为bash会在懒蜗牛的指挥下跑来跑去，执行各种操作。其实完全不是那么回事，bash只是作为一个命令的传达者而已，真正干活的是那些命令们，也就是ls、free这些家伙。

【bash和图形界面的工作性质相同】

这些所谓的命令，其实都是一个个的小程序，或者说一个个的小软件而已。就跟狐狸妹妹、OO老先生一样，只不过比他们小巧很多。如果你愿意，也可以把Firefox视为一个上网用的图形化界面的命令，为了方便描述，咱们以后管这些家伙叫做命令程序吧。

当用户输入命令比如ls的时候。ls这两个字符就被传给了bash。bash怎么处理呢？首先bash要看输入的字符是不是自己的什么关键字，比如for，history之类的，如果是，就归bash来处理了；如果不是，就说明懒蜗牛是要找个命令程序，bash就要负责去找到懒蜗牛想要的这个程序，并且叫他起床干活。

这个工作过程其实跟Gnome的工作是很相似的，只不过Gnome是根据鼠标的点击位置来判断用户想要运行哪个软件，而bash是根据用户输入的字符来判断的。

【bash查找命令的艰辛历程】

那么bash去哪里找哪些命令程序呢？不知道您有没有听说过有个叫做环境变量的东西，跟Windows系统里的那个环境变量差不多，其中有个环境变量叫做PATH，里面记录着bash去找程序的路径。如果你想看看PATH到底是什么，运行echo
$PATH就可以了。会得到类似这样的输出：
#+BEGIN_SRC shell :results output
echo $PATH | sed "s/$USER/me/g"
#+END_SRC

#+RESULTS:
: /home/me/anaconda3/bin:/home/me/anaconda3/bin:/home/me/anaconda3/bin:/home/me/anaconda3/bin:/home/me/anaconda3/condabin:/home/me/anaconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/home/me/.emacs.d/bin:/home/me/.emacs.d/bin:/home/me/.emacs.d/bin:/home/me/.emacs.d/bin

*提示：*$符号在命令中表示引用变量。可以export设置变量（这里引用和设置的都是全局变量，后文会讲到）。例如：


第1行设置test变量的值为字符串“my\_test\_word”，第2行使用echo命令来查看test变量，第3行是运行结果。

当懒蜗牛运行一个命令，比如ls时，bash就对照着PATH里面的设置，开始找了。

他先去/usr/local/sbin房间里面找（根据PATH的设置顺序）。敲开门，客气地问：“请问ls是住这屋么？”等了半天，除了墙角的蜘蛛网上那8条腿的小家伙寂寞地弹了几下琴弦之外，再也没有活物给他任何回应，于是bash意识到这屋没人，赶快去下一屋。

又到了/usr/local/bin，他依然是很礼貌地敲开门问候，里面只有一位懒蜗牛前几天安装的叫做Maya的软件，只听那位叽里咕噜地说了几句2012啥的玛雅语，bash也听不懂，不过反正他不是ls就对了，赶紧去下一间。

*提示：*/usr/local目录与/usr目录中的结构类似，都包含bin、sbin、lib、incud等目录。对于Linux系统，并没有明确地对这两个目录内容进行定义。不过一般来说，对于Ubuntu系统，/usr目录中用于存放从软件源中安装的软件。/usr/local中用于存放用户用其他方式安装的软件。

bash推开/usr/sbin这屋的门一看，这回里面很热闹，而且都是重要人物。有管用户创建的useradd、每天启动必备的gdm、负责跟通过网络跟Windows
XP共享文件的smbd和nmbd等。一听bash来找ls，useradd没好气地说：“哎呀，ls怎么可能在我们这里呢？我们这里都是管理级的程序，都是领导！那个ls是谁都能运行的，他怎么会在sbin里，你得去bin里面找啊。”

bash只好客气地退了出去，继续去找/usr/bin、/sbin/、/bin，终于在/bin里面找到了ls，于是赶紧叫醒ls，让他去干活。至此，bash的任务也就结束了，他就回去等待懒蜗牛的下一个命令了。

*提示：*一般/bin、/usr/bin、/usr/local/bin目录下存放的是普通用户使用的命令。/sbin、/usr/sbin、/usr/local/sbin目录下存放的是需要root权限才能使用的命令。

上面说的是直接敲一个命令的情况。直接输入一个命令，bash就会去PATH变量记载的路目中查找。如果你想运行一个二进制程序（比如刚刚从网上下的某个软件的安装程序），但这个程序不在这些/bin、/sbin之类的目录里怎么办呢？也好办，只要你运行的时候加上路径就可以了。如果没有写路径，那么bash就去PATH中的目录里找，如果写了路径，他就直接去指定的路径找了。

*提示：*Linux中，一般当前目录------即“./”，并不在PATH变量中，所以要运行当前目录下的二进制文件或脚本文件，也需要加上路径。例如要运行当前目录下的setup.sh脚本，需要输入：./setup.sh。

【有困难找纯爷们儿】
# 形象得很好.
懒蜗牛对照着书本练习各种命令。学到ifconfig命令的时候，觉得书上写得不是很明白，怎么办呢？bash告诉他：“别着急，我给你找个人问问，这个人，纯爷们儿！”然后bash扭头冲着硬盘里喊：“嘿man！你出来，说说这是怎么个意思。”

随着咔咔嚓嚓一阵硬盘响，只见内存中走来一人。见此人人高马大，膀大腰圆，扇子面的身材，胳膊跟大腿一样粗，这就是bash说的那个“man”。这纯爷们儿说出话来如同打个炸雷一样：“嘿！你好啊。洒家我是专职命令解说员，你有什么想知道的吗？”懒蜗牛输入了命令：

: man ifconfig

意思就是问man，这个ifconfig怎么用啊？man仰天大笑一声：“嚯哈哈哈，要说这个ifconfig嘛......不难，听我慢慢地道来！”当然，他不是用中文说的，而是用英语介绍了一下ifconfig命令的使用方法，
*提示：*进入man的界面后按q键可退出man。

** 6.2　这么用Shell
# 基本的shell命令
懒蜗牛同学那敲敲打打的命令行生活就这样开始了。从那以后，工作间里少见了红酒大师；看不到盒子妹妹；心有灵犀也不常来上班了；OO老先生也难得起床了，工作间里净是些命令行的小程序在跑来跑去。

*** 6.2.1　理解目录结构

这一天，懒蜗牛觉得玩伪终端不够过瘾，于是按下Ctrl+Alt+F1组合键进入黑漆漆的终端界面来敲名令。看着一屏屏的字符，懒蜗牛感觉很有成就感。

*提示：*进入终端后，可以按Ctrl+Alt+F7组合键回到图形界面。

【当前目录，家目录】

懒蜗牛进入终端后，先习惯性地运行了一下ls，看到了当前目录下的所有文件。

所谓当前目录，就是用户现在所在的目录。比如你在你家卧室发呆，那么你的当前目录就是卧室；过一会儿你又去客厅发呆了，那么当前目录就是客厅；然后你去厕所发呆，当前目录就是厕所（怎么到哪都发呆）。那么懒蜗牛现在的当前目录是哪个目录呢？就是他的家目录，就是图形界面的“位置”下的“主文件夹”那个目录，也就是/home/lanwoniu这个目录。当懒蜗牛每次打开终端的时候，无论是虚拟终端还是按Ctrl+Alt+F1组合键进入的终端，刚一进去，都是在懒蜗牛的这个家目录里。

*提示：*命令行下可以用“～”符号代表当前用户的家目录。

【出去走走】

不过，毕竟不是什么事情都要在家目录里做的，如果你在这个目录里看够了，想出去走走，到其他的目录逛逛，这时候就需要cd命令了。cd命令跟光盘没有关系，他是Change
Directory（改变目录）的缩写。这个命令可以改变当前的目录，他就像出租车一样，可以让你到达你想去的任何一个目录（当然，前提是你得有权限进入那个目录，就像你不能让出租车开进中南海一样）。

cd命令的用法就是：


【绝对路径和相对路径】

那么，路径该怎么写？如何描述你想去的目录呢？一般有两种方法：绝对路径和相对路径。

绝对路径就是无论去哪都统一从一个根本的位置上描述。比如你打车，司机师傅问你去哪，你说：“我去地球，亚洲，中国，北京市，崇文区，羊肉大街，排骨胡同，376号。”这么说就是绝对路径。无论你在什么地方打车，都从一个根本的位置上说起（比如地球，当然，你愿意从太阳系说也行）。层层递进，最终说到最小、最详细的那个地方为止，就肯定错不了。我们这里目录的地址当然不能从地球开始说了，我们的根目录“/”就是那个最初的、根本的位置，无论你去哪个目录，都可以从这里说起，比如：
: cd /usr/share/fonts/X11

这条命令的意思就是说，要去根目录下的，usr目录下的，share目录下的，fonts目录下的，X11目录。

绝对路径很准确并且最直接，不过有时候也比较费劲，所以，cd还支持相对路径。相对路径，就相当于你打车，司机师傅问你去哪，你说：“就前面那路口，左转，过三个红绿灯走700米有一家精神病院，到时候我指给您，您就靠边停车就行了。”这种描述方法就是以当前所在的地点为起始地点进行描述，而不用从外太空开始说。那么具体到我们这个系统里怎么说呢？还拿刚才那个命令作为例子。假如现在已经在/usr/share目录下了，那么就运行：

: cd /fonts/share

这样就进入X11目录了。这句命令的意思就是，要去当前目录下的，fonts目录下的，X11目录。

【引导员】

懒蜗牛同学学会了cd命令，兴奋地在终端里cd来，cd去的，像个跑进游乐园的小孩子。转着转着，忽然觉得有点迷路了。静下来想一想：我现在是在哪个目录呢？是在/usr/bin，还是/bin，还是/usr/local/bin呢？

其实，他看一眼那个提示符$前面的内容就可以了，默认设置下这里显示的就是用户所在的目录的绝对路径。不过这个提示符的格式是可以修改的，如果修改了，这里显示的不是当前的路径了，怎么办呢？

这一点，我们早为您想到了。命令行中配有专业的引导员，告诉您您现在所在的位置，这位引导员就是pwd。可别一看名字就以为他是负责修改密码的，其实他跟password一点关系都没有，他是Print Working Directory的缩写。用法简单，输入pwd就行了，他就会告诉你现在所在的目录。

*** 6.2.2　重要的TAB--命令补全功能

学习完ifconfig命令，懒蜗牛同学又开始研究fdisk，这是个磁盘分区命令。学习了这个命令之后，懒蜗牛又学习了查看网络端口的netstat命令。渐渐地，懒蜗牛发现了一个问题：随着命令字符越来越多，敲起来越来越费劲了。

一开始ls、cd、top这样的命令很简短，输入也没觉得麻烦。可遇到字母多的命令，一遍一遍地敲就慢多了，有没有什么省事的办法呢？

【便捷高效的键盘】

很多人不喜欢键盘，不喜欢打字。其实想想，早在电脑刚刚被发明出来的时候，键盘就已经是每一台电脑所必备的输入设备。作为从那个字符界面的时代走过来的Linux系统，我们自然充分考虑通过键盘操作整个系统的便捷和效率问题。直到现在，使用键盘操作Linux都会拥有意想不到的高效率和成就感。

我以前很不明白，键盘可以发送上百个命令，用起来应该很方便才对，为什么人类就那么喜欢那个只能发送：上、下、左、右、左键、右键、滚轮这么几个命令的鼠标呢？（当然，有的鼠标还有一些额外的功能键，但是那也比键盘少啊）。后来见多识广的OO老先生给我解释，我才明白。原来是因为人类记忆力不行，没有我们软件这么可靠，记不住那么多个键，于是只好用那只能发送几个命令的鼠标了。

好了，绕得有点远，其实说起来在我们的命令行里通过键盘敲命令是很方便的，只是很多人不大熟悉如何节省时间而已，都以为用键盘和我交流跟用键盘和那个DOS系统交流一样麻烦呢。其实我已经很人性化了，就因为键盘上有个键------Tab。

【重要的Tab键】

看一个人的键盘，就可以猜测出他平时用电脑干什么。如果W, A, S, D, U, I, J,
K这些键严重磨损，说明这哥们儿玩拳皇的；如果A, Shift, Ctrl, 1, 2, 3, 4,
..., 9, 0键严重磨损，说明是个玩即时战略的，星际魔兽之类；如果Alt,
S或Ctrl,Enter键磨损，大概是天天聊QQ；如果Tab键严重磨损，那估计就是个Linux高手了。因为在Linux的命令行下，Tab键起着命令补全的重要作用。

比如说，要运行ifconfig命令，可以不用完全输入这8个字母，只要输入ifc，然后按Tab键，bash就知道你要干什么了。因为所有可以运行的命令里面以ifc开头的就只有ifconfig，所以当你按下Tab键的时候，它就会替你写出完整的命令：ifconfig，

这是因为在你按下Tab键的时候，bash会去PATH变量所设置的所有目录里遍历一遍，检查了里面所有的有执行权限的文件，查到了ifconfig文件（命令其实就是个可执行文件嘛）。之所以这么快，是因为他早就把这些重要的东西缓冲进内存了，所以下次别抱怨我们Linux动不动就把你内存占满了哦。

*提示：*Linux系统的内存管理机制是尽量多地使用内存。将空闲的内存用来做缓存。因此bash遍历PATH中的路径时并不是去硬盘读取，而是直接在内存中处理。

那么如果你再少写个字母呢？比如你只写了if，然后就按Tab键，Bash遍历了一遍PATH中的路径后发现，有4个命令是以if开头的，所以他不知道你要的是哪个命令，于是就不做任何动作。这时候如果你再按一下Tab，他就会提示你：以if开头的命令有if、ifconfig、ifup、ifdown、ifquery。然后你自己看需要的是哪个，照着输入就行了，很交互吧？如果没明白，可以看图6.7所示的效果。


这样除了减少按键次数以外，还有一个好处就是你可以不必完全记住整个命令，能够记住前几个字母就可以通过Tab把整个命令回忆出来。

*** 6.2.3　翻旧账------命令的history

有了Tab，用户输入新命令的时候省事了不少，还有一个history功能，可以让用户重复以前输入过的命令的时候省心。

在终端里，如果你想输入上一次输入的命令，按一下向上箭头，就看到了；如果想要再上一次的命令，就再按一下；如果想要再再上一次的命令，就再再按一下；如果想要再再再再再上一次的命令......不怕键盘坏掉你就按吧。

好了，总该有些更靠谱的方法吧。如果想查看很久远以前的命令怎么办？请输入history。这是一个命令，可以显示之前运行过的n条命令，默认情况下n=1000。现在图形界面越来越发达，输入命令的机会越来越少，估计1000条记录都能把去年的命令显示出来了。

*提示：*也可以指定显示最近的n条命令。例如运行：
: history 20
显示最近的20条命令。

说起来history命令也没啥神奇的，他之所以能够显示曾经运行过的命令，不是因为他有啥水晶球，而是负责接收用户命令的bash会把每一条命令记录下来，写在~/.bash\_history文件中。用户输入history的时候，bash再把这个文件打开，显示出里面的内容。

*提示：*history并不像ls那样是独立的命令，而是bash的关键字。即history是否可用与所用的Shell有关，本文所述仅针对bash。

懒蜗牛输入了fdi这3个字母，然后按了一下Tab键，bash赶紧给他把命令补全，fdi变成了fdisk，懒蜗牛同学感觉省事了不少（其实就少输入了俩字母）。听说这个fdisk是用来给硬盘分区的命令，可不能瞎玩，还是先问问纯爷们儿吧。于是，一阵嚯哈哈哈的笑声又从硬盘里传来了。

*提示：*fdisk需要操作硬盘设备，因此需要加上sudo提升权限才能运行。

*** 6.2.4　more or less------命令的分页显示
*** 6.2.5　wildcards

** 6.3　Shell编程

懒蜗牛同学经过一段时间的学习，已经对我们Ubuntu系统里面的基本命令了如指掌了。接下来他又想要干点什么更有意思的事情呢？

*** 6.3.1　把命令打包执行

【日复一日】

这一日，懒蜗牛把一张SD卡插进了电脑，然后运行mount命令来挂载：
: sudo mount /dev/sdb1 /mnt/
挂载之后，把里面的东西复制了进来：
: cp /mnt/*JPG /home/me/Pictures/
之后把这些图片打成压缩包，放到一个目录里作为备份：
: tar -czvf /home/me/Backup/Pic.tar.gz /mnt/*.JPG
备份完了，把卡里的文件删掉吧：
: rm /mnt/*.JPG
最后，卸载这个SD卡：
: sudo umount /mnt/
又一日，懒蜗牛又把这张SD卡插进来了，里面有了新的文件。于是，他像前一次一样操作，又一次挂载：

然后第3天......懒蜗牛终于忍不住了。每次都要输入这么多命令很麻烦啊，能不能省事一点呢？

【高级批处理】

懒蜗牛同学回忆起了在很久很久以前，用过一个叫做DOS的操作系统，那里面有一种叫做“批处理”的东西，可以把很多条命令写进一个.bat文件里，一起执行，似乎很强大。那么我们Linux系统里有没有这种批处理呢？在我们Linux系统面前说批处理，那简直就是关公面前耍大刀，华佗门口卖止疼膏了。

您或许听说过我们Linux系统中有叫做Shell脚本的东西。这是我们Linux的骄傲，如果批处理文件是辆自行车的话，Shell脚本就是波音747！这么强大的东西，解决懒蜗牛同学现在遇到的问题，绰绰有余。

要写个Shell脚本很简单，随便用一个什么文本编辑器，写上你要执行的命令，然后保存，就可以了。比如要解决懒蜗牛同学每次敲很多相同命令的烦恼，那么可以写这么一个文本文件：
: 所有的命令写在此处.

然后保存，随便起个名字就可以，比如叫“daily_backup.sh”。到此为止这个脚本还不能运行，还得赋予这个文件“可执行”权限。就这么操作：
: chmod +x ./daily_backup.sh
这就可以了。这回这个脚本就可以运行了，就这样：
: ./daily_backup.sh

不过因为里面涉及挂载操作，所以脚本里面调用了sudo。因此运行的时候会提示输入密码。这样，用这么一个脚本就可以省去懒蜗牛同学每次敲命令的烦恼了。

*提示：*脚本文件并不要求特定的扩展名，只要是文本文件，具有可执行权限即可。但一般习惯上将脚本文件的扩展名命名为.sh。

【灵活的Shell脚本】

不过有的同学可能发现了，这样简单地把静态的命令写成脚本，并不能完全解放懒蜗牛同学。懒蜗牛每天打包备份的文件都是不一样的，但是这个脚本里，备份文件的文件名是固定的呀，这样懒蜗牛同学每次运行完这个脚本还得去改一下文件名。就不能送佛送到西，帮忙帮到底么？

当然能，咱们来把脚本修改一下：

#+BEGIN_SRC shell :results output
sudo mount /dev/sdb1 /mnt/
cp /mnt/*.JPG /home/me/Pictures/
tar -czvf ~/Backup/Pic"$(date +'%Y%m%d')".tar.gz /mnt/*.JPG
rm /mnt/*.JPG
#+END_SRC

#+BEGIN_SRC shell :results output
date +'%Z'
#+END_SRC

#+RESULTS:
: CST

或者也可在date命令后添加参数，以设定输出格式。可支持的格式参数如表6.1所示。

*** 6.3.2　规范的Shell脚本

虽然懒蜗牛同学用一个类似批处理的脚本文件解决了他每次都要手动敲很多命令的烦恼，但是他写的这个所谓的脚本还是太初级了，一点都不专业。

【要有必要的注释】

【指明使用哪个Shell】

: #! /bin/bash

这又是什么意思呢？有的同学说：我知道，这个以“#”开头，所以只是个注释。但是，很不幸，这不是注释。

确实，我说过，以“#”开头的是注释。但是，“#!”放在一起还出现在脚本第一行，那就不是注释啦！这一行的意思是用来指明这个脚本所需要的Shell。

前面说过，我们Linux系统中有很多的Shell，比如bash、tcsh、ksh等。这些不同的Shell，他们的特性、语法什么的，大都是不同的。那么一个脚本程序就有必要说明一下，这是个bash的脚本，还是tcsh或者别的什么Shell的脚本。就好像你写了一段代码，总要告诉人家你写的是C语言的代码还是Java语言的代码吧。

当然，你可以直接告诉系统，说这个脚本是一个bash的脚本，请用bash来解释这个脚本。那么你就需要这样运行你写的脚本（比如脚本叫做myscript.sh）：

【使用函数】

另外，Shell脚本也像大多数编程语言一样支持函数。如果你有一段代码需要在脚本里执行多次，不必反复地写多份，而是把它们写成一个函数，直接调用即可。比如这个自动备份的脚本：

#+BEGIN_SRC shell :results output
#! /bin/bash
backup_pictures ()  {
sudo mount /dev/sdb1 /mnt/
cp /mnt/*.JPG /home/me/Pictures/
tar -czvf ~/Backup/Pic"$(date +'%Y%m%d')".tar.gz /mnt/*.JPG
rm /mnt/*.JPG
}
#+END_SRC

把备份的动作写成一个backup_picture()函数后，需要进行备份的时候，在脚本里调用这个函数就可以了。脚本在执行的时候，会先略过写进函数里的部分，直到执行到某一行调用了这个函数，再回来执行。

*** 6.3.3　在Shell中使用变量

作为一种编程语言，少不了变量。我们Linux系统中强大的Shell自然也要支持变量。

【用户变量------信手拈来】

【变量类型------只有字符串】

有的同学可能注意到了，我们的脚本里并没有给变量明确声明一个类型。这是因为Shell的变量只有一种类型，就是字符串。没有什么整型、浮点型之类的概念。咱们再用一个简单的脚本说明一下：
#+BEGIN_SRC shell :results output
num=8
num="$num + 2"
echo $num
#+END_SRC

#+RESULTS:
: 8 + 2

运行这个脚本，会看到最终打印出来的num的值是“8+1”，而不是“9”。因为bash这家伙压根就没长数学的脑子！他只会把变量的值作为字符串处理。

可是虽然bash没长数学脑子，但是我们的生活不能没有数学啊，遇到需要计算的问题时怎么办呢？没关系，bash不会算，有人会算，就是expr命令。

expr专门用于Shell脚本中，负责对几个字符串变量进行数学计算。比如刚才这个脚本，我们实在是想计算num+1，看看到底得多少。那么就可以这样：

#+BEGIN_SRC shell :results output
num=8
num=$(expr $num + 1)
echo $num
#+END_SRC

#+RESULTS:
: 9

这样就可以如愿看到数字9了。

【环境变量------哪都能用】
# flask便是大量应用环境变量
刚才我们随手定义的变量，可以叫做用户变量。自己定义自己用就好了。除了用户变量之外，还有一个重要的概念，就是环境变量。比如我们之前遇到过的PATH变量、HOME变量等。

所谓环境变量，有点类似于C语言里面的全局变量，它在整个系统中都有效。用户变量只在这一个脚本内有效，出了这个脚本，这个变量就没了。而全局变量一旦设定，可以在整个系统中的任何时候、任何地方进行访问。要让一个变量成为全局变量很简单，只要在变量赋值语句前加上export，类似这样：

#+BEGIN_SRC shell :results output
export env_num=8
ech $env_num
#+END_SRC

运行这个脚本，你自然会看到输出一个“8”，当然这并不是环境变量的特点。环境变量的特点是你运行完这个脚本以后，再输入命令：

依然会看到这个变量的值还是“8”。

*提示：*环境变量在当前会话结束后失效。

当然，像这样创建出一个环境变量的需求并不多，一般我们在写Shell脚本的时候，多数是使用或者修改已经存在的环境变量。比如通过$TZ变量获取本系统所在的时区；通过$HOME变量获取当前用户的家目录地址等。比如懒蜗牛同学的自动备份脚本，现在每次都是固定往/home/lanwoniu/backup目录下备份，很不灵活。这里就可以应用全局变量，改成这样：
#+BEGIN_SRC shell :results output
#! /bin/bash
backup_pictures ()  {
sudo mount /dev/sdb1 /mnt/
cp /mnt/*.JPG $HOME/me/Pictures/
tar -czvf ~/Backup/Pic"$(date +'%Y%m%d')".tar.gz /mnt/*.JPG
rm /mnt/*.JPG
}
#+END_SRC


如此一来，就不光是lanwoniu用户可以用这个脚本了，任何用户都可以用这个脚本进行备份，提高了灵活性。

【特殊变量------一堆符号】

除了普通的用户变量和环境变量外，还有一些特殊的变量。这些特殊变量特殊在如下几方面。

  长得就特殊。
　脚本执行时自动被设定。
　不可修改。
# 总结得好.
下面我们就看看这些变量的样子，主要就是下面这些。

　$n------这里，n是一个从0到9的数字。这个变量代表了执行本脚本所加的第n个参数。n=0时代表脚本本身的名称。这个变量跟C语言中的argv[]有点类似。

　$*------这个变量代表执行本脚本所加的所有参数（不包括脚本名本身）。

　$#------执行本脚本所加的参数个数，类似C语言中的argc。

　$$------这个脚本的PID。
#+BEGIN_SRC shell :results output
echo $n
echo $*
echo $#
echo $$
pstree -asp $$
#+END_SRC

#+RESULTS:
:
:
: 0
: 32265
: systemd,1 splash
:   `-emacs,1719
:       `-bash,32265
:           `-pstree,32266 -asp 32265

【变量赋值】

变量赋值，除了可以直接写出初值之外，还可以将命令的运行结果赋给变量。比如咱们之前用到过的“`”符号，可以调用指令并获得该指令的输出。那么同样也可以把这个输出赋值给一个变量。还拿懒蜗牛同学的备份脚本做例子，可以再这样修改一下：

这回我们把当前的日期，存储进了today这个变量，这样如果要多次用到日期，就不必每次都调用date命令了，直接从变量中读取就可以了。

***
 6.3.4　Shell中的条件判断

所有编程语言，都少不了条件判断语句。我们的Shell也是可以支持简单的条件判断的。

【if和fi】

最常见简单的条件判断，就是if语句了。Shell中的if语句比较有个性，if后面的“表达式”部分必须被足够的空格分隔得分崩离析才可以。比如咱们看下面这个脚本（建议把这个脚本命名为kill）：
#+BEGIN_SRC shell :results output
if [ "$1" = "me" ]; then
    echo "Hi"
else
    echo "Hello $1"
fi
#+END_SRC

#+RESULTS:
: Hello

*提示：*要注意这个脚本中“[”符号前边和后边、“"$1"”后边、“=”后边、“]”前边，都要有空格。否则脚本错误。

这个脚本的运行效果就是这样：

好，我们暂时不去讨论这个脚本中的虐畜及自虐倾向，只讨论里面的if语句。if的工作，就是根据后面命令的返回值，来判断程序应该走哪条分支。另外，if语句一定要有对应的fi作为结尾（相当于endif）。

这里大家可能有点困惑：if后面的命令？if后面不是一个表达式么？哪来的命令呢？

好，那我们写个更简单点的脚本说明一下。
#+BEGIN_SRC shell :results output
if ls -l /; then
    echo "ls return true!"
else
    echo "ls return false"
fi
#+END_SRC

#+RESULTS:
#+begin_example
total 72
lrwxrwxrwx   1 root root     7 Oct 20 00:36 bin -> usr/bin
drwxr-xr-x   4 root root  4096 Nov 13 14:08 boot
drwxrwxr-x   2 root root  4096 Oct 20 00:38 cdrom
drwxr-xr-x  20 root root  4360 Nov 13 09:05 dev
drwxr-xr-x 140 root root 12288 Nov 13 14:16 etc
drwxr-xr-x   3 root root  4096 Oct 20 00:38 home
lrwxrwxrwx   1 root root     7 Oct 20 00:36 lib -> usr/lib
lrwxrwxrwx   1 root root     9 Oct 20 00:36 lib32 -> usr/lib32
lrwxrwxrwx   1 root root     9 Oct 20 00:36 lib64 -> usr/lib64
lrwxrwxrwx   1 root root    10 Oct 20 00:36 libx32 -> usr/libx32
drwx------   2 root root 16384 Oct 20 00:35 lost+found
drwxr-xr-x   3 root root  4096 Oct 20 00:49 media
drwxr-xr-x   2 root root  4096 Oct 17 20:22 mnt
dr-xr-xr-x 220 root root     0 Nov 13 09:04 proc
drwx------   6 root root  4096 Nov 13 14:25 root
drwxr-xr-x  33 root root   980 Nov 13 14:17 run
lrwxrwxrwx   1 root root     8 Oct 20 00:36 sbin -> usr/sbin
drwxr-xr-x   4 root root  4096 Oct 20 13:43 snap
drwxr-xr-x   2 root root  4096 Oct 17 20:22 srv
dr-xr-xr-x  13 root root     0 Nov 13 09:04 sys
drwxrwxrwt  21 root root  4096 Nov 13 17:09 tmp
drwxr-xr-x  14 root root  4096 Oct 17 20:24 usr
drwxr-xr-x  14 root root  4096 Oct 17 20:32 var
ls return true!
#+end_example

运行这个脚本，可以看到Shell会调用“ls --l /home”这条命令，列出/home目录下的文件，然后因为if判断到“ls --l /home”这条命令返回了结果“真”（因为命令执行成功嘛），因此显示出了“ls
return true！”这个字符串。如果/home这个目录不存在，ls命令就会执行失败，返回“假”，于是if根据这个返回值判断，程序运行else对应的语句，就会打印出“ls
return false！”这个字符串。

这下大家是不是明白些了？if与“;”号之间的，就是一条Shell中的命令而已。这个命令返回真，则进入if对应的分支；返回假，则进入else对应的分支（如果有else的话）。那么刚才那个kill脚本里的“["$1" = "me"]”这段难道也是命令么？答对了！这就是命令。
“ls -l home”中，“ls”是命令名，后面是两个参数：“-l”和“/home”。
“[ "$1" = "me" ]”中，“[”是命令名！后面有4个参数，分别是“"$1"”，“=”，“"me"”，以及“]”。
没错，“[”是一个无比简练的意想不到的命令。这条命令就在/usr/bin/下，用ls可以看到。它跟apt-get、gcc等命令一样，是一条实实在在的Shell命令。这条命令的作用，就是判断后面参数所组成的表达式的值（真或假），并返回。“[”命令要求输入的最后一个参数必须是“]”（这主要是为了你们人类看着顺眼点）。

这样就可以理解一个问题了：既然“[”后面的所谓的变量、常量、“]”号等，对于“[”命令来说都是它的参数，那么这些参数之间必然都要有空格。所以Shell脚本中的if语句必须写成类似这个样子：
#+BEGIN_SRC shell :results output
if [ $a = $b ]; then
if [ ! $a = $b ]; then
#+END_SRC

而不能写成下边这样：
#+BEGIN_SRC shell :results output
if [$a=$b]; then
if [ !$a = $b]; then
#+END_SRC

“[”命令不仅可以判断相等条件，还可以判断很多复杂的条件，如表6.2所示。

*表6.2　常用判断参数*

[[./Images/image00526.jpeg]]

*提示：*“-eq”与“=”的意义不同。“-eq”用于判断数值上的相等，“=”用于判断字符串的完全匹配。例如：$a的值为“03”，$b的值为“3”，则“-eq”将判断这2者相等，而“=”将判断这2者不等。“!=”和“-ne”同理。

有了if命令，我们就可以把懒蜗牛同学的自动备份脚本再进一步完善一下：

[[./Images/image00527.jpeg]]

【case】

类似于C语言的switch，case语句，Shell中也有case语句来实现多分支的判断。看看下边这个小脚本：

[[./Images/image00528.jpeg]]

这个脚本的运行结果估计您也能看明白，就是个英语没学好的卖萌脚本。通过这个脚本可以比较好地理解case的作用：就是用某个变量的值，去匹配下边的几个“)”符号前的字符串。如果某行匹配，则执行该行的语句，直到发现双分号“;;”时停止。如果没有找到匹配的，就执行“*)”一行的内容，遇到双分号时停止。

*提示：*“*)”一行也可以不存在，则匹配不到任何字符串时就不执行任何命令。

*** 6.3.5　Shell中的循环语句

【for循环】

Shell脚本同样支持for循环。不过跟多数语言的for循环的写法不太一样的是，Shell脚本中的for循环有种很有个性的格式：
#+BEGIN_SRC shell :results output
for v in v_list
do commands
done
#+END_SRC

其中，“变量”就是一个变量，这个变量一般会在do和done之间的命令列表中用到。而这个“名字列表”则是一个由空格分隔的字符串列表。Shell在执行for循环时，每次依次从“名字列表”中取出一个字符串赋给“变量”作为变量的值，并执行“命令列表”中的命令。另外，在写for语句时，也可以省略in及名字列表部分，这表示用当前的位置参数来代替这时的名字列表。

这样说很枯燥，写个小程序吧：
#+BEGIN_SRC shell :results output
for num in 1 2 3 4 5 6 six
    do echo "num = $num"
done
#+END_SRC

#+RESULTS:
: num = 1
: num = 2
: num = 3
: num = 4
: num = 5
: num = 6
: num = six

运行这个脚本，会看到这样的输出：


这样就很明白了吧。这种方式用于批量处理文件会很方便。当然，如果你需要C语言中那种for循环，也是可以的。不过写法稍稍有点不一样，要用两个小括号。类似这样：

[[./Images/image00532.jpeg]]

这里就不做过多解释了。像其他语言中一样，num的值从1开始，依次累加，直到不满足“num<7”这个条件。

【while循环】

while循环也是经常用到的一种结构，它的用法大约如下：

[[./Images/image00533.jpeg]]

其中，“循环条件”的写法也是和if语句一样的。多数情况下使用“[”命令来计算条件并返回结果，这里不再赘述。

无论是while循环还是for循环，都可以使用break和continue指令。其中break指令用于跳出当前循环体，执行后面的操作；continue指令用于忽略本次循环，直接回到循环体的开始位置，执行下一次循环。这和其他常用编程语言中的break和continue是一样的。

*** 6.3.6　扩展阅读：Linux的文件权限

这一回中，我们提到了写一个脚本，要赋予它可执行权限才能执行。有的同学可能对这个权限还不是很明白，那咱们就仔细说说Linux下的文件权限。

【简单的权限------只有3种】

熟悉Windows系统的同学应该都知道，Windows下可以对文件设置很详细的权限。谁可以读这个文件，谁可以写这个文件，等等，如图6.8所示。

[[./Images/image00534.jpeg]]

图6.8　Windows设置文件权限

我们Linux系统中的权限相对简单很多，对于一个文件（包括文件夹），只有3种权限------读、写、执行。

对于一个普通的文件，拥有对这个文件的读权限，就是可以读取里面的内容。对于一个目录（目录也是特殊的文件，在我们Linux世界，一切皆是文件），拥有对这个目录的读权限，就意味着可以查看目录中的文件列表（也就是可以用ls命令看里面都有什么东西）。

对于一个普通的文件，拥有对这个文件的写权限，就是可以改变里面的内容，增加、修改、删除，这些都算改变。对于一个目录，拥有对这个目录的写权限，就意味着可以删除、移动或者添加目录里的文件或者目录。也就是说，对于目录文件，里面的文件列表就相当于这个目录文件的“内容”，有写权限就是可以修改内容。

*提示：*要注意的是，对于一个普通文件，有写权限并不代表可以删除这个文件。要对这个文件所在的目录有写权限才可以删除这个文件。

对于一个普通的文件，拥有对这个文件的执行权限，就是可以运行这个文件，比如我们写的脚本。对于一个目录，拥有对这个目录的执行权限，就意味着可以进入这个目录（比如用cd命令）。如果一个目录有执行权限，但是没有读权限，就意味着你可以通过cd命令进入这个目录，但是进去之后运行ls发现什么也看不见。

*提示：*在赋予一个文件可执行权限时，并不会对这个文件的格式进行检查。也就是说，你完全可以赋予一个JPEG格式的图片文件可执行权限而不会收到任何错误提示。当然，当你真的试图运行这个图片文件的时候，肯定会报错的。

【面对的用户------只有3类】

现在，这3种权限我们明白了。但是权限离不开对用户的识别，Windows下可以细致地针对某一个用户或者某一个组来分配特定的权限，那么Linux呢？本着简洁高效不折腾的原则，我们Linux系统只对3类用户设置权限。

注意我说的是3类，可不是3个用户哦。哪3类用户呢？就是文件的所有者、群组、其他。

在我们Linux系统中，每个文件都明确地属于一个用户。比如我们这里，/home/lanwoniu目录下的文件基本上都属于lanwoniu用户；/etc、/usr、/bin这些系统目录中的文件，都属于root用户等。一个文件所属于的那个用户，我们就叫他所有者吧。Linux系统中，可以对一个文件的所有者，设置一套权限。比如一个文件叫做“懒蜗牛记账.odt”，属于lanwoniu用户。那么可以设定，对于lanwoniu用户，这个文件可以被读和写，但不能执行（一个文档而已，当然不能执行）。

文件除了属于一个用户外，还要属于一个组。就好像你家里，你的电脑是属于你的，别人用不了（不知道开机密码）。但同时它也是属于你们家的，你爹虽然不能打开它，但是他有权把它卖掉（让你不好好学习，哼！）。Linux系统可以对文件所属的组设置一套权限。还比如“懒蜗牛记账.odt”文件，它除了属于lanwoniu用户外，还可以属于family组。那么就可以设定，对于family组的用户，这个文件可以被读，但不能写和执行。

除了所有者和群组之外的用户，就是“其他”了。可以对其他用户设置一套权限。例如除了lanwoniu用户和属于family组的用户以外，其他用户既不能读，更不能写和执行那个“懒蜗牛记账.odt”文件。就像你家邻居赵大婶完全不能够对你的电脑进行任何处理一样。

【设置权限的命令------chmod】

说了这么半天了，可能有人着急问：到底怎么针对用户设定文件的权限呢？好，下面我们就来介绍这个问题，这需要一个命令------chmod。

chmod是专门用来修改文件权限的命令，它的使用格式大约是这样：
: chmod +xrw file

其中，“设置权限的对象”，就是指所有者、群组、其他这3类。当然你不能在命令里写中文“所有者”，而是用字母表示：u代表文件的所有者；g代表文件的群组；o代表其他。而文件的权限就是读、写、执行，当然也用字母表示：r表示读，w表示写，x表示执行。

比如我想给懒蜗牛日记.odt文件设置权限，我想给这个文件的所有者（也就是lanwoniu这个用户）增加可执行权限（就是个实验，别管这个动作多么抽风），那么就可以运行如下命令：
: chmod u+x file

其中，u代表要对所有者的权限进行操作；+号代表要增加权限；x代表要增加的是执行权限。那么如果我想去掉family组内的成员对这个文件的读权限（日记不能瞎让别人看），那么就可以运行这样的命令：
: chmod g-r file

其中，g代表要对群组的权限进行操作；-号代表要去掉权限；r代表要去掉的是读取的权限。于是family组的成员就不能够读取懒蜗牛同学的日记了。

或者，也可以在图形界面中对文件的权限进行设置。右击要设置权限的文件，在弹出的快捷菜单中选择“属性”，出现文件属性对话框。切换到“权限”标签，就可以看到对文件设置权限的界面了，如图6.9所示。

** 6.4　正则表达式

在使用Shell命令或者Shell编程的时候，经常会用到一种叫做“正则表达式”的东西。有了它，很多事情事半功倍。作为一名想成为高手的菜鸟，懒蜗牛同学觉得有必要了解一下这个东西。

*** 6.4.1　什么是正则表达式

正则表达式（RegularExpression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。听着挺迷茫的吧，那就说简单点：正则表达式就一段火星文似的字符串，这段字符串可以用来表示有一定规律的很多段字符串。

最初的正则表达式，出现在理论计算机科学的自动控制理论和形式化语言理论中（完全听不懂的举手）。在这些领域中有对计算的模型和对形式化语言描述与分类的研究。20世纪40年代，WarrenMcCulloch与WalterPitts将神经系统中的神经元描述成小而简单的自动控制元。到20世纪50年代，数学家StephenColeKleene利用称为“正则集合”的数学符号来描述此模型。后来，UNIX的创始人，KennethLaneThompson将此符号系统引入编辑器QED，然后是UNIX的编辑器ed，并最终引入了grep。自此，正则表达式被广泛地使用于各种UNIX或类UNIX系统的各种工具中。

*** 6.4.2　初识正则表达式

懒蜗牛同学想学习正则表达式，也不是一时兴起。前几天，他确实遇到了类似的需求。

话说那一天，懒蜗牛拿到一个脚本文件，里面大量使用了sed命令。懒蜗牛同学想要复制里面的所有sed命令，存入另一个文件里，作为学习sed命令用法的参考。经过学习和研究，懒蜗牛了解到有个grep命令可以完成这个操作，他的用法大约是这样：

: grep pattern file

这样的命令所做的事情，就是在“文件名”所指定的文件中，查找带有“字符串”所指定的内容的行，并输出到标准输出。当然，懒蜗牛同学是想存成文件，于是就加了个输出转向，运行了这个命令：
: grep 'sed' .

*提示：*“>”可以将原本输出到标准输出的内容（即打印到屏幕上的内容），转向到一个文本文件中。并且如果文件已经存在，它将覆盖掉文件原有内容。如果不想覆盖文件原有内容，可以使用“>>”符号，代替“>”，如此则会在文件末尾追加新的内容。

这样，就把learn.sh脚本中，所有带有sed字样的行，全部输出到了sed\_command.txt文件中。但是当懒蜗牛打开sed\_command.txt查看的时候发现了问题。所有带有sed命令的行，固然是都写进来了，但同时还有很多跟sed命令无关的行，也跑了进来。比如这一行注释：


还有：


grep之所以会将这些行匹配出来，是因为它们确实包含了“sed”这个关键字，只不过不像懒蜗牛想象的作为单独的一个命令而已。所以这并不能怪罪grep不智能，而是懒蜗牛陈述的要求并不准确。懒蜗牛的要求如果用准确一点的人类语言描述，应该是这样：查找所有包含sed作为完整单词的行。

当然你用人类语言说，grep肯定听不懂。于是，这时候就需要正则表达式出场了。我们需要使用“\b”元字符，这个字符代表了单词的开头或者结尾。那么懒蜗牛要查找的东西，就应该这样表示：

[[./Images/image00543.jpeg]]

这样，像kissed、used这样的词，就不会被匹配到了。这里，我们写的“\bsed\b”就是一个正则表达式。除了“\b”外，还有很多元字符，各代表不同的意义，如表6.3所示。

*表6.3　元字符*

[[./Images/image00544.jpeg]]

*提示：*更精确地说，\b是匹配这样的一种位置------它的前一个字符和后一个字符，有一个是，但不全是\w（一个是，一个不是或不存在）。

*** 6.4.3　强大的正则表达式

又有一回，那位和懒蜗牛同学聊天的MM遇到了麻烦。她需要从她写的日记中找到一个固定电话的号码。但是记忆力如此差的她，竟然完全不记得这个电话号码大约出现在哪几天的日记中。于是，她希望能够找出日记中出现过的所有电话号码，然后她根据上下文判断哪个才是需要的。

【使用反义字符】

这样的工作，懒蜗牛同学自然毫不犹豫地包揽下来。在收到MM传来的足有3
MB大的diary.txt文件后，懒蜗牛运行了这个命令：

[[./Images/image00545.jpeg]]

咱已经知道了，\d可以匹配一个数字。这个命令的意思很明白：查找diary.txt文r件中，所有出现了连续8个数字的行。

运行之后，懒蜗牛得到了一些输出，但是好像依旧比较乱。因为一些手机号、QQ号、各种账号之类的也被搜出来了。它们虽然都是8个以上连续的数字，但毕竟它们“包含”了连续的8个数字，所以被grep找出来了。

那么如果要精确匹配“有且只有8位的数字”该怎么办呢？这就要用到正则中的反义了。常用的反义字符如表6.4所示。

*表6.4　反义字符*

[[./Images/image00546.jpeg]]

那么，对于懒蜗牛同学的需求，就应该运行这样的命令：

[[./Images/image00547.jpeg]]

这个命令用人类语言描述就是：查找diary.txt文件中，所有出现了连续8个数字，且此8个数字的前后1个字符都不是数字的行。这样就能更准确地定位1个固定电话的号码了。

【使用重复】

不过这样写连续的8个“\d”还是有点累，其实这里可以精简一下，写成这样：

[[./Images/image00548.jpeg]]

其中，“{8}”的意思，就是前一个字符重复8次（\d看作一个元字符）。类似的重复还有几个，如表6.5所示。

*表6.5　常用的重复*

[[./Images/image00549.jpeg]]

举几个例子吧。比如正则表达式“go*gle”可以匹配“ggle”、“gogle”、“gooogle”、“goooooooooooogle”等。反正就是中间有多少个o、有没有o都没关系；而“go+gle”则不能匹配“ggle”，它代表必须有至少一个o；“go?gle”就只能匹配“ggle”和“gogle”；“go{2,4}gle”就只能匹配到“google”、“gooogle”、“goooogle”这3种情况了。

【使用中括号】

懒蜗牛终于找出了所有的“出现了连续8个数字，且此8个数字的前后1个字符都不是数字”的行，并让MM过目。结果，MM很不好意思地表示：这些好像都不是，那个电话号码有可能写成了xxxx
xxxx的格式，也没准是xxxx-xxxx，或者是带区号的（xxx）xxxx-xxx......

从昏厥中苏醒过来的懒蜗牛同学毫不气馁，继续用正则表达式满足MM的需求。区号不区号的先不去管，先看看xxxx
xxxx和xxxx-xxxx怎么匹配吧。其实也简单，使用中括号就可以了，像这样：

[[./Images/image00550.jpeg]]

这样的正则表达式用人类语言描述就是“前面有且仅有4个数字，中间有一个横杠‘-'或者空白，后面有且仅有4个数字的”这么一个字符串。

其中中括号的意思，是表示里面的字符都是或的关系。例如“[abc]”可以匹配a、b、c中的任意一个（且仅有一个）字母。或者也可以写一个范围，例如“[a-z]”可以匹配任何一个小写的字母。“[0-9]”就完全相当于“\d”了。

咱们还是举例子吧。比如“b[ae]d”这样一个表达式，就可以匹配bed和bad这两个字符串；而“[a-c]an”可以匹配aan、ban、can这3个字符串。

在精确地匹配了xxxx-xxxx这种形式的电话号码后，懒蜗牛同学终于找到了MM想要的电话。因此，在接下来的几天之内，他一直都对正则表达式赞不绝口。不过，他用到的这点功能，不过是正则表达式中的最初级用法，沧海一粟尔。

*** 6.4.4　无处不在的正则表达式

刚才咱们看着懒蜗牛同学折腾了这么半天，都是在使用grep命令时应用正则表达式。其实正则表达式的用途相当广泛，基本上在我们Linux系统里，你能想到的地方都能够支持正则表达式。比如常用的查找文件的find命令、已经见识过的grep命令、编辑字符流的sed命令，甚至连ls命令都是支持正则表达式的。还有Vim编辑中，Emacs编辑器中，都有支持正则表达式的操作。Shell编程中更可以用正则表达式了。

可以这么说，在我们Linux系统里，只要你觉得某个地方可以用正则表达式来简化操作、提高效率，那么这个地方就一定支持正则表达式。

** 6.5　多彩的Shell
# 在shell中能做的事情.
懒蜗牛逐渐开始适应了纯终端的操作，于是他有个想法：在这个黑漆漆的界面中，搭建起一个可用的环境，这样以后开机就可以不进图形界面，直接用命令行的软件来做各种事情，可以更高效，更快速。他决定，用一周的时间来完成这件事情。

*** 6.5.1　懒蜗牛同学的计划

起初，懒蜗牛来到混沌漆黑的命令行。

界面是黑漆漆一片，ls还会出些菱形的方块块，懒蜗牛的手指游弋在键盘上面。

懒蜗牛说：“要有中文！”就有了中文。

懒蜗牛看中文是顺眼的，有中文，有英文，没有了乱码。这是头一日。

懒蜗牛说：“要有声音！打破寂静的黑夜。”

懒蜗牛就让命令行里发出美妙的乐声，这是第2日。

懒蜗牛说：“要有窗，看到外面的世界。”于是有了浏览器，懒蜗牛可以重新看到那些网络上的奇花异草，光怪陆离。有了通信工具，懒蜗牛又可以把这些光怪陆离，异草奇花分享给朋友们，这是第3日。

懒蜗牛说：“要有色彩，有图，才有真相！”于是就有了图。

图片为黑白的世界带来了色彩。美好的、丑陋的、思念的、怀旧的、唯美的、憧憬的、现实的、抽象的，各种的图片，懒蜗牛微笑了。这是第4日。

懒蜗牛说：“要动起来，要鲜活的世界。”于是，就动起来了，这是第5日。

第6日，懒蜗牛说，我累了，要休息。于是，就没有于是了，这小子没开机。

众人：合着懒蜗牛就是传说中的上帝？

我说：不是，上帝第7日才休息。

众人：废话，那是上帝没赶上实行双休日。

我估计这么说您还是听不懂，那我慢慢给您讲解。

*** 6.5.3　在Shell下播放音乐

周二，懒蜗牛得到了比较顺手的有中文环境的命令行之后，又开始踏上了新的寻觅旅程------寻觅音乐。

在图形界面下的时候，有很多播放软件可以让懒蜗牛浸泡在音乐的海洋里。那在字符界面下呢？想想也不应该有问题呀，放音乐又不需要图形界面是不是？字符界面下播放音乐还是不成问题的，Mplayer就可以播放各种音频，还有个Mpg123也可以放出声来。不过他们俩虽然能放出声音来，毕竟不专业，怎么也得有个播放列表、歌曲管理的功能吧。于是，懒蜗牛选择了moc。

*提示：*Gnome界面下，鼠标悬停在音乐文件上就可以预览其内容，这个功能就是通过调用Mpg123实现的。

【终端里的窗口】

moc是一个字符界面的音乐播放软件。有好奇而OUT的同学可能会猜想：字符界面播放音乐，那是不是要输入命令才播放音乐呢？比如输入play，就播放；输入stop就暂停；输入load
xxxx.list就导入播放列表这样？要是30年前没准能有这种软件，不过在现在这么简洁高效的年代，怎么可能用这么难用的东西呢？虽说是字符界面，但是不代表就不能有窗口！是的，你没听错，在字符界面下也能画出窗口来！怎么画？用字符拼！

我们知道，ASCII码中有一些特殊的字符，什么横杠、竖杠、拐弯杠什么的。用这些特殊的符号，加上可控制的字符底色，可以拼接出有窗口效果的终端显示的界面。

当然，如果每个程序都自己写代码去拼肯定是很费事的，所以崇尚共享的我们Linux系统提供了一套专门在字符界面下画窗口的函数库，叫做ncurses。调用这个库画窗口就跟用gtk+提供的接口在图形界面下画窗口类似，所以编程人员不必在意怎么用各种字符拼出好看的窗口，只要调用ncurses就行了。ncurses的前身是curses，大名鼎鼎的Vi就是用它实现的界面。

【moc的操作】

moc就是一个基于ncurses的、字符界面的音乐播放软件。直接找apt就可以安装。懒蜗牛装了之后赶紧运行一下试试。虽然包名叫moc，不过运行的命令是mocp。运行起来之后如图6.11所示。

[[./Images/image00560.jpeg]]

图6.11　mocp运行界面

运行起来之后，左边是文件列表窗口，可以通过上下箭头选择相应目录，按回车键进入，最上面的那个“..”表示上一级目录，这个都知道吧，不知道的面壁去。

选到要听的MP3文件按A键将文件加入右边的播放列表。把MP3都加进来之后，用Tab键，切换左边的文件列表和右边的播放列表。按回车键就可以播放了。然后还有些快捷键比较常用，介绍如下。

　h键，打印出使用说明。

　左右方向键可以调节播放的进度。

　“,”、“.”用来控制音量，“,”键为减小，“.”键为增大。

　s键停止播放。

　b、n键分别是跳到“上一首”、“下一首”曲目。

　R和X键用来控制重复播放和循环播放（注意大小写的区别，所谓按R键，就是按下Shift然后按下r键，也就是在终端打出大写的R的操作顺序）。

有人说，这个播放软件把整个屏幕都占了，我还怎么干别的呀？简单，你有如下3个选择。

（1）不干别的了。

（2）按下Ctrl+Alt+F2组合键，换个终端。当然，这两个方法都是比较弱智的，呵呵。

（3）其实mocp是一个Server和前端分离的软件，你可以按q键退出前端界面，然后该干啥干啥，音乐继续播放，想再回来就再运行mocp。如果想彻底退出，就按Q键，也就是按住Shift再按q键。

好了，懒蜗牛已经添加好播放列表，按下回车键，音箱里传来了悠扬的乐曲。

*** 6.5.4　在命令行中上网

周三这天，懒蜗牛要解决一个关键的应用------上网。平时在图形界面下，最忙碌的就是狐狸妹妹Firefox，基本上只要电脑开着，内存里就少不了狐狸妹妹的身影。要是命令行下不能上网，那还不得把懒蜗牛同学憋屈死。

不过命令行毕竟是命令行，功能还是有限的，所以对浏览器的要求也不能太高，简单的文字的网页还是没问题的。图片呢，实时的显示也不行，不过勉强可以调用别的程序来看一下。但是像Flash、在线的视频音频这类的就不用想了。好在懒蜗牛同学比较通情达理，也就是想看看文字的东西和一些简单的图片，所以，有那么几个候选软件是可以满足懒蜗牛要求的：w3m,  lynx, links。

【命令行中的浏览器------w3m】

这3个软件都是可以直接叫apt去装的，很省事。但经过懒蜗牛的试用，lynx和links对中文的支持都相对差点，并且他们都不能显示图片，所以被pass了，w3m华丽胜出。不过w3m也不是天生就会显示图片，他需要一些工具，这些工具被打成一个包放在软件源里，包的名字叫做w3m-img，懒蜗牛让apt给w3m搬来了这个工具包之后，w3m才拥有了显示网页上的图片的能力。

当然，w3m显示图片跟moc显示窗口可不一样，可不是拿特殊字符拼出图片，如果是那样，整个屏幕顶多拼个超级玛丽出来，连蘑菇都没地方显示了，估计就是图6.12所示的这个效果。

[[./Images/image00561.jpeg]]

图6.12　字符拼成的超级玛丽

要显示正经的JPG这样的图片，还是需要framebuffer的支持。framebuffer基本上是能够使命令行界面变得多姿多彩的最基本、最重要的条件。懒蜗牛要访问的网页无疑基本上都是中文的，所以需要能够支持中文的终端。咱之前说过了，就是fbterm。于是，懒蜗牛就在fbterm下运行起了w3m。

【jfbterm中的w3m】

不过，天有不测风云日，人有无意失手时，软件也有偶尔不大正常的时候。

虽然在某些系统某些机器上，fbterm下的w3m（前提是装了w3m-img哦）确实可以正常地显示出图片，不过不知道为什么在我们这里，这个w3m和fbterm配合了半天也没配合上。他们一运行起来就听着他们俩不停地吵吵：

“fbterm，快点把fb0设备给我，我要显示网页上这个图片。”

“你怎么又要啊，我这边的中文还没显示好呢。”

“你怎么那么多中文要显示啊？”“你这不废话么，我显示的都是你的网页，显示多少中文还不是你说了算。”“别急别急，你显示完了赶紧给我用。”“等等，等等，再有3毫秒就完了。”

“靠，懒蜗牛翻篇了。刚才那个图片翻过去了，白算了半天。”

“好了我用完了，给你用去吧。”

“用什么用，他已经翻到下一页了，又一个新的图片，我先得解码看看这个图片里是什么才知道该显示什么嘛。”

总之，这俩软件从来没对上过，于是懒蜗牛就没看到图片。

*提示：*Ubuntu
10.04中，开启fbterm后会因/dev/fb0设备被占用而导致w3m无法显示图片。

不过后来懒蜗牛还是找到了解决办法，那就是换了另一个终端，其实跟fbterm还有点关系，叫做jfbterm，也一样可以支持中文。在jfbterm下，w3m终于可以正常显示图片了，虽然效果肯定不如狐狸的好看，但能在不开图形界面的情况下看到图片，也算奢侈了，就是类似图6.13这样的效果。

[[./Images/image00562.jpeg]]

图6.13　用w3m访问Google

*** 6.5.5　在Shell下看图片

周四，懒蜗牛又一次摄影归来，插上SD卡，运行mount命令挂载并且把照片cp到主目录中的照片文件夹。之后，就开始研究命令行下到底用什么来看照片了。

要看照片无疑还是需要framebuffer的支持，这一点咱就不说了。那么那个能够利用framebuffer设备来显示图片的软件是谁呢？那可是一个大名鼎鼎的家伙------fbi！

别激动，这个fbi不是某大叔的啥啥调查局，只是Linux下的一个FrameBuffer
Image
Viewer，也就是基于framebuffer的图像查看器而已。这个查看器可以查看各种常见的图片格式，全屏显示、缩放、幻灯片模式播放、旋转，都没问题，更复杂的什么调节对比度、亮度啥的自然就不行了，毕竟人家只是个查看器嘛。懒蜗牛复制好了照片后，用cd命令切换进入存着照片的目录，运行了：

[[./Images/image00563.jpeg]]

这个命令大家应该能看懂吧，就是让fbi去查看当前目录下的所有的JPG文件的意思。顺便复习一下，“*”这个通配符是由bash来处理的，就是说，懒蜗牛输入了这个命令后，bash先把命令改成：

[[./Images/image00564.jpeg]]

这样的形式，然后再按照这个命令去叫醒fbi，告诉他要去显示这么多图片。然后就是fbi起床，一个一个地显示这些图片，当懒蜗牛按“-”、“+”键的时候就对图片进行缩小、放大。按下PageDown键就播放下一张，偶尔遇到竖着拍的照片可能还需要按r或者l键旋转一下，总之，懒蜗牛在悠然轻松地欣赏照片的过程中度过了一晚上。

*** 6.5.6　在Shell下播放视频

光看静态的照片还是有些不过瘾的，于是周五，懒蜗牛同学复制来了一个叫“lanjingling.rmvb”的文件，看名字好像是叫什么“懒精灵”？真是什么人看什么片。

【观看本地文件】

那命令行下能看片么？答案依然是肯定的。当然，也依然离不开framebuffer。平时在图形界面下懒蜗牛经常用来看片的播放器是SMplayer，当初咱们介绍这个家伙的时候就说过，他只是个前端界面，真正在后面默默无闻地进行播放工作的是Mpayer，Smplayer能播放什么文件完全取决于Mplayer能播放什么文件，只是因为Mplayer总是在后台，人们都忽略了他的存在。现在，到了字符界面，Mplayer终于可以从后台来到前台了。懒蜗牛用cd命令来到了存放lanjingling.rmvb这个文件的目录里，运行了：
: mplayer

于是，一个动态的画面出现在了黑漆漆的屏幕上，一群蓝皮肤白帽子的小家伙映入了懒蜗牛同学的眼帘。我猜懒蜗牛同学一定最喜欢里面那个叫惰惰的家伙。

*提示：*如果不添加任何参数运行“mplayer路径/视频文件”，则只会按照视频的原始大小显示，且此时按f快捷键无法全屏。效果类似图6.14所示。如果需要全屏播放，需要添加“-fs”参数，例如：

[[./Images/image00566.jpeg]]

图6.14　在命令行下播放视频

[[./Images/image00567.jpeg]]

【观看流媒体】

除了硬盘里现成的视频文件以外，Mplayer还可以播放mms流媒体，也就是一些在线的视频也是可以播放的。

懒蜗牛找到了一些网上的电视台的流媒体地址，什么CCTV5啊，CCTV8啊，这TV那TV的，反正我是不知道什么内容，但是懒蜗牛看得很起劲。流媒体的地址大约就是
mms://URL/FILENAME
这样的形式，要看这样的媒体可以简单地运行：
: mplayer mms:

好像懒蜗牛同学屋里也没有那个叫做TV的东西，于是有了mplayer，他就拿电脑当作TV用了。

*** 6.5.7　扩展阅读：bash的发展历史

【Thompson Shell】

在最初创造UNIX系统的时候，KenThompson大牛在Bell实验室写了一个简单的程序，将它作为新的UNIX操作系统的接口界面来让系统和人类进行交流。这个程序就叫做Shell，那时候还没正式起名字，为了让使用这个Shell的人们不忘记作者的辛劳，大家就管它叫ThompsonShell了。

ThompsonShell的功能很简单，用户通过它输入一些指定的命令，它负责解释为需要计算机做的操作，并去执行。另外它还能够支持一些简单的脚本，就是把一堆命令写进一个文件里依次执行。但并没有更高级的例如流程控制、分支、变量、函数之类的东西。

【Bourne Shell】

同时，Ken/Thompson的同事，同在Bell实验室的SteveBourne（就是图6.15所示的这位）也写了一个Shell程序。作为一个有很多重要程序要写的大牛，SteveBourne也没来得及给他写的Shell起名字，于是人们同样为了不忘记作者的贡献，管这个Shell叫做Bourne
Shell。这个Shell跟Thompson Shell不同，他加入了流控制，可以写简单的函数。

[[./Images/image00569.jpeg]]
图6.15　Steve Bourne

【标准Shell之争】

等到了20世纪70年代晚期，每种Shell在Bell实验室都有不少人用，于是形成了两个派别。说来这两个Shell应该都是很不错的，用熟悉了都很顺手，但是这两个Shell是互不兼容的，就如同修习了少林的内功后再去学武当的心法，多半不是很习惯。

但是作为一个成熟的商业化的系统，总该有个默认的、标准的Shell才方便用户学习使用。于是在Bell实验室里，分别支持ThompsonShell和BourneShell的两大帮派，进行了激烈的辩论，经过3次连续的UNIX用户组集会上两大帮派的斗争之后，终于确立了BourneShell成为UNIX的标准Shell。

【Bash诞生】

等到1978年，Bourne Shell随着Version7
UNIX一同发布，终于告别了实验室，和广大用户见面了。9年后，1987年，一个叫做BrianFox的家伙非常喜欢BourneShell，并且觉得它还可以更加完善，于是开始在BourneShell的基础上进行创造，几年后它成为一个更加完整而且好用的Shell。出于对BourneShell的缅怀和崇拜，他将这个Shell命名为Bourne Again Shell------简称bash。现在，bash是绝大多数Linux系统及Mac OS X
v10.4系统的默认Shell。甚至还被移植到了Windows系统上，什么？你没见过？那你听说过Cygwin吧，那里面就是bash。

** 6.6　本章小结

这个懒蜗牛同学对于Linux系统，可说是越用越有感觉了。在图形界面下玩腻了就跑到字符界面下感受了一番。他记住了一些简单的命令，还学会了编写简单的Shell脚本和使用正则表达式。但这不是主要的，更重要的是了解了命令行的很多基本的概念，也可以感受到Linux系统的一些优秀的设计思想。有了命令行的使用基础以后，懒蜗牛接下来会去学点什么呢？咱们下回再说。
* 第7章 改造世界的工具

懒蜗牛同学熟悉了命令行的操作，了解了各种命令之后，越来越能体会到我们Ubuntu系统的自由和开放。但他没有就此结束探索，他还要更深入地学习，学习编程，学习如何改造这个Linux世界。

** 7.1　C/C++语言


开发环境的搭建

编程语言有很多种，懒蜗牛也不知道哪个适合自己。所幸他上学的时候学过Turbo
C，而且听说C语言在Linux里用得很广泛，那就从C语言开始吧。

*** 7.1.1　安装开发套件

C语言是当年创造UNIX系统的主要参与者之一------Dennis M.
Ritchie设计并实现的。（就是图7.1里所示的这位）当年这位牛人在写UNIX系统的时候，觉得没啥顺手的编程语言，于是就基于B语言进行改造，设计出了C语言。

[[./Images/image00570.jpeg]]

图7.1　Dennis M. Ritchie

牛人设计出的东西总是很经典的，C语言就是一个经典中的经典，经典到至今仍然被广泛应用于各种编程的场合。C语言是一种编译型语言，所以要使用C语言开发程序，就需要安装编译器。

*提示：*B语言是由BCPL语言发展而来的，设计者是美国贝尔实验室的Ken
Thompson。将它取名为B语言的意思是将BCPL语言进行压缩，提炼出它的精华。
# 这俩缔造Unix
【编译型语言】

有人问，什么叫编译型语言呢？

编程语言大致分成两种，编译型和解释型。编译型语言，就是像C语言这样的，写完了需要用编译器编译的语言。

C语言的程序源码，对我们系统来说就是一个普通的写满字符的文本文件而已。就比如你看书懒得自己翻页（这得多么懒啊），于是要设计一个自动翻页的机器，那么肯定要先有机器的大致的设计图纸。C语言的源代码就相当于是设计图纸，而最终要得到的那个可以运行起来的程序就相当于最终的翻页机。要想让图纸变成机器，需要一个制造的过程，这个过程就相当于编译过程。造机器的过程中肯定需要各种工具，什么扳手、钳子、螺丝刀之类的。软件的编译也需要工具，就是编译工具。

通过编译工具的编译，原本一个或者几个源码文件（多数情况下是很多源码文件），就变成了活生生的、欢蹦乱跳的、能够像狐狸妹妹（以下“狐狸妹妹”或“狐狸”特指Firefox）一样跑进内存运行的程序。

除了编译型语言外，还有一种解释型语言，咱们以后再解说它。这里先说C语言的编译工具。

【GCC的来历】

我们Linux系统中最常用的C语言编译器就是GCC了，图7.2所示是它的Logo。

[[./Images/image00571.jpeg]]

图7.2　GCC的Logo

GCC这个项目是GNU计划的发起者------Richard
Stallman于1984年开始实施的。到1987年，首次发行了最初的GCC版本。他最初取名GCC是想表示GNU C Compiler，也就是GNU系统中的C语言编译器。GCC起初是在早期的Sun和DEC
VAX系统上运行的，由于它是开源的编译器（Richard
Stallman创造的东西，怎么可能不开源，除非太阳从西边出来），因此热心的爱好者们可以随意修改并且完善它。这其中最主要的工作，就是提供对各种处理器架构Arm、MIPS、x86等的支持。很快，GCC就能够支持大多数流行的（甚至罕见的）处理器架构了。表7.1列出了目前GCC支持的CPU架构。


由此可见，GCC支持的处理器还是非常广泛的。不仅如此，随着开源贡献者的不断完善，GCC的功能还得到充分的扩充，不仅可以编译C语言，什么Ada、Fortran、C++、Object-C，它都可以支持。它不再仅仅是一个C Compiler，于是它的首字母缩写的意思就变成了GNU Compiler Collection，也就是GNU系统编译器套装。

*提示：*Object-C是扩充C的面向对象编程语言。它主要使用于Mac
OS X和GNUstep这两个使用OpenStep标准的系统。

除了GCC外，Intel公司还开发了一个专门针对他们公司的处理器进行优化的编译器------ICC，大约就是Intel C Compiler的意思吧。如果你用的是Intel公司的CPU，那么这个编译器编译出来的东西，理论上效率会高一些。不过这个编译器目前还不大靠谱，用来试验还可以。

【需要安装的软件包】

好，咱还回来说GCC。说了这么多，这个GCC编译器怎么安装呢？是不是叫apt来装就好了呢？告诉您，apt都不用，装系统的时候就装上了。那么既然已经有了编译器，懒蜗牛同学是不是可以马上开始用GCC编译C语言的程序了呢？也不是，只有GCC是不够的，还需要一些必要的头文件和库文件。

前面说过，GCC就相当于一个用来加工代码的工具，就像木匠造凳子需要的凿子、斧子、锯子这些工具一样。但光有工具不行，还得有材料。要创造东西总是要把某种东西经过加工才变成成品的，总不可能凭空创造出东西吧。你看木匠要造凳子得需要木头、钉子或者胶水这些材料。根据爱因斯坦的物质守恒学说......哦，有点扯远了，总之，要创造程序，需要工具和材料。

用户要创造一个程序，他需要的工具，就是GCC。而需要的材料，就是各种头文件、库文件这样的文件。创造程序之前，需要准备好这些东西才可以开始。我们的懒蜗牛同学似乎已经进行了充分的学习，对这些理解得比较透彻，所以他就直接叫apt来帮忙准备好这些工具和材料。

为了方便用户安装开发环境，apt已经把创造程序需要的工具都打好了包，包名就叫做build-essential。所以懒蜗牛运行了：
: sudo apt-get install build-essential

就去把这些东西从网络上拖回来并且安装好了。作为仅仅是初学C语言的懒蜗牛同学来说，装好这个包就够了。

*提示：*如果编写较为复杂的程序，则需要根据程序所涉及的功能安装相应的库。例如，编写需要调用OpenGL绘图的程序，则需安装OpenGL库；编写gtk图形界面程序，则需安装gtk库等。

*** 7.1.2　在哪编写程序

装好了编译工具，懒蜗牛还是有些不知从何下手。他在图形界面找了半天也没找到GCC到底装哪里了。嗯！看来是个命令行程序，于是懒蜗牛又在命令行下运行GCC，结果提示说：no input files，这到底是什么意思呢？连个界面都没有，往哪里写程序啊？

【散装的工具和成套的套件】

看来懒蜗牛同学已经习惯了Windows下的开发工具了，以为GCC跟Turbo
C或者Visual C++一样呢。其实人家Windows下的Visual
C++是一个集成开发环境，那可是个巨无霸型的软件。他拥有编译程序、编辑文本、项目管理、程序调试、帮助文档等各种各样的功能。这符合微软公司总是把软件做得大而全的一贯作风。装了这么一个软件，您就用去吧，啥都有了。

而在我们崇尚简洁的Linux系统中，这些功能分别由不同的软件去实现。例如帮助文档由man来负责；项目管理靠用户写Makefile来实现；文本的编辑则由任何一个用户用着顺手的文本编辑器完成；编译程序，才是GCC的工作。还是那句话：只做一件事，但要做到最好！

所以，写程序这件事其实可以用任何一种文本编辑器完成，只要是能编写文本文件的，都可以写C语言的程序。


【Vim】

上面说的编辑器虽然能够写点小程序，有点小功能，不过毕竟有限。真要做开发，还是有些应付不了。这时候就需要更强大的文本编辑器了，Vim就是一个。

Vim，即Vi Improved，它是Bram Moolenaar开发的、与无比强大且无比难用的Vi编辑器相兼容并且是更加强大易用的文本编辑器。它支持语法变色、正规表达式匹配与替换、插入补全、自定义键等功能，为编写程序提供了极大的方便。图7.5所示是它的Logo。

[[./Images/image00576.jpeg]]
图7.5　Vim的Logo

我们Ubuntu系统中默认带有Vi编辑器，可能很多同学已经听说过它的大名了。不过，这个编辑器实在是很不好用，太没人性了，所以一般人都会让apt去安装一个更人性化一点的Vi------这就是Vim，可以这样安装：
: sudo apt-get install vim-gnome

安装这个包之后，就有了字符界面的Vim和图形界面的gVim可以使用。使用方法基本一样，所不同的就是gVim支持一些鼠标操作。如图7.6所示就是gVim显示C语言代码的效果。

[[./Images/image00578.jpeg]]
图7.6　gVim显示C语言代码

【Emacs】

还有一个跟Vim同样强大的编辑器，就是Emacs了。

Emacs全称为Editor MacroS，直接翻译过来就是“宏编辑器”，图7.7所示是它的Logo。Emacs是一个有着悠久历史的文本编辑器，最初由RichardStallman于1975年在MIT的时候，协同Guy
Steele共同完成，比Vi的诞生要早一点。这种神一样的编辑器使用了Emacs
Lisp这种有着极强扩展性的编程语言，从而实现了包括编程、编译乃至网络浏览等功能的扩展。由于扩展功能的强大，所以很多人开玩笑说Emacs是一个伪装成编辑器的操作系统。

[[./Images/image00579.jpeg]]

图7.7　Emacs的Logo

*提示：*Emacs还有一个分支，是1991年发起的XEmacs项目。XEmacs与Emacs有着良好的兼容性，并且对多国语言的处理能力更加强大。它甚至可以在一份文件中同时处理多种不同的语言文字。

如今，依然有很多人在使用Emacs编辑器处理着他们的各种工作。在我们Ubuntu系统中想用Emacs就直接叫来apt安装：
: sudo apt-get install emacs

安装好之后，就可以直接运行“emacs”命令来启动Emacs。“emacs”命令本身可以判断当前的系统环境，如果有图形界面，会启动图形界面的Emacs，如图7.8所示。如果是在纯字符终端运行“emacs”命令，则启动字符界面的Emacs，如图7.9所示。

[[./Images/image00581.jpeg]]
图7.8　Emacs图形界面

[[./Images/image00582.jpeg]]
图7.9　Emacs字符界面

【最强大的编辑器】

不过有一点要特别注意：千万不要问谁是Linux下最强大的文本编辑器！

一直以来，在Linux这片自由的天空下，两位公认的顶级的文本编辑器------Vim和Emacs，谁也不服对方。两个人都觉得自己才是空前绝后旷古烁今的全能文本编辑器。一旦有谁质疑一下“最强大文本编辑器”的地位，他们两个都会第一时间跳出来，相互指摘对方的缺点，以确立自己在文本编辑器领域的不败地位。

Vim总是指责Emacs说：“那么多的快捷键，记忆起来多麻烦。”

这时候一般Emacs会反驳：“你呢？那么多命令难道容易记？”

“初期需要记住的命令确实多一些，”Vim辩解说，“但是总共就那么几个命令，记住之后就可以应用自如了。通过简单命令的组合可以实现各种复杂的操作。哪像你，每种操作都有快捷键要记忆，而且还分那么多模式。每个模式都有特定的快捷键，搞得人晕头转向。”

“你还好意思说我模式多？你不也分什么输入模式、指令模式还有行末模式么，搞得新手不知如何是好，连退出都不知道怎么退出。你觉得我模式多？那是我灵活，我功能多。你能看邮件么？你能编写网页么？你能看图片么？我都能，并且还远远不止这些。”

Vim会冷冷地说：“是啊......所以你才不是最强大的文本编辑器。因为你压根不是文本编辑器，你是个绑定了文本编辑功能的操作系统！”

“胡说，我是编辑器，怎么成了操作系统了？我不是操作系统！你才是操作系统呢，你们全家都是操作系统！”

......

总之呢，一定不要让这两个人遇到一起，更不能在有他们两个的时候提到谁是最好的之类的话题。否则就是：吵不关机死不休！其实要我说，这两者各有特点而已，没什么争吵的必要。您用哪个顺手就用那个就行了。

【经典的HelloWorld】

介绍了这么多，这会儿懒蜗牛已经完成了他人生中的第一段Linux下的C语言代码。他写的是一段最简单、最经典的C语言代码------HelloWorld。程序全文如下：

#+BEGIN_SRC c
# include <stdio.h>
int main(int argc, char* argv[])
{
  printf("Hello World!\n");
}
#+END_SRC
简洁明了吧。这段程序也没什么实际意义，只是试验一下C语言的编译而已。懒蜗牛同学写好了这个程序之后，把它保存在了/home/lanwoniu/Program_C目录下。这是他刚刚建立的一个目录，把这个源代码存为了hello.c文件。然后，就准备进行编译了。

*提示：*建立目录使用命令：mkdir <路径>/<目录名>。

*** 7.1.3　编译和运行

【编译C语言】

编译很简单，找来编译器GCC就可以了。只见懒蜗牛同学运行：
进入这个目录里，然后：
#+BEGIN_SRC shell :results output
cd $HOME/Documents/Program_C
gcc ./hello.c
ls .
#+END_SRC

#+RESULTS:
: a.out
: hello.c

这样就编译完了，简单吧。运行完了之后，编译出的结果会被命名为一个a.out文件，就放在当前目录下，懒蜗牛执行了ls命令一下，果然看到了这个文件：



这个a.out就是编译出的二进制文件，赶紧执行试试：

[[./Images/image00587.jpeg]]

嗯，果然如预期所料。

咱刚才说了，GCC这个名字已经并不单单指一个编译器了，而是很多种语言的编译器的组合。除了编译C语言的“gcc”命令之外，另外一个最常用的就是用于编译C++程序的“g++”命令了。

【C++语言简介】

C++，这个词在懒蜗牛同学所在的这个国家通常被读做“C加加”，同理，地球对面的程序员通常读做“C plus plus”。它是一种使用非常广泛的计算机编程语言。它完全兼容C语言，在C语言的基础上增加了对对象的支持。

早在20世纪80年代，贝尔实验室的本贾尼·斯特劳斯特卢普（BjarneStroustrup）博士最初发明C++语言的时候，将它命名为“C with Classes”，直译过来也就是“带有类概念的C语言”。C++最初是作为C语言的增强版出现的，但随着它的发展，从增加类开始，不断地增加新特性。什么虚函数（virtual
function）、运算符重载（operator overloading）、多重继承（multiple
inheritance）、模板（template）、异常（exception）、RTTI、命名空间（name
space）逐渐被加入标准。

到1998年，国际标准组织（ISO）颁布了C++程序设计语言的国际标准ISO/IEC
14882-1998。然而由于C++语言被设计得太复杂、太高深、太科幻，以至于到现在为止，都没有一个编译器能够100％地支持这个标准。不过也不用担心，绝大多数编译器的绝大多数行为还是一致的。

【C++的编译】

懒蜗牛很快又试了试“g++”命令的使用。要使用g++，首先得有段C++语言的程序啊，其实“g++”是完全可以编译C程序的，不过为了让程序更C++一些，懒蜗牛同学还是把程序改了改，写出了C++版本的HelloWorld：

[[./Images/image00588.jpeg]]

修改之后，懒蜗牛将程序另存为hello.cpp文件并运行：

[[./Images/image00589.jpeg]]

同样也编译出了a.out文件，运行效果和刚才那段C语言的程序没啥区别。

*提示：*编译输出的文件如果有同名文件在目录下，编译器将直接覆盖原有文件，不做任何提示或询问。

*** 7.1.4　C/C++语言集成开发环境
# 略掉此项
咱们已经说明白了，这个GCC只是个编译器，不是集成开发环境。但是并不是说我们Ubuntu系统里就没有C/C++语言的集成开发环境。毕竟有时候，有的用户，还是用集成开发环境更顺手一些。那我就介绍几个常见的吧。

** 7.2　PHP开发环境的搭建

搭建好了C语言开发环境后，懒蜗牛同学又开始着手试着研究PHP语言了。这主要是因为他觉得C语言还是有点难度，好像PHP更容易入门些。于是他就开始了搭建PHP开发环境的工作。

*** 7.2.1　PHP是个神马

PHP（Hypertext Preprocessor）是一种脚本语言，主要用于处理动态网页。不过它也包含了命令行运行接口，甚至还能产生拥有图形用户界面（GUI）的程序。PHP最早由拉斯姆斯·勒多夫（Rasmus
Lerdorf）在1995年发明，就是图7.14中所示的这位仁兄。要说起PHP的作用和意义，那就得从很久以前说起了......

[[./Images/image00596.jpeg]]

图7.14　拉斯姆斯·勒多夫

【静态的HTML】

话说很久很久以前，互联网才刚刚兴起。那时候网页上使用的是HTML语言，也就是超文本标记语言------HyperText
Markup Language来实现排版。似乎是带“超”字的东西都比较强大而流行，比如超人、超市、超女之类的，于是网页这种形式的媒介很快流行起来（这都挨得着么......）。用户的浏览器下载下来用HTML语言写的网页，然后按照HTML语言的规则解释为一张调整好各种版式、字体、图片等内容的网页，如图7.15所示。

[[./Images/image00597.jpeg]]

图7.15　静态网页

【在客户端执行的脚本】

不过过了几年，人们就不满足于仅仅靠HTML提供的这种静态的网页了。于是各种网页脚本语言开始盛行，比如JavaScript。这种脚本嵌入在HTML的网页源码中，用户的浏览器下载下网页的源码之后，除了按照HTML排版出网页以外，还要运行网页上的JavaScript语言写的脚本程序。有了这样的脚本语言，就可以实现很多有意思的效果，比如图片的移动（比如某些网页上飘来飘去的广告），背景的切换，甚至实现一个网页上的小游戏，都没有问题。于是，网页开始越来越有意思了。图7.16所示就是一个有一定互动性的动态网页的例子。

[[./Images/image00598.jpeg]]

图7.16　互动网页

【在服务器端执行的脚本】

不过这种脚本语言也有它的问题。随着这种脚本运用得越来越广泛，写得越来越复杂，执行的效率就难以保障了。用户的电脑多种多样，有的是奔腾166
MHz的CPU，16 MB的内存；有的是8核CPU，8
GB的内存。这两台电脑如果运行同一个网页行的脚本，速度肯定不一样。并且由于不同的浏览器对脚本的解释也会有些细微的差别，因此一个脚本要想在各种电脑、各种浏览器上都能有相同的效果，需要做大量的兼容性测试工作。

这时候，PHP语言吸引了人们的目光。PHP也是一种脚本语言，但它是运行在服务器端的。它同样可以提供一些互动性的或者动态的网页，但这种动态和互动性是依赖服务器的运算能力来实现的，不需要用户的浏览器和电脑做过多的工作。

这样做的好处就是减少了客户端浏览器和计算机硬件的不同带来的差异性，减轻了客户端浏览器的工作压力，让网页的效果更有保证。

*** 7.2.2　解释型语言

PHP是一种解释型的语言，跟刚才咱们说的编译型的C语言不一样。那么解释型语言又是怎么回事呢？

解释型语言就是由一个统一的解释器根据脚本程序进行各种操作，实现各种各样的功能。假设还是你懒得翻书这件事。如果用编译型语言，就相当于设计出一张“自动翻书机”的图纸，然后照着图纸制造出这么个机器，之后你就可以懒到看书不用翻了。

如果用解释型语言呢？那你需要先有一台“全功能懒人助手机器人”，然后你写一段翻书的程序输入到里面，程序里写明了该怎么翻、如何翻、全是字的页隔多长时间翻、有插图的隔多长时间翻等。然后这个全能机器人理解了你写的程序后，就可以帮你做翻书的动作了。

这时候，你写的那个清单，就相当于解释型语言的程序清单。而全能机器人能够解释你的程序，并做出相应的动作，于是它就是你这种“翻书语言”的解释器了。

从我们操作系统的角度看，编译型语言是通过编译器创造出新的程序，然后让这个新的程序去完成你需要的任务；而解释型语言是有一个通用的，干什么都行的解释器程序（比如全能机器人），通过写程序告诉这个程序该去干什么，然后由解释器程序去具体实现各种功能。

*提示：*我们熟悉的bash其实也是一种解释器，Shell脚本就是用bash能够看懂的语言写的一段程序。

*** 7.2.3　安装Apache和PHP

懒蜗牛同学准备安装Apache了。

【安装必要的软件包】

有人问，这个Apache是什么？不是在说PHP么？你是不是印错了？告诉您，没错。这个Apache是我们Linux下的一个Web服务器软件，对外提供Web服务。再简单点说吧，有了Apache，就可以把你的电脑做成一个网站了。Apache的Logo是一片彩色的羽毛，您可能曾经看到过，如图7.17所示：

[[./Images/image00599.jpeg]]
图7.17　Apache的Logo

因为PHP主要是用在网页上的脚本语言，而且还是在服务器端执行的，所以当然先得有个Web服务器才好使用PHP脚本。

*提示：*一些轻量级的Web服务器软件，例如Lighttpd、thttpd等，也可以支持PHP脚本。

安装Apache还是找超级牛力，PHP也找超级牛力装，为了省事，可以写在一条命令里，类似这样：
: sudo apt-get install apache2 php-mysql

【验证Apache正常】

安装的过程没什么悬念，安装后你就可以用Firefox访问
http://127.0.0.1/
这个地址来看看效果了，如果正常，应该会看到如图7.18所示的页面。

[[./Images/image00601.jpeg]]

图7.18　Apache默认页面

*提示：*根据TCP/IP协议，127.0.0.1为代表本机的特殊地址。

那么这个简陋的页面是从哪里来的呢？
装上了Apache之后，你的电脑就相当于一个网站的服务器了。而这个页面，就相当于网站的首页。这个页面存储在/var/www/目录下，里面有个index.html文件，里面的内容很简单，大约就是这样：

[[./Images/image00602.jpeg]]

用狐狸妹妹访问127.0.0.1的时候，狐狸妹妹就连接到本机的80端口，然后会发现Apache在那里笑盈盈地等着，并把这个简单的index.html文件交给狐狸妹妹，狐狸再根据HTML语言的规则把文件显示出来，就是您刚才看到的那个页面。

如果能够显示这个页面，Apache算是正常工作了，但我们还没有看到PHP的身影呢。

【验证PHP正常】

要验证PHP是否正常工作，需要写一个PHP的页面。还在刚才那个/var/www/目录里，咱们再写一个index.php。当然，这个目录不是随便哪个人都能写入的，需要sudo：

[[./Images/image00603.jpeg]]

这样，gedit会打开一个空文件，然后我们往里面写入如下内容。暂时照着写，不要问为什么。

[[./Images/image00604.jpeg]]

写完之后保存好，再访问http://127.0.0.1/index.php
（如果访问http://127.0.0.1/，还会获取到index.html）
然后，就是见证奇迹的时刻，如图7.19所示。

[[./Images/image00605.jpeg]]

图7.19　PHP信息页面

我们写下的短短几行的代码竟然显示出这么复杂的一个页面。这个页面里介绍了当前正在运行的PHP的一些信息，比如版本、各种相关的配置等。看到这个页面，就说明PHP已经正常地运行起来了。

*** 7.2.4　又是HelloWorld

好了，现在开发PHP的环境装好了，懒蜗牛同学要开始学习怎么写PHP程序了。

【浏览器中的PHP页面】

刚才我们看到了，PHP的程序是嵌入在HTML语言之间的，用标记“<?php”作为开始，“?>”作为结束。这两个标记之间的内容，就是PHP的语句。懒蜗牛同学又写了个经典的HelloWorld程序，存为test.php文件，放在了/var/www/目录下。程序全文如下：

[[./Images/image00606.jpeg]]

*提示：*曾经PHP语言的开始标记也可简写为“<?”，但为了防止和其他的标记符号冲突，PHP官方现在推荐使用标准的“<?php”。

这样，当懒蜗牛同学用狐狸妹妹访问http://127.0.0.1/test.php
的时候，就是下面这样一个过程。

（1）首先，Apache接到狐狸的请求，知道她想要查看test.php这个文件，于是就把文件拿过来。但是根据扩展名发现这是一个.php文件，于是就叫来PHP处理。

（2）然后，PHP就查找这个文件中所有“<?php”和“?>”之间的内容，并且按照PHP语言去解释它们，执行相应的操作，用操作输出的结果替换掉“<?php”和“?>”之间的内容，再交回Apache手里。这时候的代码里就没有PHP的内容了，比如懒蜗牛同学写的这个简单的test.php页面，经过PHP翻译之后，大约就是下面的样子：

[[./Images/image00607.jpeg]]

（3）之后，Apache才将PHP翻译过的这个文件交给狐狸妹妹，让她去根据HTML语言的规范去显示页面。狐狸显示出来的test.php大约就是图7.20所示的这个样子了。所以说狐狸根本看不到什么PHP语句，这就是所谓的“运行在服务器端”的脚本语言。

[[./Images/image00608.jpeg]]

图7.20　test.php效果

【命令行中的PHP脚本】

另外，PHP脚本也不一定非要用在网页上，如果你对PHP语言非常熟悉，想用它写个脚本实现一些简单的功能，比如批量处理文件、自动格式化硬盘之类的，也是没问题的。不过这需要一个命令行下的PHP解释器，需要安装“php5cli”这个软件包，运行以下命令即可，都是老熟人了，我就不讲解这个命令是什么意思了：

[[./Images/image00609.jpeg]]

装好之后，你就可以写PHP脚本了，比如下面这个简单的例子：

[[./Images/image00610.jpeg]]

这个文件第一行，咱们之前说过，说明了这个脚本的解释器是/usr/bin/php。下面就是PHP的语句了，当然，虽然不是网页，但PHP语句也一定要写在<?php和?>之间。把这个文件写好了之后，存储为cpu.sh并赋予执行权限之后，即可执行这个脚本看效果了，其实就是用来查看CPU信息的一个小脚本。

*提示：*使用chmod +x
cpu.sh命令来赋予可执行权限。
** 7.3　Java开发环境的搭建

除了C语言外，应用最广泛的语言大概就是Java了，尤其是在开发手机应用方面，更是Java的天下。因此，懒蜗牛同学决定，还得好好学一下Java。

*** 7.3.1　半编译型语言

Java也是一种电脑编程语言，拥有跨平台、面向对象、泛型编程等特性。它最初被命名为Oak（橡树），当时的目标是用于电视机、电话、闹钟、烤面包机等家用电器的控制和通信。可是由于这些智能化家电的市场需求没有预期的高，于是Oak被改造为应用在互联网上的编程语言。1995年5月，它被正式命名为Java，并伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。它的Logo大概您不会陌生，就是图7.21所示的这杯咖啡。

[[./Images/image00611.jpeg]]

图7.21　Java的Logo

前面说了，这个编程语言有编译型的，有解释型的。那好，提问：Java是哪种类型的语言呢？

　A．编译型
　B．解释型
　C．以上皆错
　D．人妖型

正确答案：C、D（我说是单选了吗？）。

其实，Java既不是编译型，也不是解释型。它有它的中性美，是多少有点半男不女、半上不下、半人半妖的这么一种人妖型语言。好吧，我承认这个名字不那么好听，那么我们就管它叫做半编译型语言吧。为什么这么叫呢？

【既需要编译器，又需要解释器】

首先，跟编译型语言一样，要想运行Java的源程序，必须要经过编译的步骤。但是Java程序编译出来之后并不能像C/C++语言一样直接在机器上运行。也就是说，Java编译器编译出来的并不是一个符合当前系统的二进制格式的程序，而是一种特殊结构的二进制程序。

那么这种特殊的程序怎么运行呢？要想运行这个程序，就和解释型语言一样，需要一个解释器。Java的解释器就是Java虚拟机。一般如果要运行一个Java写的软件，就必须装一个叫做JRE的东西。他负责给Java程序创造出一个可以自由运行的空间，在那里面，这个编译好的Java程序才能运行。

就好像，我们宽敞的内存是一片大草原，GCC编译出来的程序就是各种哺乳动物，什么牛、羊、猎狗之类的。而Java编译出来的程序就是一堆鲤鱼、黄鳝、泥鳅之类的东西。那么JRE的工作，就是挖一个水塘，或者做一个鱼缸。
# 够形象的.
【Java的特点】

那为什么Java要整得这么繁琐呢？又需要编译器，又需要解释器，有什么好处？好处很大，最大的好处就是跨平台。

作为编译型语言，编译出来的程序跟目标平台是紧密相关的。平台包括硬件和操作系统。也就是说，同样一套程序的源代码，如果要在不同的操作系统或者不同的硬件平台上运行，那么就需要用不同的编译器，针对每一种系统和硬件分别进行编译，才能够运行。

而Java就可以解决这种困境。它可以只编译一次，就能把编译出的二进制程序放到不同的平台上运行。当然，前提是那些平台上都安装了Java的解释器。各个平台的差异性由Java的解释器统一处理掉了，编写Java程序的人不需要考虑程序是运行在哪个系统，哪种CPU中，只要程序写出来，编译完了，就可以放到任何地方运行。Java的理想就是：Write once，run anywhere。

*提示：*实质上，由于各个系统的差异性，Java编译出的程序还是需要针对特定平台进行一定的调试和修改。所以有的程序员戏称Java是“Write once,debug anywhere”。

当然，解释型语言照样可以实现跨平台，只要不同的平台上都有相应的解释器就可以。比如bash其实就可以算是一种解释型语言，同样一个脚本，不管你是在Linux还是BSD系统，或者Windows的cygwin模拟环境下，都可以实现相同的功能。但是与之相比，由于经过了编译，Java的二进制程序更接近汇编指令，因此翻译起来效率比纯解释型语言高很多。

*** 7.3.2　JDK和JRE

作为一种编译型语言，要编译程序，就需要编译器。
作为一种解释型语言，要运行程序，就需要解释器。
而作为一种人妖型语言的Java，既需要编译器，又需要解释器。所以，我们就来说说怎么装这俩东西。

【安装开源的JDK和JRE】

如果你想要运行一个Java的程序，比如咱们之前介绍过的BT下载软件毒蛙，那么你的系统里面就必须有解释器------JRE。JRE就是JavaRunTime的缩写，只要你想运行Java程序，无论在哪个系统上，都得安装它。而如果你想开发Java程序，那就不止需要JRE了，还需要JDK，也就是Java Development Kit，Java开发工具。

这两种东西在我们的软件源里有不止一种。您可以在新立得里面搜索一下JRE，会有不少结果。其中有一个openjdk系列的软件包，包括了编译器JDK和解释器JRE。看名字就能明白，这是一套Java的开源实现，如果您只是想运行些简单的Java程序，基本上装这个包也就可以了。不过既然懒蜗牛同学是想做Java的开发，那还是用更权威的比较好，那就是sun-java6。

【安装权威的JDK和JRE】

sun-java6这一套开发套件默认并不在源中，需要稍微操作一下。别急，一点儿也不难。

（1）首先用任何顺手的编辑器打开/etc/apt/sources.list文件，例如用gedit，就这样：

[[./Images/image00612.jpeg]]

（2）打开sources.list文件之后，在文件的最后加上这样一行：

[[./Images/image00613.jpeg]]

（3）记得我们说过，更改sources.list文件之后一定要更新，所以：

[[./Images/image00614.jpeg]]

好了，这样就可以直接用超级牛力来安装Java相关的东西了。比如安装JRE只要运行：

[[./Images/image00615.jpeg]]

就安装好了。或者用新立得安装sun-java6-jre这个软件包，也一样。如果需要做Java开发，就安装JDK。

[[./Images/image00616.jpeg]]



** 7.4　Vim编辑器的使用

前面咱们曾经介绍过几种常用的文本编辑器。其中使用最广泛，功能最强大的，就要数Vim和Emacs了（可别问哪个更强大啊，省得他俩又吵起来）。于是，懒蜗牛同学打算学习一下Vim的使用，为以后写程序及写脚本做好充分的准备（懒蜗牛学习Vim的事别让Emacs知道啊，低调低调）。
两种模式:　命令模式和输入模式

** 7.４　本章小结

这些日子，咱们这位懒蜗牛同学可是没少忙活。又是C，又是C++，又是PHP，又是Java的，配置了不少语言的开发环境。并且为了更好地编程，懒蜗牛还学习了Vim的使用。可是也没见他写出什么有用的东西来。当然，也许生活，就是一个HelloWorld，接着另一个HelloWorld吧。
# 这一章太无聊了．
* 第8章 程序是怎样炼成的
# 第八章太无聊了．
# 比喻是很好．
懒蜗牛同学搭建好了各种语言的开发环境，并且开发出了不少的HelloWorld。但他显然并不想就此罢休。凡事都喜欢刨根问底的懒蜗牛同学，还要搞明白一个软件从源代码到打包为成品的整个过程。

** 8.1　施工队

软件的最初状态自然就是源代码，要把C语言的源代码变成二进制的程序，离不开GCC。那么GCC到底对源代码做了什么，才能把一段段冰冷的代码变成一只只鲜活的程序呢？（为啥要用“只”......）

*** 8.1.1　懒蜗牛的日记A

“2010年9月3日　降雨

学了这么几天，觉得还是C语言最有意思、最灵活高效。听说好多Linux系统的软件都是拿C语言写的，连Linux内核也是以C语言为主创造的。我能不能也写出一个自己的小软件来呢？不要求功能有多么复杂，但要符合Linux的精神------只做一件事，但要做到最好。

仅仅编译一个HelloWorld很简单，只有一个.c文件，只用一条命令。我应该设计些复杂的程序，实现点有意思的功能才会有进步。编个什么程序好呢？”

*** 8.1.2　编译多个源文件的程序

懒蜗牛同学之前写过一个HelloWorld程序，但是觉得那个程序实在太简单，没什么意思。于是这回他决定写个稍微复杂点的程序。

【无聊的rubbish 1号】

只见他冥思苦想之后，写下一个源码文件，叫做rubbish.c，看来这懒蜗牛同学还真谦虚。在rubbish.c文件中写了些代码后，懒蜗牛就叫来GCC进行编译，运行了这么个命令：
: gcc ./rubbish.c -o rubbish

命令后面那个“-orubbish”的意思，就是指定编译后的二进制文件的文件名叫做rubbish。这样就不会每回都输出为a.out文件了。编译出来后，还冒着热气的rubbish就被懒蜗牛叫进内存运行起来。只见rubbish飞身跳进内存，跑进内存后抢过标准输出设备，对着那个设备大喊一声：“I am a Rubbish!”然后，就跑回硬盘继续睡觉去了。我说懒蜗牛同学呀，不是说设计个复杂点的程序吗？您这个rubbish跟那个HelloWorld有啥区别呀？

*提示：*标准输出设备，即/dev/stdout设备文件，一般该文件映射到当前字符终端。

我们后来管这个弱智的程序叫做rubbish_1号，因为懒蜗牛同学很快又创造出了很多的rubbish。

【同样无聊的rubbish 2号】

不一会儿，懒蜗牛又拿来rubbish
1号的图纸改起来。10分钟后，图纸完成，交给GCC编译，懒蜗牛很自觉地把这个程序命名为rubbish2。
: gcc ./rubish.c -o rubbshi2

很快，rubbish 2号诞生！毫无悬念地，懒蜗牛马上让我叫醒rubbish
2号起来干活。于是我走进硬盘，叫醒rubbish 2号。只见rubbish
2号立刻飞身跳进内存，依旧是对着标准输出设备大喊一声：“I am a
Ru～Ru～Ru～Rubbish～～～～!”喊完了就跑回去继续睡觉了。懒蜗牛同学成功地利用for循环创造了一个结巴。

【多个文件的rubbish 3号】

15分钟后，rubbish
3号的图纸再次毫无悬念地完成。这回的图纸不光是一个rubbish.c文件了，而是包含了3个文件：rubbish.c、input.c和input.h。这回懒蜗牛依旧是叫来了GCC，他运行这么个命令：

[[./Images/image00658.jpeg]]

这就是当代码包含多个.c文件时候的编译方式。有人问，那个.h文件呢？.h文件一般是要被包含进某个.c文件的，这个包含的动作一般在预处理的时候就给处理了，不需要在编译命令里写上.h文件。至于什么叫预处理，您别忙，咱们一会儿就会说到。

rubbish 3号这会儿已经起床，跑进内存向懒蜗牛发问：“How many Ru do you
want？”然后就等待懒蜗牛输入。懒蜗牛同学输入了一个6，于是就听见rubbish
3号大喊：“I am a Ru～Ru～Ru～Ru～Ru～Ru～Rubbish!”------程控结巴！

【系统调用的rubbish 4号】

rubbish
4号的图纸诞生啦。Vim告诉我说，这回懒蜗牛调用了创建线程的库函数（因为懒蜗牛是用Vim编程的嘛，所以Vim能知道写了些什么）。果然，在编译的时候懒蜗牛运行了：

[[./Images/image00659.jpeg]]

其中，-lpthread的意思就是要连接创建线程相关的库函数。图纸交给GCC后，很快rubbish
4号诞生，并且很快就起床跑进内存。只见他念动咒语“唵木哒咪咪呀......分！”然后白光一闪，rubbish
4号变成了2个！2个4号同时喊：

“I am a Ru～Ru～Ru～Ru～Rubbish!”

“I am a Ru～Ru～Ru～Ru～Rubbish!”

二重结巴！

*** 8.1.3　编译过程详解

刚才咱们见到了编译一个（或一坨）C语言源文件时的操作，下面就仔细说说编译的过程。

在编译的时候，虽然用户用的只有一个“gcc”命令，然而我们说过，GCC是一个编译器套装。他不是一个人，不是只有一个“gcc”命令就能完成整个编译过程的！他们是一个团队，一个以“gcc”命令为首的源代码编译施工队。

施工队主要成员有gcc、cpp、as和ld这么4个命令。其中gcc命令是老大，其他几个干什么活都得听他的调遣，用户一般也只跟gcc命令打交道。当写好了图纸之后（也就是源代码，就比如刚才懒蜗牛写的rubbish.c），虽然用户直接把图纸交给gcc命令就不管了，但其实gcc命令需要去调动其他命令进行各种处理，才能完成编译工作。

（以下文中出现的小写“gcc”均代表gcc命令，而不是整个GCC开发套件。）

【施工第1步------预处理】

一般来说，gcc拿到图纸后，会首先叫来cpp进行预处理。

预处理主要就是将文件里的宏定义进行展开。什么是宏定义呢？人类用户一般都比较懒，或者说，人类能力有限，不愿意写很多重复的，相似的东西，就把这些都定义成宏。比如，这么写：

[[./Images/image00660.jpeg]]

这就是定义一个叫做TOTAL\_NUMBER的宏，从名字看，这个宏代表了一个总数，数值是18353226。那么以后再要用到这个总数的时候，就直接写TOTAL\_NUMBER就可以了，不用写那一大串数字。而且，如果总数变了，只要在最初#define的位置修改一次就可以，反正就是为了偷懒。

cpp的任务就是把这类的宏定义都替换回去。把所有的TOTAL\_NUMBER都替换成18353226；把所有#include引用的文件内容都粘贴进来等。这么说可能不形象，那咱们找个实例吧，比如有一个hello.c文件，内容是这样的：

[[./Images/image00661.jpeg]]

那么经过了预处理之后的内容是什么样呢？如果您想体验一下，可以自己试着运行：

[[./Images/image00662.jpeg]]

“-E”参数的意思就是让gcc只对main.c进行预处理。这样处理后的结果会直接输出到标准输出，不方便查看。所以我们需要进行输出转向，把输出的内容存进hello\_cpp.c文件里。打开这个文件你就会发现，仅仅几行的程序，预处理后变成了800多行！

*提示：*gcc是调用cpp命令来进行预处理，因此也可直接用cpp命令进行预处理，运行以下命令：

[[./Images/image00663.jpeg]]

效果与“gcc --E”相同。

这800多行就是因为这段代码包含了stdio.h文件，stdio.h文件又包含了很多其他的.h文件，于是在预处理的时候，cpp就把这些.h文件全部粘贴了进来（但其实都没什么用，我们只用到了其中的printf()函数）。

预编译后的文件大约就是下面这个样子：

[[./Images/image00664.jpeg]]

当然，这里面省略了很多。我们主要关注的是cpp将我们定义的TOTAL\_NUMBER这个宏，替换成了数字18353226了。

这样经过了cpp预处理之后的文件，就该交给gcc去编译了。

【施工第2步------编译】

编译又是什么意思呢？

最初的图纸，也就是没有经过预处理的源代码，那是人写的。一般懂相关语言（比如C语言）的人都能看懂。预处理之后的文件，虽然不那么直观了（TOTAL\_NUMBER看着是不是比18353226直观？光写个18353226还以为是谁的QQ号呢），但终究只是做了下替换，还是人类可以看懂的。而经过编译之后的代码是什么样子呢？还以刚才那个hello.c做例子，运行：

[[./Images/image00665.jpeg]]

“-S”参数就是告诉gcc，只对文件进行预处理和编译的步骤。这样最终会得到一个hello.s文件，这个文件里就是经过了cpp的预处理，并由gcc进行编译之后的代码了，大约是下面的样子：

[[./Images/image00666.jpeg]]

这样的代码，就不是普通人类可以看懂的源代码，而是只有终极牛人才能读懂的汇编代码了。汇编代码比较贴近底层的机器码，里面描述的都是一些基本的操作，以机器的思维来描述整个程序。

打个比方。就比如描述切黄瓜的过程，用C语言描述出来就像是“将黄瓜切片”，这么一句就搞定了。要是用汇编，那就是：“左手扶住黄瓜，右手拿起刀，移动刀到黄瓜顶部，刀落下，刀抬起。刀向黄瓜后部移动3毫米，刀落下，刀抬起。刀再向黄瓜后部移动3毫米，刀再落下，刀再抬起。放下刀，走出厨房，走进卧室，找到创可贴，贴在左手食指上......”总之，汇编是一种面向机器的，很复杂的程序设计语言。gcc的任务就是把C语言的源代码转换成贴近机器语言的汇编代码，为下一步as的工作做好准备。

【施工第3步------汇编】

as拿到汇编代码后，要对这样的代码再进行处理，得到真正的机器码。这个处理的过程，也叫汇编。

如果说进行汇编之前的汇编代码是终极牛人才能看懂的，那么经过as汇编之后，得到的机器码压根就不是人能看懂的了。而且从.c的源码文件一直到汇编之前的.s文件都是文本格式的，进行汇编之后就成为二进制的elf格式了。这就不是普通的文本编辑器可以打开的了，需要用专门的软件将其转换为16进制数据查看。转换过来之后大约就是如图8.1所示的样子。

[[./Images/image00667.jpeg]]

图8.1　汇编后的文件

如果你想看看汇编后的机器码，那么可以运行命令：

[[./Images/image00668.jpeg]]

“-c”参数的意思大概您也猜到了，就是告诉gcc，只进行预处理、编译、汇编这3个步骤。这样运行之后会输出一个hello.o文件。如果想查看这个文件，运行：

[[./Images/image00669.jpeg]]

就可以看到一堆乱七八糟数字的机器码了。汇编程序中至少还有些操作的助记符，比如什么add，mov之类的。寄存器也是有名字的，比如叫eax，叫rbp等。但是到了机器码，这些都没有了，都换成了各种各样的数字，半句人话都没了。还以切黄瓜为例，要是用机器码来描述，就相当于说：“用32号设备扶住87号物体，24号设备拿起126号物体，移动126号物体到87号物体顶部，做2635号动作，再做2636号动作......”

【施工第4步------链接】

好了，现在终于得到机器码了，机器码按说就是可以执行的代码了。但是，这时候的程序还是不能直接执行的，为什么？因为还有ld没有出场呢，他的工作叫：链接。

经过预处理、编译、汇编之后的二进制代码，按说已经是机器码了，可以直接运行。但是这里得到的机器码并不完整。就比如刚才说的这个hello.c文件，得到的机器码只是针对这个hello.c文件里面所写的这么点内容的。而这个hello.c里面还调用了printf()函数，这个函数是在系统的标准输入/输出库里面实现的。这部分负责真正向屏幕上打印字符的机器码如果不包含进来，这个程序怎么可能正常地实现功能呢？所以，就需要把这段标准库中的机器码和我们编译出来的机器码“链接”起来。

而且很多时候，一个程序不是一段机器码，而是由很多段机器码组成的。这些机器码分别保存成很多的.o文件，最终也需要把它们都“链接”起来才可以运行。

这时候就需要ld出场了。

ld负责把这些机器码组装起来，并且写明了各段代码的地址、从哪里开始执行之类的标记。就像我们造个机器人，脑袋、胳膊、大腿之类的都做好了，ld就是负责组装的。

经过ld组装的程序，就可以运行了。整个编译过程是不是挺复杂的？不过所幸我们的用户并不需要一步一步地手动做这些步骤，只运行gcc命令就全搞定了。

** 8.2　修理工

程序编译出来只是第一步。编译好的程序不一定靠谱，可能会有各种各样的错误，这就需要进行调试。调试有很多方法，但肯定离不开调试工具。这回，懒蜗牛同学就要学习调试工具的使用了。

*** 8.2.1　懒蜗牛的日记B

“2010年9月18日　变天

终于又到周末了。今天在自己的机器上学习编程，逐渐开始入门了。这一阵子最大的收获是学会了自学。通过网络、论坛搜索，也能学到不少有用的东西。像学编程吧，开发环境的搭建、循环结构、文字输入甚至创建进程，都尝试过了。看来编程也不是那么的困难嘛。不过我也知道这只是刚刚入门而已，真的写出个能用的程序和随便写个小程序玩玩还是有很大区别的。

今天写了个程序，不知道为什么，总是运行不起来。以前能够运行的程序可以用printf()函数打印出变量来看看，这个运行不起来的程序怎么调试呢？”

*** 8.2.2　邪恶的程序

今天起床的时间似乎比平时晚了点，全体起床之后，懒蜗牛同学按部就班地叫来OO老先生记录下一些文字，之后又继续去创造他的rubbish系列程序去了。

【19号扰乱秩序】

这一阵子，我们的懒蜗牛真是笔耕不辍------哦，不对，应该是键盘不辍才对------先后制造了18个rubbish程序。不过很多都被蜗牛删除了，只留有几个：一个是8号。因为8号比较憨厚，性格温顺，不爱打架。还有一个16号。16号很安静，不爱多说话，有点冷漠，但是做起事情来一丝不苟，严格地执行命令。再就是17号很厉害，但是很自大，高傲，总跟别人发生矛盾。他好像和18号还有点什么关系，具体的我就不知道了。最后的18号是个美眉，长得很可爱，一头金发，本事也不错，我们大家看她都很顺眼。而现在懒蜗牛正在制造19号。不知道为什么，我总觉得即将到来的19号将是一个邪恶的坏家伙......

没过多长时间，19号出炉了。只见他起床之后，跑进内存，刚说了几句我是rubbish
19号之类的话之后，就开始乱动别人的东西。一会儿要去狐狸的内存空间里拿数据，一会又要往心有灵犀的地盘里存东西。当然，他的这些企图都没有得逞，要是连这样的小流氓都管不了，我还叫内核么。

【内核严明法纪】

我们这个工作间里面的空间管理是很严格的，谁的空间谁用，别人不能乱动。像19号这么目无法纪，影响他人工作的软件是不能容忍的。眼看着这邪恶的19号，和满工作间无辜受害的软件们，我终于忍无可忍！为了工作间的安宁，为了我稳定内核的荣誉，为了爱与正义，为了世界和平，为了部落，我代表月亮，我，我消灭了你！转眼间，手起刀落，只听咔嚓一声------整个世界安静了。19号被我斩为两段，然后我向懒蜗牛汇报：很遗憾，您的程序出现了段错误，就像图8.2显示的这样（因为他被砍成两段了，所以错误了）。

[[./Images/image00670.jpeg]]

图8.2　程序出现段错误

懒蜗牛似乎有些不明所以，不知道这个段错误是怎么回事（因为太血腥了，所以我没直说是因为被我剁成两段）。于是就赶紧叫来狐狸上网上查去。通过搜索知道了，段错误的情况有很多（很多种不老实的程序都会被我砍成两段），但大致上都是由于内存指针使用不当引起的。比如没有给指针赋值就去使用，或者虽然赋值但是访问越界等。总之就是动了你不该动的内存就会段错误。

可是到底这个19号是如何动了别人的空间的呢？他到底为什么要去访问非法的地址呢？这些情况虽然我们内存里的软件们看得一清二楚，铁证如山，但是懒蜗牛他不知道啊。他没法钻进内存里来看程序是怎么运行的。那么懒蜗牛能有什么办法看清楚19号的一举一动呢？这时候就需要我们的软件修理工GDB闪亮登场了。

*** 8.2.3　GDB的简单使用

GDB是GNU
Debugger的缩写，也就是GNU调试器的意思。它和GCC一样，最初也是由Richard
Stallman设计并实现的。图8.3是GDB的吉祥物------一条鱼（不要问我为什么，问Stallman去）。GDB是一个字符界面的调试工具。用过VC的同学应该知道，在那里面调程序的时候可以进入debug模式，能够查看内存、单步执行之类的。我们Linux中，每个软件秉承着“只做一件事情，但做到最好”的原则，将调试这件事情交给了GDB来完成。

[[./Images/image00671.jpeg]]

图8.3　GDB的吉祥物

【编译出可被调试的程序】

GCC编译出来的程序可以通过GDB来运行，运行的时候，就可以执行设置断点、单步运行、查看变量、查看堆栈等操作。有了GDB，懒蜗牛同学就可以监视程序在内存里面的一举一动了。

不过GDB并不是像狗仔队那样想监视谁就监视谁。像狐狸啦，gedit这样的成品程序是不能被监视的。要想让某个程序被GDB监视，必须在制造他的时候------也就是编译的时候，留出给GDB控制的接口来，GDB才能监视那个程序的一举一动。您看过黑客帝国么？我们机器里的普通程序，就像是里面正常的自然人。而可以被GDB调试的程序就像Matrix世界中的人一样，脑袋后面有个接口，可以接进去控制。那么怎么给程序装这么个接口呢？很简单，就是在编译的时候加上参数“-g”，类似这样编译：

[[./Images/image00672.jpeg]]

懒蜗牛运行了这么一句，就创造出了脑袋后面有接口的rubbish
19号。之后就可以叫来GDB去调试他了。

*提示：*没有加“-g”参数编译出来的二进制文件也可以被GDB调用并运行，但由于该文件中没有记录机器码与C语言源码的对应关系，因此无法进行设置断点、查看变量、查看源码等操作。

【用GDB调试程序】

编译出了可调试的程序后，就要叫来GDB来运行它，像下面这样：

[[./Images/image00673.jpeg]]

于是，GDB就会接到命令，赶快掏出各种仪器和工具，并把19号拖进内存里（这时候19号可还没醒哦）。然后从一个大机器上抽出一个长长的电缆，插进19号脑袋后面的接口里，一切准备好之后，向懒蜗牛报告：“一切准备就绪，可以开始了。”也就是打印出下面这样的信息：

[[./Images/image00674.jpeg]]

进入这个界面，就可以进行调试了。当然，要想调试，需要了解一下GDB的一些基本的指令。我们简单介绍几个常用的。

　run命令（或者简写为r）------这个命令很好理解，就是从头开始运行程序。像刚才懒蜗牛运行“gdb
./rubbish19\_debug”后，进入了GDB调试环境，但是并没有自动运行起19号这个程序，需要run一下才行。

　break命令（或者简写为b）------这个命令用来设置断点。例如“break
12”的意思就是在程序源码的12行设置断点。这样程序运行到这一行就会停下来。

　list命令（或者简写为l）------列出当前程序源代码。遇到问题了总得看看源码吧，或者设置个断点什么的也得看着源码才知道应该断在哪行。那就用这个命令查看源码就可以了。

　continue命令（或者简写为c）------这是继续执行的意思。程序遇到断点停下来以后，可以用这个命令继续执行下去，直到碰到下一个断点，或者结束。

　print命令（或者简写为p）------这个命令用来打印变量的值。比如print
i，意思就是打印出变量i当前的值。

　examine命令（或者简写为x）------这个命令用于查看指定内存地址中的数据。例如examine
0x12345678的意思是查看内存中，地址为0x12345678位置所存放的数据。

*提示：*examine命令只能查看当前被调试程序能够合法访问的地址。

　next命令（或者简写为n）------这是单步执行的命令。程序遇到断点停下来之后，执行这个命令可向下执行一句代码。

懒蜗牛同学好像是之前看书学习过了，虽然据我所知这是他第一次使用GDB，但是似乎还挺熟练。

进入GDB调试环境后，懒蜗牛输入了r并且回车。于是，GDB按下一个电钮，19号的身体跟着腾地一下站了起来，启动了。插着电缆的19号像他上次启动后一样，还是要去骚扰狐狸妹妹，访问人家的内存空间，于是我也只好再次举起屠龙刀，再次将其一刀两断。

GDB赶快向懒蜗牛报告：19号同学在按照您的图纸进行某某动作的时候，由于侵占他人内存空间，触犯了内存管理条例第287条，因此被处以“断刑”。然后还指出了19号的这种行为在懒蜗牛的图纸中所在的位置，也就是代码行数，类似下面这样：

[[./Images/image00675.jpeg]]

懒蜗牛一看，rubbish.c文件的第9行就出问题了，太伤自尊了，可是这第9行也看不出什么不对的来。应该是这个指针有什么问题，还是从头看看程序吧。

于是懒蜗牛输入了list命令，GDB赶紧把19号的整个图纸------也就是全部程序的源代码，打印了出来。程序一打印出来，懒蜗牛才看明白：这个buffer指针压根就没有初始化嘛，只是做了声明而已，也没给申请内存空间，就这么用，那不出问题才怪。

*** 8.2.4　扩展阅读：内存管理机制

前面向您介绍了懒蜗牛创造的rubbish
19号程序，这家伙由于不遵守《Linux系统内存管理条例》被我干掉了。那么我们Linux的内存管理原则是什么呢？都有什么规矩呢？下面就来说说。

咱们说过，一个程序工作的时候需要用到的内存分为几个部分：代码段、数据段、BSS段和堆栈段。其他的段，基本上程序一启动就确定好了，没什么可说的，也没太多要管理的。唯独这个堆栈里面的堆空间，是程序运行起来之后动态申请的，需要我来管理。

【空间的申请和释放】

堆空间是指程序在起床运行后向我申请来的空间，也是一个程序占用得最多的空间。一个程序如果要想使用工作间里的空间，要向我提出要求，说需要多大多大的一块内存空间------这个过程叫做申请。然后我根据工作间里的情况来分配，告诉他，哪块哪块归你，然后这个程序就去用了。

这时候那块地方就单独给这个程序使用，不许别的程序访问了。如果别的程序胆敢来访问这块空间，就像你去人家偷东西一样，必须依法剁成两段（偷东西没这么大罪过吧......）。

那么这块内存空间分给这个程序使用之后就永远给他了么？想得美！你买房还只有70年产权呢，这么珍贵的内存空间怎么可能永久分给一个程序。申请到内存空间的这个程序在做完了相关的事情，不再需要这块空间的时候，他应该跟我报道，说空间我用完了，这块地方可以再给别的程序用了------这个过程叫做释放。

【内存泄漏】

一个有知识有道德有理想的程序，在他回硬盘睡觉以前应该释放掉所有他申请过的空间。如果遇到哪个不良程序，无德青年申请了很多空间不释放，我也没有办法。因为这不像越界访问那样，访问了别人的地址就是访问了，人赃俱获，无法抵赖。而人家不释放空间，也许是因为他一会儿还需要用这块空间呢，我没法证明他申请的空间用不着了。我唯一可以做的就是在他回硬盘睡觉的时候，检查所有他申请过的空间，如果有没释放的，就强制释放掉------你都睡觉去了，你申请的空间肯定用不着了嘛。

*提示：*Linux在程序退出之后将回收程序申请的所有资源，包括内存空间、Socket连接、设备访问等。

但是如果这个程序是个长时间运行的后台服务程序，并且还不断地申请新的空间而不释放，那就麻烦了。内存空间会被他一点一点地消耗光，这就是最烦人的内存泄漏。在我们软件界，内存泄漏是和瓦斯泄漏同样严重的事故。《Linux系统内存管理条例》第3条明确写着------禁止申请不释放！就在第4条禁止抽烟的上面（当然不能抽烟，内存都冒烟了机器还能用么）。

【Windows与Linux对内存使用的不同理念】

其实不光是Linux，Windows里的程序一样需要遵守类似的原则，估计他们那里大概也有个什么《Windows系统内存管理办法》之类的文件吧，反正大家的原理是一样的。不过对于工作间的使用，Windows和我还是有点不同的。

Windows总是喜欢尽量留出空间来，好给新起床的程序用。可是我总觉得，作为一个系统，我怎么能知道用户还有什么程序要运行呢？要是没有程序要来了，工作间里还空那么大地方，不让正在工作的程序用，那不是浪费么？所以我还是习惯尽可能地把东西都搬进工作间里。除了程序们申请多少内存就尽可能给多少之外，剩下的部分，我就把一些可能会用到的库、命令等统统都搬进来，能占多少占多少。

有人问：要是你把这里边都占满了，待会儿有程序要进来咋办？很简单啊，我再搬出去呗！

程序要用空间，也不是一下子都占满吧，他也得把他的东西一点点搬进来。他往内存里搬的时候，我就往外搬，不耽误。所以，当某个程序启动，跟我说：“我要10平米的地方放东西。”的时候，我就先答应他说：“好，你就往那边那10平米放吧。”然后在他往内存里搬数据的时候，我再去给他清理那10平米的地方。也可能他要10平米，但是暂时只用了2平米，那我就先腾出2平米来，等他再要我再腾。他们管我这个方法叫Copy-onwrite。

但是Windows就不同了。可能是因为他们普遍比较胖的缘故吧，都比较懒，不愿意搬来搬去这么折腾。基本上Windows只是在必须用啥东西的时候才把那东西搬到内存里，让内存留出尽可能多的空闲空间。这样，当有程序向他申请内存的时候，就可以用手一指：那块地，归你。然后就不用管了。内存实在不够用的时候就找个比较闲的程序，命令他：你，去硬盘里先忍会儿。

*提示：*图形界面中，可以通过“系统”|“系统管理”|“系统监视器”来查看内存使用情况，如图8.4所示。

[[./Images/image00676.jpeg]]

图8.4　系统监视器

在字符界面中可以通过“free”命令查看内存使用情况。但需注意“free”命令显示的结果中，第1行为计算了内核缓冲后的使用率。这个使用率一般很高，多数空闲内存都被用于缓冲。“buffer/cache”一行显示的，才是真正的应用软件所占用的内存，如图8.5红线处所示（free命令显示结果默认单位为KB）。

[[./Images/image00677.jpeg]]

图8.5　free命令

** 8.3　包工头

简单的程序直接用GCC编译就可以了。但是如果程序越来越大，源码文件越来越多，再手动调用GCC来编译就显得费事了。有什么好办法呢？

*** 8.3.1　懒蜗牛的日记C

“2010年10月10日　起风

今天好孤独，节后的只有一天的周末还要独自来加班。领导总是不顾员工的死活，就像剥削劳动人民的包工头一样。

不过今天加班的时候倒是抽空完善了我的rubbish程序。现在这个程序已经有16个.c文件了。每次编译的时候敲命令还真麻烦。还好Linux可以记住最近运行的几条命令，不用每次都输入。不过就算这样也挺累的，有没有更好的办法呢？”

*** 8.3.2　越来越多的源码文件

最近硬盘里的rubbish越来越多，已经排到31号了。虽然这些程序都不大，31个加在一起也就几兆的大小，可关键是这帮程序大都不着调，不是段错误就是内存泄漏，要不就是乱访问设备。这么多不着调的程序在内存里折腾，指不定什么时候就出事了。

【文件太多，一起编译费时费力】

这些rubbish程序，除了不着调以外，个头越来越大，源码也越来越复杂。从rubbish
1号只有一个.c文件，发展到现在，rubbish
31号一共有10多个源码文件。每次懒蜗牛同学编译rubbish
31号的时候，都要这样：

[[./Images/image00678.jpeg]]

每次看着他输入这么长一串的命令，我真替他累得慌。并且每次懒蜗牛这么一编译，施工队那哥儿几个就都得跑过来，把这一大堆.c挨个打开，开始从头施工，一个一个编译。有时候懒蜗牛只是在ai.c里面修改了很少的一点，编译的时候施工队的同志们也要从头到尾地重新编译每一个文件。

这就好像盖个楼，完工之后开发商说：一楼这个大门的门把手图纸上画错了，应该用圆的，怎么画成方的了？改了吧。施工方一听，赶紧下令：“图纸画错啦！把楼炸了重新盖！”虽然这样对于拉动GDP发展有很好的作用，但毕竟属于精神不正常的范畴。

【分别编译，一起链接】

那么我们的GCC施工队为什么做这种很抽风的事呢？这不怪施工队，这是因为懒蜗牛输入的命令就是让他们拆了重盖的意思（也就是让他们从头开始编译），他们只是严格执行命令而已。实际上完全不必这样，那些.c文件中，改了哪个只编译哪个就可以。那应该怎么操作呢？

（1）首先，源码写完了之后先各自编译成模块，运行：

[[./Images/image00679.jpeg]]

这个命令的意思就是把这些.c文件各自编译成.o文件，如rubbish.o、input.o等。

（2）要获得最终的二进制文件，只要再运行：

[[./Images/image00680.jpeg]]

就生成了最终的rubbish 31号。

（3）那么之后如果修改了某个源文件------比如修改了ai.c文件，只需要重新编译这一个文件就行了，就运行：

[[./Images/image00681.jpeg]]

这样就编译出了新的ai.o。

（4）得到新的ai.o之后再运行：

[[./Images/image00682.jpeg]]

重新链接一下，新的rubbish
31号就完成了。这样就省去了重新编译那些没有改动过的文件的时间。

*** 8.3.3　make的机制

不过这样编译虽然节省了编译的时间，但是敲起命令来也挺麻烦的。有没有更方便的方法呢？当然有。

【大项目需要规划】

其实用户完全不必每次都敲一大长串的gcc命令来编译程序。如果是那样，我们Linux内核有上千个文件，要是编译一次，光敲命令就得敲一上午。

那个GCC施工队毕竟只是个施工队，你要是盖个小厨房，垒个猪圈，这样的小东西直接找他们没问题。直接一编译：“gcc砖头-o猪圈”就出来了。可如果要盖个CBD商圈，里边什么银行、商场、写字楼、炸油条的、卖臭豆腐的、修理自行车的等，一应俱全，这么大的一个工程，你光叫个施工队来肯定搞不定。这得有人进行合理的统筹规划，设计施工方案，然后再让施工队去具体施工。这个规划的人谁呢？按照懒蜗牛现在的做法，这个规划人就是懒蜗牛自己，但他自己又没这本事，怎么办呢？这时候他就需要专业的规划人，能够指挥施工队的包工头------make。

【make的重要作用】

make也是一个程序，像上面说的一样，他就是负责控制整个施工过程的（也就是编译过程）。对于比较小的程序，就一两个.c文件，根本用不着make出马，GCC施工队去编译就行了，因为源文件的结构关系不是很复杂。可是对于稍大一点的程序，像狐狸妹妹、心有灵犀、星爷啊，基本上所有常用的软件，都足够复杂到需要make来对编译过程进行管理。

如果软件大了，编译的时候就不能简单地把一大堆.c的源文件统统一次性编译成一个二进制文件，这种方法太粗鲁了。应该像上面介绍的那样，把一堆.c文件编译成一堆.o文件，然后再把.o文件链接成一个成品的二进制文件。有改动的时候只更新单个的.o文件就可以。

*提示：*不一定非要把每一个.c文件编译出对应的.o文件，可以几个.c文件生成一个.o，一切根据具体代码的需求来设计。

但是这个过程如果由人类来负责，就不那么靠谱了。他们的大脑不可靠，不一定能记清楚这次改了哪些文件，应该更新哪个.o文件。于是，make就义无反顾地挑起了这个重要的担子。当然make也不能靠凭空的想象就来指导包工队干活，什么事情总得有个规划，make也需要一份施工的规划书，这份规划书就是Makefile。

*** 8.3.4　Makefile的基本格式

Makefile，顾名思义，就是make用的file。这就相当于一份施工的规划，上面写着整个工程分为几个模块，先用哪几个文件编译成一个什么什么.o，再用哪几个文件编译出一个.o，再怎么怎么一链接，最后得到编译好的二进制程序。

make就根据这份文件来指导GCC他们进行施工。当有某个.c文件被修改之后，make能够根据文件的修改时间智能地判断出哪些模块需要重新编译，重新链接，然后就去让GCC重新编译那些改过的文件，最终生成新的二进制程序。

有了make，写好了Makefile文件，就省去了用户敲一大堆编译命令的烦恼。只要敲一个make命令，其他的，就交给make去做吧。他办事，你放心。

【简单的Makefile示例】

比如说，有这么一个工程，包含了3个文件（咱就不拿懒蜗牛同学的rubbish系列打比方了，源文件太多，还乱）。分别是：main.c、part1.c、part2.c。那么我们就可以试着写出一个用于编译这个工程的Makefile如下：

[[./Images/image00683.jpeg]]

乍一看可能您不太明白，没关系，咱们慢慢说。当用户运行make命令的时候，make就会来到当前目录下，首先在这个目录里查找Makefile文件，如果没有，就找makefile文件（Linux区分大小写嘛）。如果都没找到，就报错。如果找到了，那就打开Makefile看看该干些什么。

【Makefile中的基本书写格式】

首先我们看到，这个Makefile大致分成了4段，每段的格式都差不多。我们把它总结为这样的格式：

[[./Images/image00684.jpeg]]

对照着来看，先看第1段：

[[./Images/image00685.jpeg]]

这段的“目标”是all，all是一个make的关键字，当用户运行make并不加任何参数的时候，make就会来Makefile里找到目标为all的这一段，并且从这里开始干活。

然后，这段的“原料”是main.o、part1.o、part2.o这3个文件。也就是说，要想达到all目标，需要先有这3个文件。于是make就会查找现在是否有这3个文件，一看------没有！

没有没关系，make会继续往下找，这回的目标，就是查找怎么才能搞到main.o文件，结果一找，还真有，第2段就是：

[[./Images/image00686.jpeg]]

这段的“目标”就是make正要找的main.o，于是赶紧看看原料，是main.c文件。这个文件已经有了。那么怎么用这个原料加工成main.o？看方法：gcc
--c
main.c。哦，原来运行这条命令就行了啊，于是make就会去调用gcc，来编译出main.o。

*提示：*“加工方法”一行的前面有且必须有一个Tab制表符，不能顶格写，也不能用空格代替Tab。

有了main.o，make再回去看第1段，发现还需要part1.o，part2.o，跟main.o的处理方法一样，根据3、4两段就可以编译出来了。原料都齐全了之后，make就再根据第1段的“加工方法”运行“gcc
main.o part1.o part2.o -o mybin”，生成了最终的目标。

另外，刚才说了，如果不加参数，make就去找“目标”是all的段落。其实用户也可以通过参数指定make的目标，比如用户运行：

[[./Images/image00687.jpeg]]

意思就是去完成Makefile里面，“目标”是main.o的那段任务。于是make就根据Makefile里的记录，只编译出一个main.o来。

*提示：*如果Makefile中没有“目标”为all的段落，并且运行make没有指定参数，则make会执行Makefile中的第1个段落，无论目标是什么。

【根据时间决定动作】

当某一个.c被修改了之后，用户应该如何编译呢？简单，还是只执行make就可以了。剩下的事情，就交给make去做吧。

make会检查每一个“目标”和“原料”的最后修改时间。比如part1.c文件被修改了，那么make就会发现，part1.o的创建时间要早于part1.c的最后修改时间，这说明part1.o需要被重新编译。于是他就会按照这一段的“加工方法”，再次运行gcc
-c part1.c，来编译出新的part1.o。

那么现在part1.o的创建时间又比最终的mybin新了，于是make又根据第1段的加工方法执行了gcc
main.o part1.o part2.o -o
mybin，把新的part1.o和没有变动的main.o、part2.o链接成了新的mybin文件。

【多种多样的“加工方法”】

上面的例子里，加工方法一行基本都是编译或链接命令。其实，宪法里并没有规定“加工方法”必须是跟gcc有关的。其实加工方法这一行写任何命令都可以，并且不一定只写一行，写几行都可以，只要是挨着就行。比如一般的Makefile里都会有类似下面这样一段，用于清理编译结果：

[[./Images/image00688.jpeg]]

这一段的目标是clean，没有原料。用户执行：make
clean的时候，make就会找到这一段，并且发现不需要原料，于是直接执行“加工方法”，于是就删除了所有.o文件和最终的编译目标文件。于是整个源代码的目录里恢复到了编译之前的样子。

与此类似的还有make install，一般就是下面这个样子：

[[./Images/image00689.jpeg]]

也就是在确认当前目录下有mybin这个编译好的文件后，把这个文件复制到系统中的相应目录，就完成了安装。

** 8.4　分析师

一说到make，很多人都记得编译源码包的时候，经常在进行make之前还要运行“./configure”命令，这个命令又是干什么的呢？

*** 8.4.1　懒蜗牛的日记D

“2010年11月15日　晴

这个make工具果然方便啊。听说Windows下的VC其实也使用了类似的东西，只不过把它们都用图形界面封装了起来，所以我看不到了。看来还是在Linux下学习编程才能了解到一些本质的东西呀。

我还看到很多以源码包发布的软件，都会有一个configure脚本，成功地运行了这个脚本以后才能去运行make命令。这个脚本又是干什么的呢？”

*** 8.4.2　源码软件的平台依赖

懒蜗牛同学最近是越来越不着调了，竟然想把他最新写的那个rubbish
1115号发布到网上去！祸害我们一个系统还不够，还要残害多少青春懵懂的Ubuntu啊。

【rubbish 1115号------放到哪都是个祸害】

其实那个rubbish
1115号也干不了啥正经事，主要就是能陪懒蜗牛同学玩“猜拳”的游戏，所以才这么受宠。说来也怪，我们软件源里面有那么多游戏，懒蜗牛都没兴趣，不知道为什么就对这么个石头、剪子、布的随机函数情有独钟。不过也难说，毕竟是他自己编的嘛，谁的孩子谁不爱呢。可是您自己喜欢那就偷偷摸摸自己玩就行了，干嘛非要发布到网上让他去祸害别的电脑呢？

这家伙经常申请了内存不释放，有时候还假死，如果是不明所以的人用了这个程序，没准还抱怨我们Linux系统不稳定呢。当然，发牢骚归发牢骚，懒蜗牛的命令我们还是得执行，Firefox就正忙着把rubbish
1115号传到网上去呢。

过了一会儿，狐狸妹妹忍着笑就过来了：“你知道懒蜗牛怎么发布他那个程序么？懒蜗牛直接把编译出来的二进制文件贴到了论坛里面。哈哈，他以为这样直接就能运行呢。笑死了。”

【二进制程序------不是放到哪都能运行】

嗯，看来懒蜗牛同学还有很长的路要走啊。这个二进制文件看上去就是单一的文件，但其实他运行起来是需要很多库文件来协助的，不是拿到哪都能运行的。在他们Windows界其实也是这样：Windows
98的程序直接拿到Windows XP下不一定能运行；Windows
XP的程序也有很多装不到Windows
7上。但是由于他们的版本比较少，而且系统的各种库和接口等都比较统一，所以也有不少的绿色程序直接复制到系统里就能运行。因此很多人觉得程序就是一个EXE文件，复制到哪里都可以运行。

懒蜗牛写的这个程序，如果复制到一个和我们相同的系统上，肯定可以运行（也肯定可以造成内存泄漏和假死，哼哼）。可是不一定别人的系统就跟你的系统一模一样啊！尤其我们Linux，发行版五花八门，就算相同的发行版，版本不一样，也不一定能行。如果系统里没有这个程序所依赖的那些库，这个程序肯定是运行不起来的。要想知道一个程序依赖于哪些库，可以用ldd命令来查看。

【查看依赖关系------看他到底在哪能运行】

我趁懒蜗牛不注意的时候叫来ldd，运行了一下ldd
./rubbish1115，看看这个软件都依赖什么。ldd向我汇报如下：

[[./Images/image00690.jpeg]]

看来依赖的还不是很多，算是最基本的了，可照样不能随便放到别的系统上运行啊。比如这个“ld-linux-x86-64.so.2”，明显只有64位系统才可以。“libc.so.6”虽然是个系统就有，但是版本也得合适，不合适也不行。这也是为什么Linux上发布的软件好多都是源码包的原因，因为系统环境实在是各式各样，还是把源码放到目标系统上编译一遍更方便。然而我这些话也就跟您说说，懒蜗牛听不见我说话的，所以他还是把那个rubbish金刚直接贴到网上了。

*** 8.4.3　一个标准的源码包安装过程

几天之后，懒蜗牛就收到了应有的回应。

“这个程序在我这运行不了啊？”

“楼主我用SUSE啊，你编译出个SUSE版本的来吧。”

“楼主再好好看看吧，我这里运行不了。”

“我是32位机啊，运行不了这64位的。楼主提供个32位的版本吧。”

......

懒蜗牛同学终于意识到二进制文件不是放到哪都能执行的，可要让懒蜗牛去给每个人编译一个针对他们系统的版本也是不大可能的。好吧，那就发布源码！

可是问题又来了，源码发布的软件包应该是什么样子呢？为了避免再次体现自己的无知，懒蜗牛从网上下载了一个lynx2.8.7.tar.gz软件包。这个Lynx是一个字符界面的浏览器，懒蜗牛倒不是想用它，主要是这个软件体积不大，依赖也不多，正好拿来体验一下源码包的安装。

【要装源码包，先打开看看】

像“.tar.gz”这样的源码包是下载软件时最经常遇到的了。另外还有“.tar.bz2”格式，跟“.tar.gz”的没什么区别，只是压缩格式不同而已。就类似于一个是RAR，一个是ZIP。那么这样的软件包怎么装呢？当然是先把包解开再看了，得先解开压缩包看看里面是什么内容才能知道怎么装啊，就像我问你RAR包怎么装，你能知道么？

“.tar.gz”格式的文件，就像是一个邮局寄来的包裹。你收到一个包裹后怎么办？当然是先打开啦！先找剪子、小刀之类的工具把包裹拆开，然后看看里面有什么东西，根据里面东西的不同来决定怎么处理。里面要是家里寄来的松子核桃之类的特产，就赶快吃了；要是比较难吃的松子核桃什么的，就跟同事分着吃了；要是部手机，就赶快拿出来试试；要是下面还有把手枪，就赶紧拿刚才那手机报警。

【解压TAR包的工具】

这些大概不用我说，智力正常的人都应该知道怎么做。其实TAR包也是如此。拿到一个TAR包之后，先用你的工具把TAR包拆开。工具是啥？有道是解铃还须系铃人，TAR打的包，当然还用TAR来解了。一般解压一个TAR包的命令是：

[[./Images/image00691.jpeg]]

这里，xzvf是tar命令的参数，我们分别解释一下。

　x------参数x意味着要做解包的动作，与之相反的是c，也就是打包的意思。

　z------意思是这个包是用gzip压缩过的，需要先调用gzip解压。

　v------显示解压的过程，也就是打印出解压出来的文件。如果没有这个参数，则在解压过程中没有任何输出。

　f------指明要解压的文件。

另外还有一些常用的参数，也顺道介绍一下。

　j------意思是这个包是用bzip压缩过的（也就是.tar.bz2格式），需要先调用bzip2解压。

　c------这个参数的意思是要做打包的动作，和x参数相反。

　C------注意这个参数是大写的C，用于将解压缩后的文件存放到指定目录。如果没有这个参数，则默认解压到当前目录。

当然，也可以用那个叫做文档管理器的家伙，他的中文名字叫归档管理器，他的英文名字叫file-roller。不过其实他只是个负责用图形界面和用户交流的家伙，真正干活的还得是tar。

*提示：*tar命令后面的参数顺序并没有特定要求，但要确保文件名紧跟在f参数后。如“tar--vzxf
xxx.tar.gz”，“tar --xvzf xxx.tar.gz”都是正确写法。

TAR包解开后，一般会得到一个目录，里面有很多的文件。然后干什么呢？有的同学记起来了，看看里面的东西啊。

一般包里面应该有个README文件。文件里写着这个软件是干什么用的、怎么安装、怎么用、作者是谁、何方人士、爱吃什么、身高多少、腰围裤长等信息。也可能安装的方法写在一个叫做INSALL的文件里。总之，应该有相应的文档文件来告诉你这个软件怎么装。不过也有时候软件的作者不厚道，或者忘性大，没有写README或者INSTALL文件。或者文件是有，但是没说清楚到底怎么装，那怎么办呢？只好去给作者写个E-mail鄙视他了。

*** 8.4.4　configure的作用

懒蜗牛把下载来的软件包移动到了他的家目录下，然后运行：

[[./Images/image00692.jpeg]]

把这个压缩包解压了出来。解压之后是一个目录，叫做lynx2-8-7。懒蜗牛继续运行：

[[./Images/image00693.jpeg]]

这样就进入了刚刚解压出来的目录里面，用ls看了一下，发现有很多文件：

[[./Images/image00694.jpeg]]

其中有个叫做INSTALLATION的文件，里面很显然应该写着安装方法。于是懒蜗牛同学打开这个文件看了看，内容很多。不过关于安装，他看到这么几行：

[[./Images/image00695.jpeg]]

看来是运行这样两个命令就可以了。于是，懒蜗牛同学按照说明，运行了：

[[./Images/image00696.jpeg]]

这个configure是干什么的呢？

【施工之前，先勘察好环境】

我们知道GCC施工队听make包工头的指挥，make包工头根据Makefile安排工作。这样，如果想把一堆源码编译成二进制的程序，只要执行一下make。执行之后make会在当前目录下寻找Makefile，然后按照上面写的方案，指挥施工队：在这盖个大裤衩，在那盖个水煮蛋，再在中间垒个鸟窝。然后施工队按照命令一点点施工，直到最终完成任务。

然而事情有时候并不是那么简单。没准包工头make下达建设大裤衩命令之后，施工队回来报告：这地方挨着鞭炮厂啊，盖大裤衩还不烧着了？包工头说：那先盖水煮蛋吧。施工队又报告：这地方常年干旱，地下水位也低，这点水连泡面都不够，别说煮蛋了。包工头只好说：那就先盖那鸟窝，总行了吧？施工队再说：鸟窝倒是能盖，就是这地方不通天然气，点不着窝里那火炬啊。

【分析师出马】

遇到这些问题，都是由于开工之前没有对施工的环境、现有的材料进行合理分析导致的。那么我们的这个configure，就是能够解决这种问题的一名分析师。

configure跟make不一样，他并不是常驻在我这里的软件，而是每个源码发行的软件自带的一个脚本。简单点说，铁打的make只有一个，流水的configure每个软件一个。

有了configure之后，编译软件的步骤就多了一步------./configure。让这个分析师首先开始工作，他会检查当地的情况，有什么材料、什么库、什么编译器之类的，都检查一遍，然后因地制宜地设计一份Makefile。如果有足够的水，才允许煮蛋；有远离火种的安全空间才能晾裤衩等。如果条件不满足，configure就会报告错误，告诉用户这里缺少什么，等用户想办法弄齐了再来编译。如果条件满足可以施工，configure就会出一份Makefile。注意，一般configure调查前，目录下是没有Makefile文件的（当然，没有configure的情况另说）。

懒蜗牛运行./configure之后，得到了如下输出结果：

[[./Images/image00697.jpeg]]

这中间省去了几百行，无非就是“checking for xxxxxx...
yes/no”这样的格式。这些输出的意思，就是说configure在对我们系统进行检查，报告有什么材料，没有什么材料。如果不是必需的材料，没有也就没有了。如果是必需的东西没有，那么confiugre就会报错并停止。

最终，我们这个系统里的东西还比较全，configure发现可以施工，于是就生成了Makefile文件。

*提示：*Makefile文件中可以引用另一个Makefile文件，因此一个软件工程中，经常可以看到不同源码目录下都有一个Makefile文件。

生成了Makefile文件，于是懒蜗牛同学就运行make命令：

[[./Images/image00698.jpeg]]

make开始工作，指挥着GCC施工队进行编译。由于软件很小，马上就编译完了。编译完成之后，就在当前目录下生成了一个叫做lynx的二进制文件。不过如果就这么放在这，运行起来很不方便，所以懒蜗牛同学继续运行了：

[[./Images/image00699.jpeg]]

这才把这个软件安装在了我们系统里。

*提示：*如果要删除源码安装的软件，可以在源码目录下运行“make
uninstall”。作为一个标准的GNU软件，生成的makefile中应该都包含有uninstall的定义，但实际有一些不规范的软件，没有提供uninstall的方法，就只能手动删除了。

【照猫画虎】

有了这么一番感受之后，懒蜗牛知道了一个源码发布的软件包的大概样子。于是照着人家这个软件包，对比一下自己的这个软件。一看，Makefile是现成的，只要再增加一个configure脚本，检查一下系统中有没有gcc之类的编译工具及库文件等就可以了。

要写这么个脚本，需要用到Shell脚本编程的知识。懒蜗牛之前虽然学过一点，但那都只是些皮毛。现在要真去写configure脚本，还真有点力不从心。怎么办呢？对，照猫画虎！看看那个Lynx的configure怎么写的，跟着学就好了。懒蜗牛想得挺好，叫来gedit打开configure一看就傻了------洋洋洒洒连注释带语句一共36379行！这得看到哪年啊！

*** 8.4.5　扩展阅读：黄金搭档------tar和gzip

前面介绍到tar命令，基本上每个Linux系统都会带着这个软件，我这里也是。这个软件是干什么的呢？

tar就是个打包裹的，不过他可不是邮递公司的那种，不会把打好的包扔来扔去。他的能力有点像Windows
7那里的WinZip，他能把很多文件和目录收拾在一起，打成一个包裹，也就是生成一个tar包文件。

*提示：*过去的计算机使用磁带作为长期存储数据的介质（现在依然有使用磁带作为存储介质的场合），tar命令最初就用于将数据打包存储在磁带上。tar就是Tape
Archive（磁带归档）的缩写。

可是跟WinZip不一样的是，tar只管打包，不管压缩。原来那些零碎的小文件有多大，打成tar包之后还是多大，只是变成一个整个的文件了而已。有人说，那我想压缩怎么办？别急，我这里还有另一个软件，叫gzip。这个软件就是专门负责压缩和解压缩的，但是他只能压缩单个文件，不能像WinZip那样能压缩一个目录里的很多文件。

这样，tar和gzip就成黄金搭档了。要想实现WinZip那样的功能，就得tar和gzip联手协作。比如有个目录叫aaaa，里面有好几十个文件，总共有10
MB大小。想要压成ZIP那样的压缩包，那就先让tar出手，把aaaa目录打成一个包裹文件------因为gzip只能压缩单个文件嘛。这样tar就把这个目录打成了aaaa.tar文件，这个文件还是10
MB大。然后由gzip出场，把这个文件压缩，压缩完了得标明一下啊，所以就又把文件名改了，叫做aaaa.tar.gz，表示这个文件经过了gzip压缩。这时候这个文件就小了，可能5
MB，也可能7
MB。有时候还有叫xxx.tgz的包，也是一个意思，只是把.tar.gz的扩展名合并了而已。

** 8.5　规划局

configure脚本也好，Makefile文件也好，其写法都是有一定规律可循的。并且他们的内容都是有一定复杂度的。对于有规律还复杂的东西，就可以想办法让程序自动实现。

*** 8.5.1　懒蜗牛的日记E

“2010年12月20日　回冷

总算是把代码发布到网上了。很多热心的网友提出了不错的建议和意见。才发现我写出来的程序真的很白痴。经过了这么一个过程，确实在编程方面长进了不少，了解了很多以前不了解的事情。

还有件最不了解的事，就是configure脚本。好几万行的代码啊！牛人们是怎么写出来这么复杂的脚本的？而且好像很多源码包里的configure脚本都差不多，难道都是一个专门给别人写脚本的大牛写的？不解中......”

*** 8.5.2　自动生成的configure脚本

懒蜗牛的rubbish
1115号放到网上去之后，网络上的众多牛人们，为他修改了很多问题，把他调教得规规矩矩的。现在的rubbish
1115号，也不浪费内存了，也不乱改文件了，也不死机了，腰不酸了，背不疼了，现在我们都开始喜欢这个家伙了。他好，我们也好。这大概就是开源的力量吧。我们现在都不好意思叫他rubbish了，直接叫1115号。

【3万行的脚本真不是人写的】

1115号发布前的那段时间，我们几个软件都很纠结，担心懒蜗牛运行他，担心系统被他搞坏。那时候懒蜗牛也很纠结，纠结的是怎么能够把他发布到网上去。

那时候懒蜗牛整天研究Shell编程的技术，天天对着那3万多行的configure代码，出神地看着，嘴里念叨着：“这是哪位神仙大姐写的脚本啊......这么多行得写多长时间啊......”直到有一天，他终于将眼睛聚焦在了configure文件前面的那段注释中的一句话：

[[./Images/image00700.jpeg]]

懒蜗牛顿时如醍醐灌顶一般，看着这一行注释，看着这个“Autoconf”，心里反复地呼喊，声音越来越强烈，直到终于爆发，脱口而出：“原来这脚本是用软件自动生成的啊！”顿悟之后懒蜗牛立刻叫来狐狸，本着“内事不明问老婆，外事不明问Google”的宗旨，直奔www.google.com而去。

【3万行的脚本到底是谁写的】

一番查找后，懒蜗牛终于大致了解了Autoconf这个软件。

咱说gcc、cpp、as和ld他们4个命令就像施工队，make就是包工头，configure就是分析师，那这个Autoconf大概就是市政规划局了。有了他，什么Makefile，configure脚本，全都不用自己写，都由他一手代办。

规划局的工作，就是根据源代码的结构和组成，来决定如何根据环境，因地制宜、就地取材地施工，最终派出一个专门的分析师------也就是configure。之后在安装的时候，configure就可以根据目标系统的环境及既定的几套施工方案，来写出合适的Makefile，再交给那里的make去指导施工。

*** 8.5.3　规划局的成员组成

虽然软件叫做Autoconf，但其实并不是只有他一个人。既然叫做规划局，那就不可能是一个人，你见过哪个地方的规划局就一个局长了？他们这规划局成员有4个：Aclocal、Autoconf、Automake、Autoscan。要想自动创建Makefile和configure脚本，就得跟这哥儿4个说。虽然可能你已经自己写了Makefile了，只是缺少configure。但你写的那个不行，他们向来是买一送一，搭配销售。你写的Makefile是没用的，必须得用他们创作的configure和Makefile，具体情况咱们待会儿再说。

这4个人各有各的工作，各司其职：Autoscan负责检查源码目录结构，看看都有哪些需要编译的文件；Aclocal用于检测一些编译环境相关的内容，例如使用哪个编译器；Autoconf负责生成configure脚本；Automake负责生成Makefile的蓝本------makefile.in。

*** 8.5.4　图纸审查

经过一番查找，懒蜗牛同学已经了解了Autoconf这一组软件的使用了，现在他要开始为他的程序加入configure脚本和Makefile了。

首先，懒蜗牛来到存放1115号源码的那个目录，目录里现在有main.c、board.c、ai.c、board.h和ai.h几个文件（1115号已经被网络上的热心爱好者们改装得很精简了）。然后懒蜗牛运行了这个命令：

[[./Images/image00701.jpeg]]

那么“autoscan”这个命令是干什么呢？

【Autoscan的职能】

Autoscan是负责初步审查项目的。你的工程图纸画好了，得先拿给他看。他看了一遍之后，会给你写个报告。怎么还写报告？当然了，规划局嘛，审批个这处理个那的，不都是部门之间报告来、报告去的么。Autoscan写的这个报告叫做confiugre.scan。

但是这个Autoscan写的confiugre.scan报告，基本上是驴唇不对马嘴。Autoscan这家伙，要论本事，抬举他点说是一般。图纸他都不一定看得懂。所以多数情况下，还得动手改改。改过的报告还得改个名字，叫做configure.in。

正说着，只见Autoscan同学大摇大摆地来到1115号的源码目录，东瞅瞅，西看看，挨个打开每一个文件，终于搞清楚了各个文件之间的关系。然后他按照一套很官方的格式，写了初步审核报告书，存了个文件名叫做configure.scan的文件，之后就回去睡觉去了。报告书的内容大约是这样：

[[./Images/image00702.jpeg]]

【修改报告】

懒蜗牛拿到报告书，当然知道，这只是万里长征才走完了第一步。赶紧叫来gedit小弟，修改报告书。他把一些完全不着边际的东西删掉，或者注释掉（也就是在那一行的前面加上#号）修改后的报告书是这个样子的：

[[./Images/image00703.jpeg]]

看着挺多，其实真正有用的就下面这么几行。

　AC\_INIT(main.c)------这一句说明这个工程的主要图纸是哪个文件。

　AM\_INIT\_AUTOMAKE(rubbish1115,1.0)------这一行是汇报这个项目的名称，叫做rubbish1115，版本是1.0版。

　AC\_PROG\_CC------这一句是说，最终的configure需要检查C语言编译器是否正常。

　AC\_OUTPUT(Makefile)------这一行是说明，最终的configure需要产生的文件，叫做Makefile。

其他的，都是废话。

*** 8.5.5　项目复审

懒蜗牛同学把改好的报告改名为configure.in，然后就去叫Aclocal来看报告了。也就是运行了这个命令：

[[./Images/image00704.jpeg]]

【Aclocal的职能】

Aclocal负责复查Autoscan的报告，并且根据里面的内容，做一些详细的注解和说明。并且把这些注解和说明也写成一个报告，叫做aclocal.m4。

这里所谓的说明，主要是针对configure.in中的一些宏定义，进行详细的阐述。比如configure.in中写的“AC\_PROG\_CC”，只是说明了在最终的configure脚本中，要加入检查编译器的部分。但是编译器怎么个检查法？检查哪个编译器？都没说明白。这些在Aclocal的报告中都会有详细的解释------编译器要使用GCC，configure脚本中，要检测系统是否有GCC编译器。

随着懒蜗牛按下回车键，只见硬盘中的Aclocal不紧不慢地起床，伸着懒腰走进工作间，拿起桌上的茶水杯，掀开杯盖，撇一撇浮在水面上的茶叶，拿嘴吹一吹，喝一口，盖上杯盖，放下杯子，开始看报告。扫了两眼后，就知道是怎么回事了，也不用懒蜗牛多说话，直接写了一份复查报告，叫做aclocal.m4，扔给了懒蜗牛，然后就赶紧回去继续睡觉去了。要说人家Aclocal的办事效率还真是不错，毕竟人家写的aclocal.m4不用懒蜗牛修改，直接就可以往上交了。

*** 8.5.6　派遣分析师

主要领导终于出场了，懒蜗牛赶紧又叫来Autoconf，让他指派分析师configure。也就是运行了这个命令：

[[./Images/image00705.jpeg]]

【Aotuconf的职能】

Autoconf就是专门负责指派分析师。他看了两份报告后，一般会沉思一会儿，说说目前如何困难，人手不足之类的话。最终在用户一再的苦苦哀求，以及威逼利诱之下，无可奈何地说：好，就给你派个分析师吧！如果顺利，一个configure脚本就诞生了。

不过懒蜗牛遇到的Autoconf这回倒是没太耽搁，看了configure.in和aclocal.m4两份报告后，很快就生成了configure脚本。由于懒蜗牛同学的这个程序很简单，因此configure脚本的内容也只有4千多行，不过麻雀虽小，五脏俱全，跟正规的configure脚本没有差别。

*** 8.5.7　编写施工计划

那么有了configure脚本就完事了么？当然没有！都给你介绍了规划局有4个人，第4个还没出场呢，怎么能完呢？

这个Autoconf生成的configure要想去工作，是有条件的。他必须搭配规划局制定的施工计划------makefile.in才能工作。有人会问，这个makefile.in是什么啊？我已经有了Makefile还要他干什么？咱不是说了么，你的那个Makefile，甭管写得多么天花乱坠，也是白搭，人家规划局派出来的configure根本都不会瞧上一眼，人家configure要写自己的Makefile来用。你又得说了，那你这configure就赶快写出来自己的Makefile啊。你看你，不讲道理了不是，这Makefile文件那么复杂，哪能就这么凭空写出来，总得有个参考，有个蓝本，有个全市统一Makefile模板之类的东西吧。这个模板，就是makefile.in。那么这个文件从哪来呢？这就用得着Automake了。

【Automake的职能】

Automake的职能就是专门写configure需要的makefile.in（您看咱规划局给您搭配得多好）。不过Automake也不能直接就把makefile.in写出来。人家比较忙，这一点您也得理解。局里那么多重要的事情，今天学习，明天会餐，后天考察什么的。就算不会餐不考察，谁也免不了上个网、偷个菜、斗个地主扫个雷吧？

所以，Automake是没工夫从头给你写出一份makefile.in的，你得先给Automake写好一个框架，然后人家才好动笔。这个框架，就叫做Makefile.am。有了这个框架，交给Automake，他就可以给你写出makefile.in了。

【编写Makefile.am】

懒蜗牛同学没有打听好这个步骤，他直接找来Automake，让他写makefile.in。

Automake拉着长声说：“这个......我们这里呀，工作也比较忙嘛......要按说呢......这个文件我是应该给你写滴。不过我们这里每天这么多人来，我要是一个一个写，哪天才能写完呀。所以同志啊，为了帮助我们提高办事效率，也为了你自己早点拿到Makefile的蓝本，更为了我们能够早日实现共同富裕奔小康------您是不是自己先写个草稿给我，我也好帮你赶快写出蓝本呀。”

懒蜗牛听得都快扔板砖了，心说不就你想犯懒这么点事么，至于跟我废这么多话么。赶紧动手写草稿吧，这个草稿叫做Makefile.am。好在内容很简单：

[[./Images/image00706.jpeg]]

　第1行，是行业规定，一般都这么写。

　第2行，说明编译之后的程序应该叫做rubbish1115。

　第3行，说这个工程包括main.c、ai.c、board.c这3个文件。

*提示：*第1行的AUTOMAKE\_OPTIONS=foreign是Automake的选项。Automake主要帮助开发GNU软件的人员来维护软件，所以在执行Automake时，默认会检查目录下是否存在标准GNU软件中应具备的文件，例如NEWS、AUTHOR、ChangeLog等文件。设置为foreign则Automake忽略掉对这些文件的检查。

就这么简单，草稿就写完了。之后再把Automake叫出来，总算是给写出了Makefile的蓝本------makefile.in。

做完了这些之后，这个工程就可以打包发布了。用户拿到这个包，解开之后，就直接依次运行“./configure”、“make”、“make
install”就把软件安装上了。

懒蜗牛欣喜地看着自己整出的这个像模像样的软件，看看configure脚本，4千多行！心想：不知道的人看见这个脚本一定以为我是大牛吧，哈哈哈。再运行一下configure，看看生成的Makefile，500多行，哈哈，俨然感觉自己已经成为高手了一样。于是，在懒蜗牛的YY中，我们结束了那一天的工作。

** 8.6　本章小结

咱们的懒蜗牛同学创造了不少的rubbish之后，算是对Linux下面的软件开发有了深入一些的了解了。什么编译原理、Makefile，还有怎么使用configure，怎么使用Autoconf，全都体验了一下。

从这以后，懒蜗牛算是更理解这"乌棒兔"系统了。理解它的开源；理解它的简洁；理解它的效率；理解它的灵活。从此，懒蜗牛和"乌棒兔"幸福地生活在了一起......
